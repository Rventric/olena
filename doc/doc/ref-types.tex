
This section describes the basic types available in Olena.  By
\emph{basic types} we roughly mean any type that can be used as pixel
value in an image, such as \code{int}, \code{float}, etc.  This also
includes composite types like complexes, points, vectors, and colors.

For completeness we will discuss matrices too, although these are not
deemed basic they are relevant to the description of vectors.

Other types not discussed here, but worth to mention, includes
images and iterators.  These will be described in a separate section.


\subsection{Hierarchy of types}

Here is a list of basic types supported by Olena.  Although it is
presented hiarchically, this does not means that these types are
implemented hierarchically in the C++ code.

\begin{list}{--}{}
\item Scalar types
  \begin{list}{--}{}
  \item Integers
    \begin{list}{--}{}
    \item Signed
      \begin{list}{--}{}
      \item C built-in types:
	\begin{list}{--}{}
	\item \code{signed long}
	\item \code{signed int}
	\item \code{signed short}
	\item \code{signed char}
	\end{list}
      \item Olena types: \code{int_s<BITS, BEHAVIOR>}
      \end{list}
    \item Unsigned
      \begin{list}{--}{}
      \item C built-in types
	\begin{list}{--}{}
	\item \code{unsigned long}
	\item \code{unsigned int}
	\item \code{unsigned short}
	\item \code{unsigned char}
	\end{list}
      \item Olena types: \code{int_u<BITS, BEHAVIOR>}
      \end{list}
    \end{list}
  \item Floats
    \begin{list}{--}{}
    \item C built-in types
      \begin{list}{--}{}
	\item \code{float}
	\item \code{double}
      \end{list}
    \item Olena types
      \begin{list}{--}{}
	\item \code{sfloat}
	\item \code{dfloat}
      \end{list}
    \end{list}
  \end{list}
\item Enumerated types
  \begin{list}{--}{}
  \item C built-in \code{bool}
  \item \code{bin}
  \item \code{label<TYPE>}
  \end{list}
\item Vectorial types
  \begin{list}{--}{}
  \item FIXME: complex
    \begin{list}{--}{}
    \item $a+ib$
    \item $r\exp{i\theta}$
    \end{list}
  \item points
    \begin{list}{--}{}
    \item \code{point1d}
    \item \code{point2d}
    \item \code{point3d}
    \end{list}
  \item \code{vec<N, T>}
  \item FIXME: colors
  \end{list}
\item FIXME: Matrices
\end{list}

\subsection{Scalar types}

All types listed under \emph{scalar types} in the above enumeration,
can be used together with most common arithmetic operations ($+$, $=$,
$<$, ...).  However Olena's type do not behave exactly like the
the built-in types.  We believe it's safer To
use Olena's type instead of the built-in types.

\subsection{\code{int_u<N, BEHAVIOR=abort>}}

This template can be used to define unsigned integers of various size
and behaviors.

\code{N} is the number of bits used to store the
integer.  So \code{int_u<7>} can hold values from the range $0..127$.

\code{BEHAVIOR} must be one of \code{strict}, % \code{cycle},
\code{saturate}, or \code{unsafe}, this describe how the integer will
behave on overflows (and underflows).

\begin{description}

\item[\code{strict}]

This is the default.  An overflow triggers an assertion which halts
the program.

Checking for overflow incurs some run-time overhead, but this is
dissabled entirely when compiling with \texttt{-DNDEBUG} once the
program is debugged.  (\code{strict} and \code{unsafe} are identical
when \code{-DNDEBUG} is used.)

%% \item[\code{cycle}]
%%
%% This is the behavior of modular integers.
%% \code{int_u<8,cycle> i = 256;} will define \code{i} with the value
%% of \code{0}.
%%
%% Note that this wrap-around is the behavior of the C built-in types.
%% (Compare \code{unsigned char i = 256;}.)
%%
%% This overflow checking has no run-time overhead when the type can be
%% mapped to a built-in types; typically when \code{N} is 8, 16, or 32.
%% For other values of \code{N}, you get the overhead of a bitwise
%% \code{and} (like if you did it manually).
%%
%% Using the \code{range} template described later, you can get cycling
%% types on an arbitrarily defined range.  In this case, the overhead
%% incured is that of a division (a modulo, actually).

\item[\code{saturate}]

These are bounded types, the bounds of which cannot be escaped.
Assigning a value larger (resp. smaller) than the maximum
(resp. minimum) of the type, is like assigning this maximum
(resp. minimum).

\begin{lstlisting}{}
int_u<7,saturate> i = 130; // i equals 127
i += 10;	           // i still equals 127
i -= 10;                   // i equals 117
\end{lstlisting}

This behaviour is useful for tasks like histogram construction where a
value is always increased but should never overflow.

Using the \code{saturate} behavior always incurs some overhead.
(The same overhead you would get by checking the overflow manually.)

\item[\code{unsafe}]
This is the behavior of the underlying built-in type: no overflow
checking.  (This is mainly used internally, to declare the temporary
variables used by all the other behaviors.)

\end{description}

Note that overflow checking matters only with operations that
\emph{modify} the current variable (assignments, construction, self
operators like \code{+=}, \code{-=}, \code{*=}. etc.), not with
operation returning new variables (like \code{+}, \code{*}, etc.).

If possible, operators that return new variables will extend the type
of the operand.  For instance when you add two \code{int_u<8>}
variables, the \code{+} operator returns an \code{int_u<9>} temporary
variable.  This ensures that there is no overflow.  If you then assign
this temporary variable to a \code{int_u<8>} variable, overflow
checking occurs.

\begin{lstlisting}{}
int_u<8> i = 200;
int_u<8> j = 100;
int_u<9> k = i + j;  // ok, no overflow
int_u<8> l = i + j;  // assertion triggered
                     // in the constructor of l
\end{lstlisting}

\floatstyle{boxed}
\newfloat{FormerAssignCheck}{H}{lop}
\begin{FormerAssignCheck}
In former versions of Olena, we used to disallow any assignment from
\url{int_u<N>} to \url{int_u<M>} where \code{N>M}.  The
\code{l = i + j;} line in the previous example would simply not
compile.

This restriction has been removed because it turned out to be very
annoying.  The programmer had to write
\code{l = cast::force< int_u<8> >(i + j);} or
\code{l = cast::bound< int_u<8> >(i + j);} whenever he knew there would
be no overflow.  One other work around was to bypass the temporary
variable creation with \code{l = i; l += j;}.

There are two common places where this rule was found really annoying.
One is the definition of constants.
\begin{lstlisting}{}
const T init    = cast::force<T>(optraits<T>::min() + 1);
const T inqueue = cast::force<T>(optraits<T>::min() + 2);
\end{lstlisting}

The second is the computation of an average.  Althought the sum is
made in a larger type, we \emph{know} that the final result will fit
in the orgiginal type.
\begin{lstlisting}{}
template <class T>
T average(const list<T>& l)
{
   optraits<T>::larger_type sum = optraits<T>::larger_type::zero();
   for (list<T>::iterator i = l.begin(); i != l.end(); ++i)
      sum += *i;
   return cast::force<T>(sun / l.size());
}
\end{lstlisting}
\end{FormerAssignCheck}

Saying that overflow checking occurs only during assignments because
overflow during operations is impossible (since the type is extended
as appropriate), would not the exact truth.

The type cannot always be extended during operations.  Summing two
\code{int_u<31>} variables will return a \code{int_u<32>} temporary
variable, extending the type; however summing two \code{int_u<32>}
variables will yield another \code{int_u<32>} variable (on 32bits
hosts) because no larger type is available.

Because of this, overflow checking has to occur during operations too.
This means that the behavior of the temporary variables is imporant.
The choice is based on the behavior of the operands.

\begin{tabular}{c|c|c}
operand & operand & result \\
\hline
\hline
\code{strict} & \code{strict} & \code{strict} \\
\code{saturate} & \code{saturate} & \code{saturate} \\
\code{unsafe} & \code{unsafe} & \code{unsafe} \\
\code{strict} & \code{unsafe} & \code{strict} \\
\code{strict} & \code{saturate} & \code{strict} \\
\code{unsafe} & \code{saturate} & \code{saturate} \\
\end{tabular}

Another way to present this is to say that behaviors have been ordered
as follow \code{unsafe < saturate < strict}, and that when there is a
choice between two behaviors, we always choose the greater.

Please bear in mind that the behavior chosen for temporary variable
only rarely matters because the type is usually extended so that
overflow do not occur.

The following frequently used types are given shortands.
\begin{lstlisting}{}
typedef int_u<8,  strict>	int_u8;
typedef int_u<16, strict>	int_u16;
typedef int_u<32, strict>	int_u32;
typedef int_u<8,  saturate>	int_u8s;
typedef int_u<16, saturate>	int_u16s;
typedef int_u<32, saturate>	int_u32s;
\end{lstlisting}

\subsection{\code{int_s<N, BEHAVIOR=strict>}}

This template can be used to define signed integers of various size
and behaviors.  This is can be used exactly like
\code{int_u<N,BEHAVIOR>}.

\emph{Extending the type} will also works during operations between
unsigned and signed integers.

The following \code{typedef}s are defined.
\begin{lstlisting}{}
typedef int_s<8,  strict>	int_s8;
typedef int_s<16, strict>	int_s16;
typedef int_s<32, strict>	int_s32;
typedef int_s<8,  saturate>	int_s8s;
typedef int_s<16, saturate>	int_s16s;
typedef int_s<32, saturate>	int_s32s;
\end{lstlisting}

\subsection{\code{sfloat} and \code{dfloat}}

These are the Olena equivalents of \code{float} and \code{double},
Contrary to signed and unsigned integer types, there is not
\emph{extension} during operations.  Multiplying two \code{sfloat}
yields a \code{sfloat}.

FIXME: so why do we use \code{float} and \code{double}?

\subsection{Interactions between scalar types}

The following unary operations are defined for any scalar type, with
their common semantic:
\code{+x}, \code{-x}.

These binary operations can be used with all combinasion of (Olena)
scalar type, with their common semantic: \code{x+y}, \code{x-y},
\code{x*y}, \code{x/y}, \code{x+=y}, \code{x-=y}, \code{x*=y},
\code{x/=y}, \code{x == y}, \code{x < y}, \code{x > y}, \code{x <=
y}, \code{x >= y}, \code{x != y}.

Especially, this means that \code{int_u32} is comparable to
\code{int_s32}.  For instance in
\begin{lstlisting}{}
int_u32 i = ...;
int_s32 j = ...;
if (i < j)
  // ...
\end{lstlisting}
the code generated for \code{i<j} should be close to
\code{j >= 0 && i < cast::force<int_u32>(j)}.

\subsection{Decorators for scalar types}

You can decorate a type to add some constraint or change it's
behavior.

\subsubsection{\code{range<T, INTERVAL, BEHAVIOR=strict>}}

This class, like Ada's \code{range} keyword, adds a constrains on type
\code{T}.  The constraint is that values should be bounded by
the interval \code{INTERVAL}.  \code{BEHAVIOR} specifies how overflow
checking should behave.

Interval should be expressed using the \code{bounded_s<MIN, MAX>} and
\code{bounded_u<MIN, MAX>} templates, where \code{MIN} and \code{MAX} are
signed integer in \code{bounded_s} and unsigned integer in
\code{bounded_u<MIN, MAX>}.\footnote{%%%
  \code{MIN} and \code{MAX} are always integers (the C++ language does
not allow floats as template arguments), so to define a \code{sfloat}
between $0$ and $1$, use \code{range<sfloat,bounded_u<0,1> >}, not
\code{range<sfloat,bounded_u<0.0,1.0> >}. }%%%

%% This changes the \code{min}inimum and \code{max}imum value of a type.
%% These values are used during overflow checking.

\code{range<int_u<8>, bounded_u<10, 25> >} is thus an unsigned integer,
stored on 8 bits, but restricted to the $[10...25]$ interval.  Because
\code{strict} is the default behavior, any attempt to escape this
interval will abort the program.


\subsubsection{\code{cycle<T, INTERVAL>}}

This class defines a type, the values of which can be built from
\code{T}, and that cycle over \code{INTERVAL}, where \code{INTERVAL} is
defined using \code{bounded_u<MIN, MAX>} or \code{bounded_s<MIN,MAX>}
as in \code{range}.

For instance \code{typedef cycle<sfloat, bounded_u<0, 360> > deg}
defines a type which is useful to represent angles in degrees.
\code{deg d = 400.0} will set \code{d} to \code{40.0}.

For the purpose of cycling, the upper bound of the range, \code{MAX},
is excluded.  \code{deg d = 360.0} will set \code{d} to \code{0.0}.

Any value implicitely convertible to \code{T} can be involved in an
arithmetic operation with \code{cycle<T, INTERVAL>}.

Any conversion from \code{cycle<T, bounded_x<A, B> >} to
\code{cycle<T, bounded_y<C, D> >} must be explicit and should
respect $B - A = D - C$ (i.e., the
two cycles have equal length).

%% \subsubsection{\code{view_as<T,U>}}
%%
%% \code{view_as<T,U>} declares a variable stored in type \code{T}
%% but seen as type \code{U}.
%%
%% For instance the following line defines a type which is stored as an
%% \code{int_u8} in memory, but that will be read and set as
%% \code{sfloat} values between 0 and 1.
%% \begin{lstlisting}{}
%% typedef view_as<int_u8, range<sfloat, 0, 1> > fuzzy8;
%% \end{lstlisting}
%%
%% In other words, \code{view_as} performs a linear transformation to
%% marshal \code{T} values from the \code{optraits<T>::min()}
%% ... \code{optraits<T>::max()} range as \code{U} values between
%% \code{optraits<U>::min()} ... \code{optraits<T>::max()}.
%%
%% Note that it is ok to use another \code{view_as} type for \code{U}.
%% For instance \code{fuzzy16} can be defined as
%% \begin{lstlisting}{}
%% typedef view_as<int_u16, fuzzy8> fuzzy16;
%% \end{lstlisting}
%% This describe a type whose variables are stored on 16 bits, but
%% which are seen like \code{fuzzy8}, i.e., a \code{sfloat} value between
%% 0 and 1.  The fact that \code{U} is stored on 8 bits has no influence
%% on \code{T}.

\section{Enumerated types}

\subsection{\code{bin}}

\code{bin} is a binary type, with two values: \code{0}
and \code{1}.  This is unlike the built-in \code{bool}, whose
values are \code{false} and \code{true}.

\subsection{\code{label<T, BEHAVIOR=cycle>}}

FIXME: not sure if we really need this.

FIXME: This documentation is out of date.  We've decided to split
\code{label} into ordered labels and unordered labels.

\code{label<T, BEHAVIOR=cycle>} is used to label images.

Although it is not stricly correct to define an order on labels,
we do.  This is useful (FIXME: Ask Jerome for an example).

\subsection{The \code{typetraits<T>} trait}

For each type \code{T} described in the previous section, Olena
records additional relations in the \code{typetraits<T>} trait.

All the following members of \code{typetraits<T>} are typedefs.
\begin{description}
\item[\code{base_type}] The base type for \code{T}, i.e., \code{T} without
any decoration.  For instance
\code{typetraits< range<int_u8,10,25> >::base_type}
is \code{int_u8}.

Ada programmers will probably recognize the \code{T'Base} attribute.

For a undecorated type \code{T}, \code{typetraits<T>::base_type} is
\code{T} itself.

\item[\code{storage_type}] The C type used internally for storing the
value.  E.g., \code{typetraits< int_u<9> >::storage_type} is
\code{unsigned short}.

%% \item[\code{view}] The type under which the value should be seen.
%% For example,
%% \code{typetraits< view_as<int_u8, range<sfloat, 0, 1> > >::view}
%% is \code{range<sfloat, 0, 1>}.
%%
%% For a undecorated type \code{T}, \code{typetraits<T>::view} is
%% \code{T} itself.
%%
%% Note that the view of \code{fuzzy16} as defined above, i.e,
%% \code{typetraits< view_as<int_u8, view_as<int_u16, range<sfloat, 0, 1> > > >::view}
%% is still \code{range<sfloat, 0, 1>}.

\item[\code{signed_type}]
The smallest signed type that can countain the values of \code{T}, if possible.
For instance
\code{typetraits< int_u8 >::signed_type} is \code{int_s<10>}.
(\code{int_s<9>} is not large enough to hold the value 256.)

However \code{typetraits< int_u32 >::signed_type} is \code{int_s<32>}.

\item[\code{unsigned_type}]
The smalled unsigned type that can countain the non negative values of
\code{T}.
For instance,
\code{typetraits< int_s<9> >::unsigned_type} is \code{int_u8}.

\item[\code{cumul_type}]
A type that can be used to sum up a moderate number of values of type
\code{T}.  (FIXME: a moderate number?  Come on...  I'm sure we can put
it in a way which is even more fuzzy.)
For instance
\code{typetraits< int_u8 >::cumul_type} is \code{int_u16}.

\item[\code{largest_type}]
The largest type in the familly of \code{T}.  For instance
\code{typetraits< int_u8 >::largest_type} is \code{int_u32}.

\item[\code{signed_largest_type}]
\item[\code{signed_cumul_type}]
\item[\code{unsigned_largest_type}]
\item[\code{unsigned_cumul_type}]
These are short-hands for some combinations of \code{signed_type},
\code{unsigned_type}, \code{cumul_type} and \code{largest_type}.

\item[\code{integer_type}]
An \code{int} type of the same sign as \code{T}.
For instance \code{typetraits< int_u8 >::interger_type} is \code{unsigned
int}; \code{typetraits< sfloat >::interger_type} is \code{signed
int}.

% FIXME: Is this type needed anymore?

% This type was initially used by the \code{range<T, MIN, MAX, B>} template
% to define the type of it's arguments: \code{MIN} and \code{MAX} both
% have type \code{typetraits< T >::interger_type}.  But it isn't allowed
% to have template types which depend on a previous argument,
% like in
%    template < typename T, typetraits< T >::interger_type V > ...
% (that's why we use the bounded_s and bounded_u classes instead).

\end{description}

\subsection{The \code{optraits<T>} trait}

Olena offers some additionnal supporting function or operators in the
\code{optraits<T>} trait.  For example, sometimes while developping
a generic algorithm on type \code{T} we need to need the maximum value
that this type can take.  The \code{optraits<T>} trait provides
support to anser this sort of question.  For instance
\code{optraits<T>::max()} returns the maximum values for type
\code{T}.

\newfloat{OptraitsVersusInnerTypedef}{H}{lop}
\begin{OptraitsVersusInnerTypedef}
The reason why we have to use a separate class and write
\code{optraits<T>::max()} instead of \code{T::max()} is that
the latter case cannot work with built-in types.

Besides, using a class distinct from the type itself to hold operators
and various support functions allows to reuse the support from another
type by inheritance on the \code{optraits} hierarchy, without implying
any inheritance on the type hierarchy.

For instance \code{optraits<range<int_u8, 10, 25> >} inherits from
\code{optraits<int_u8>} and simply redefine a few members like the
\code{max()} and \code{min()} functions.  However
\code{range<int_u8, 10, 25>} is not a subclass of \code{int_u8}.
\end{OptraitsVersusInnerTypedef}

Here are the public \code{optraits<T>} members:

\begin{description}
\item[\code{min()}]
  The minimum \emph{reachable} value for type \code{T}, if such minimum value
  exists (this is not the case for float value, for instance).
  \code{optraits<T>::min()} is the equivalent of \code{T'First} in Ada.
\item[\code{max()}]
  The maximum \emph{reachable} value for type \code{T}, if such maximum value
  exists (this is not the case for float value, for instance).
  \code{optraits<T>::max()} is the equivalent of \code{T'Last} in Ada.
\item[\code{inf()}]
  The lower bound for type \code{T}.  For discrete types this is the
  same as \code{min()}, for other types such as floats this can
  be $-\infty$.
\item[\code{sup()}]
  The upper bound for type \code{T}.  For discrete types this is the
  same as \code{max()}, for other types such as floats this can
  be $+\infty$.
\item[\code{unit()}]
  The unit value for type \code{T}, when it makes sense (it doesn't
  make any sense for color types such as \code{rgb} for instance).
\item[\code{zero()}]
  The unit value for type \code{T}, when it makes sense.
\item[\code{default()}]
  The default value for type \code{T}.  This is the value that a
  default-constructed \code{T} variable should have.  This should
  be the same as \code{zero()} whenever possible.
\end{description}

\code{optraits<T>} also contains a number of internal members, used
during operations.

FIXME: List them.
