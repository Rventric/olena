#include <mln/core/image/image2d.hh>
#include <mln/core/image/dmorph/image_if.hh>
#include <mln/pw/all.hh>

#include <mln/draw/line.hh>

#include <mln/data/wrap.hh>
#include <mln/data/fill.hh>
#include <mln/data/convert.hh>


#include <mln/labeling/colorize.hh>

#include <mln/morpho/closing/structural.hh>
#include <mln/morpho/closing/area.hh>
#include <mln/morpho/opening/structural.hh>
#include <mln/win/rectangle2d.hh>
#include <mln/win/vline2d.hh>

#include <mln/logical/not.hh>
#include <mln/io/pbm/all.hh>
#include <mln/io/pgm/all.hh>
#include <mln/io/ppm/save.hh>

#include <mln/literal/colors.hh>

#include <mln/value/label_16.hh>
#include <mln/value/int_u8.hh>
#include <mln/value/int_u12.hh>
#include <mln/value/int_u16.hh>
#include <mln/value/rgb8.hh>

#include <mln/draw/box_plain.hh>

#include <mln/transform/influence_zone_geodesic.hh>

#include <mln/data/stretch.hh>

#include <mln/util/timer.hh>

#include <mln/norm/l1.hh>

#include <scribo/core/object_groups.hh>
#include <scribo/primitive/extract/components.hh>

#include <scribo/primitive/extract/lines_h_pattern.hh>
#include <scribo/primitive/remove/separators.hh>
#include <scribo/primitive/group/from_single_link.hh>
#include <scribo/preprocessing/denoise_fg.hh>
#include <scribo/preprocessing/rotate_90.hh>

#include <scribo/primitive/link/with_single_right_link_dmax_ratio.hh>
#include <scribo/primitive/link/with_single_right_link_dmax_ratio_aligned.hh>

#include <scribo/filter/object_links_top_aligned.hh>
#include <scribo/filter/object_groups_small.hh>
#include <scribo/filter/object_links_bottom_aligned.hh>
#include <scribo/debug/save_linked_bboxes_image.hh>
#include <scribo/debug/decision_image.hh>

namespace mln
{

  using namespace scribo;

  template <typename L>
  void filter_bad_groups(object_groups<L>& top_groups,
			 object_groups<L>& bot_groups)
  {
    const component_set<L>& comps = top_groups.components();
    const L& lbl = comps.labeled_image();

    for_all_groups(c, top_groups)
    {
      box2d b = comps(c).bbox();
      b.enlarge(0, comps(c).bbox().height());
      b.crop_wrt(lbl.domain());

      typedef mln_value(L) V;

      const V* top_ptr = & lbl(b.pmin());
      const V* bot_ptr = & lbl(point2d(b.pmax().row(), b.pmin().col()));

      unsigned ntop = 0, nbot = 0;
      for (unsigned n = 0; n < b.width(); ++n)
      {
	if (*top_ptr)
	  ++ntop;
	if (*bot_ptr)
	  ++nbot;
      }

      if (ntop / b.width() > 0.50f)
	top_groups(c) = c;

      if (nbot / b.width() > 0.50f)
	bot_groups(c) = c;
    }

  }


  template <typename L>
  mln_site(L)
  my_anchors(const component_set<L>& comps,
	     unsigned current_object,
	     anchor::Type anchor)
  {
    mln_site(L) sp = comps(current_object).bbox().pcenter();

    unsigned h = comps(current_object).bbox().pmax().row()
      - comps(current_object).bbox().pmin().row();


    switch (anchor)
    {
      default:
	return sp;

	// Bounding box top center
      case anchor::Top:
	sp.row() = comps(current_object).bbox().pmin().row()
	  + math::min(2u, (h + 1) / 2 - 1);
	break;


	// Bounding box bottom center
      case anchor::Bottom:
	sp.row() = comps(current_object).bbox().pmax().row()
	  - math::min(2u, (h + 1) / 2 - 1);
	break;
    }

    return sp;
  }



  using namespace primitive::link::internal;

  template <typename L, typename E>
  class single_dmax_ratio_aligned_functor_base
    : public link_single_dmax_ratio_base<L, E>
  {
//    typedef single_right_dmax_ratio_aligned_functor<L> self_t;
    typedef link_single_dmax_ratio_base<L, E> super_;

  public:
    typedef mln_site(L) P;

    single_dmax_ratio_aligned_functor_base(
      const image2d<bool>& input,
      const component_set<L>& components,
      unsigned dmax,
      float min_angle,
      float max_angle,
      anchor::Type anchor_)
      : super_(components, dmax, anchor::Horizontal), anchor(anchor_),
	debug_(data::convert(value::rgb8(), input)),
	debug_angle_(data::convert(value::rgb8(), input))
    {
      std::cout << "min_angle = " << min_angle
		<< " - max_angle = " << max_angle
		<< std::endl;
      std::cout << "min_angle_rad = " << min_alpha_rad
		<< " - max_angle_rad = " << max_alpha_rad
		<< std::endl;
      min_alpha_rad = (min_angle / 180.0f) * math::pi;
      max_alpha_rad = (max_angle / 180.0f) * math::pi;
    }

    void compute_next_site_(P& p)
    {
      ++p.col();
    }


    mln_site(L)
    start_point_(unsigned current_object, anchor::Type anchor)
    {
      return my_anchors(this->components_, current_object, anchor);
    }


    inline
    bool
    valid_link_(unsigned current_object,
		const P& start_point,
		const P& p)
    {
      if (!super_::valid_link_(current_object, start_point, p))
	return false;

      box<P> b = this->components_(current_object).bbox();

      // Distance between the two components.
      float dist;

      // current object is on the left.
      if (p[this->direction_] > b.pmax()[this->direction_])
	dist = math::abs(p[this->direction_] - b.pmax()[this->direction_]);
      // current object is on the right.
      else
	dist = math::abs(p[this->direction_] - b.pmin()[this->direction_]);


//       int ldist = std::max(this->components_(current_object).bbox().width() / 2,
// 			   this->components_(this->labeled_image_(p)).bbox().width() / 2);

      int ldist = this->components_(current_object).bbox().width();

      // Components are really close, so the angle is more permissive.
      if (dist < 3 * ldist)
//      if (dist < (ldist + 0.7 * ldist))
      {
	return
	  filter::internal::component_aligned_rad(this->components_,
						  current_object,
						  this->labeled_image_(p),
						  anchor,
						  max_alpha_rad);
      }


      // Components are really far, so the angle is less permissive.
      return
	filter::internal::component_aligned_rad(this->components_,
						current_object,
						this->labeled_image_(p),
						anchor,
						min_alpha_rad);
    }

    void validate_link_(unsigned current_object,
			const P& start_point,
			const P& p,
			anchor::Type anchor)
    {
      super_::validate_link_(current_object, start_point, p, anchor);

      mln_site(L)
	p1 = mln::my_anchors(this->components_, current_object, anchor),
	p2 = mln::my_anchors(this->components_, this->labeled_image_(p),
			     anchor);
      draw::line(debug_, p1, p2, literal::green);


      float
	angle = filter::internal::alignment_angle(this->components_,
						  current_object,
						  this->labeled_image_(p),
						  anchor);
      angle = (angle * 180.0f) / math::pi;
      angle = angle * 20.0f + 1.0f;
      draw::line(debug_angle_, p1, p2, value::rgb8(angle, angle, angle));
    }

    void invalidate_link_(unsigned current_object,
			  const P& start_point,
			  const P& p,
			  anchor::Type anchor)
    {
      super_::invalidate_link_(current_object, start_point, p, anchor);

      if (this->labeled_image_.domain().has(p) && this->labeled_image_(p) != 0)
      {
	mln_site(L)
	  p1 = mln::my_anchors(this->components_, current_object, anchor),
	  p2 = mln::my_anchors(this->components_, this->labeled_image_(p),
			       anchor);
	if (this->labeled_image_.domain().has(p2) && norm::l1_distance(p1.to_vec(), p2.to_vec()) < 300)
	{
	  draw::line(debug_, p1, p2, literal::red);
	}


	float
	  angle = filter::internal::alignment_angle(this->components_,
						    current_object,
						    this->labeled_image_(p),
						    anchor);
	angle = (angle * 180.0f) / math::pi;
	angle = angle * 20.0f + 1.0f;
	draw::line(debug_angle_, p1, p2, value::rgb8(angle, angle, angle));
      }
    }


    float min_alpha_rad;
    float max_alpha_rad;
    anchor::Type anchor;


    image2d<value::rgb8> debug_;
    image2d<value::rgb8> debug_angle_;
  };


  template <typename L>
  class single_right_dmax_ratio_aligned_functor
    : public single_dmax_ratio_aligned_functor_base<L, single_right_dmax_ratio_aligned_functor<L> >
  {
    typedef single_right_dmax_ratio_aligned_functor<L> self_t;
    typedef single_dmax_ratio_aligned_functor_base<L, self_t> super_;

  public:
    typedef mln_site(L) P;

    single_right_dmax_ratio_aligned_functor(
      const image2d<bool>& input,
      const component_set<L>& components,
      unsigned dmax,
      float min_angle,
      float max_angle,
      anchor::Type anchor)
      : super_(input, components, dmax, min_angle, max_angle, anchor)
    {
    }

    void compute_next_site_(P& p)
    {
      ++p.col();
    }

  };


  template <typename L>
  class single_left_dmax_ratio_aligned_functor
    : public single_dmax_ratio_aligned_functor_base<L, single_left_dmax_ratio_aligned_functor<L> >
  {
    typedef single_left_dmax_ratio_aligned_functor<L> self_t;
    typedef single_dmax_ratio_aligned_functor_base<L, self_t> super_;

  public:
    typedef mln_site(L) P;

    single_left_dmax_ratio_aligned_functor(
      const image2d<bool>& input,
      const component_set<L>& components,
      unsigned dmax,
      float min_angle,
      float max_angle,
      anchor::Type anchor)
      : super_(input, components, dmax, min_angle, max_angle, anchor)
    {
    }

    void compute_next_site_(P& p)
    {
      --p.col();
    }

  };

}


int main(int argc, char *argv[])
{
  using namespace scribo;
  using namespace mln;

  bool debug = (argc == 7);

  image2d<bool> input;
  mln::io::pbm::load(input, argv[1]);

  util::timer t;

  t.start();
  input = scribo::preprocessing::rotate_90(input);
  float t_ = t;
  std::cout << "rotate_90 - " << t_ << std::endl;


  t.start();
  image2d<bool> hsep
    = scribo::primitive::extract::lines_h_pattern(input, 200, 9);
  input = scribo::primitive::remove::separators(input, hsep);
  t_ = t;
  std::cout << "rotate_90 - " << t_ << std::endl;


  t.restart();
  win::vline2d vl(17);
  image2d<bool> input_clo = morpho::closing::structural(input, vl);
  t_ = t;
  std::cout << "closing_structural - " << t_ << std::endl;

  if (debug)
    io::pbm::save(input_clo, "input_clo.pbm");


  /// Finding components.
  typedef value::int_u16 V;
  typedef image2d<V> L;

  t.restart();
  V ncomponents;
  component_set<L>
    components = scribo::primitive::extract::components(input_clo, c8(),
							ncomponents);
  t_ = t;
  std::cout << "extract::components - " << t_ << std::endl;

  unsigned min_angle = atoi(argv[2]), max_angle = atoi(argv[3]);

//   t.restart();
//   object_links<L>
//     top_links = primitive::link::with_single_right_link_dmax_ratio_aligned(components, 2, min_angle, max_angle, anchor::Top);

//   object_links<L>
//     bot_links = primitive::link::with_single_right_link_dmax_ratio_aligned(components, 2, min_angle, max_angle, anchor::Bottom);
//   t_ = t;
//   std::cout << "links - " << t_ << std::endl;

  unsigned dmax = 5;

  t.restart();
  object_links<L> top_links, bot_links;

  object_links<L> ltop_links, lbot_links, rtop_links, rbot_links;


  {
    // Right
    mln::single_right_dmax_ratio_aligned_functor<L>
      functor(input_clo, components, dmax, min_angle, max_angle, anchor::Top);
    top_links = primitive::link::compute(functor, anchor::Top);
    io::ppm::save(functor.debug_, "right_top.ppm");
    io::ppm::save(functor.debug_angle_, "right_top_angle.ppm");

    // Left
    mln::single_left_dmax_ratio_aligned_functor<L>
      lfunctor(input_clo, components, dmax, min_angle, max_angle, anchor::Top);
    ltop_links = primitive::link::compute(lfunctor, anchor::Top);
    io::ppm::save(lfunctor.debug_, "left_top.ppm");
    io::ppm::save(lfunctor.debug_angle_, "left_top_angle.ppm");

    image2d<value::rgb8> output = duplicate(functor.debug_);
    data::paste((lfunctor.debug_ | (pw::value(lfunctor.debug_) != pw::cst(literal::black))) | (pw::value(lfunctor.debug_) != pw::cst(literal::white)), output);

    io::ppm::save(output, "left_right_top.ppm");
  }


  {
    // Right
    mln::single_right_dmax_ratio_aligned_functor<L>
      functor(input_clo, components, dmax, min_angle, max_angle, anchor::Bottom);
    bot_links = primitive::link::compute(functor, anchor::Bottom);
    io::ppm::save(functor.debug_, "right_bot.ppm");
    io::ppm::save(functor.debug_angle_, "right_bot_angle.ppm");

    // Left
    mln::single_left_dmax_ratio_aligned_functor<L>
      lfunctor(input_clo, components, dmax, min_angle, max_angle, anchor::Bottom);
    lbot_links = primitive::link::compute(lfunctor, anchor::Bottom);
    io::ppm::save(lfunctor.debug_, "left_bot.ppm");
    io::ppm::save(lfunctor.debug_angle_, "left_bot_angle.ppm");

    image2d<value::rgb8> output = duplicate(functor.debug_);
    data::paste((lfunctor.debug_ | (pw::value(lfunctor.debug_) != pw::cst(literal::black))) | (pw::value(lfunctor.debug_) != pw::cst(literal::white)), output);

    io::ppm::save(output, "left_right_bot.ppm");
  }

//  primitive::link::with_single_right_link_dmax_ratio_aligned(components, 2, min_angle, max_angle, anchor::Top);

//   object_links<L>
//     bot_links = primitive::link::with_single_right_link_dmax_ratio_aligned(components, 2, min_angle, max_angle, anchor::Bottom);
  t_ = t;
  std::cout << "links - " << t_ << std::endl;


//   t.restart();
//   // Filtering.
//   object_links<L>
//     ftop_links = filter::object_links_top_aligned(top_links, atoi(argv[2])),
//     fbot_links = filter::object_links_bottom_aligned(bot_links, atoi(argv[2]));
//   t_ = t;
//   std::cout << "links alignements - " << t_ << std::endl;

  // Debug image.
//   if (debug)
//   {
//     scribo::debug::save_linked_bboxes_image(input,
// 					    components,
// 					    top_links,
// 					    literal::red,
// 					    literal::green,
// 					    "top.ppm",
// 					    anchor::TopRight);

//     scribo::debug::save_linked_bboxes_image(input,
// 					    components,
// 					    bot_links,
// 					    literal::red,
// 					    literal::green,
// 					    "bot.ppm",
// 					    anchor::BottomRight);
//   }

  t.restart();
  object_groups<L> top_groups = primitive::group::from_single_link(top_links);
  object_groups<L> bot_groups = primitive::group::from_single_link(bot_links);
  t_ = t;
  std::cout << "regroup - " << t_ << std::endl;

  unsigned min_card = atoi(argv[4]);


  t.restart();
  util::array<accu::shape::bbox<point2d> >
    btop_accu(top_groups.nelements()),
    bbot_accu(bot_groups.nelements());


  for_all_groups(c, top_groups)
  {
    btop_accu(top_groups(c)).take(components(c).bbox());
    bbot_accu(bot_groups(c)).take(components(c).bbox());
  }
  t_ = t;
  std::cout << "groups to group bboxes - " << t_ << std::endl;



  image2d<value::rgb8>
    wo_filtering = data::convert(value::rgb8(), input);

  for_all_comp_data(d, btop_accu)
  {
    if (btop_accu(d).is_valid())
    {
      mln::draw::line(wo_filtering,
		      btop_accu(d).to_result().pmin(),
		      point2d(btop_accu(d).to_result().pmin().row(),
			      btop_accu(d).to_result().pmax().col()),
		      literal::green);

    }
  }

  for_all_comp_data(d, bbot_accu)
  {
    if (bbot_accu(d).is_valid())
    {
      mln::draw::line(wo_filtering,
		      point2d(bbot_accu(d).to_result().pmax().row(),
			      bbot_accu(d).to_result().pmin().col()),
		      bbot_accu(d).to_result().pmax(),
		      literal::green);
    }

  }
  io::ppm::save(wo_filtering, "wo_filtering.ppm");



  t.restart();
  top_groups = filter::object_groups_small(top_groups, min_card);
  bot_groups = filter::object_groups_small(bot_groups, min_card);
  t_ = t;
  std::cout << "small groups - " << t_ << std::endl;



//   t.restart();
//   filter_bad_groups(top_groups, bot_groups);
//   t_ = t;
//   std::cout << "bad groups - " << t_ << std::endl;



  t.restart();
  util::array<accu::shape::bbox<point2d> >
    top_accu(top_groups.nelements()),
    bot_accu(bot_groups.nelements());


  for_all_groups(c, top_groups)
  {
    top_accu(top_groups(c)).take(components(c).bbox());
    bot_accu(bot_groups(c)).take(components(c).bbox());
  }
  t_ = t;
  std::cout << "groups to group bboxes - " << t_ << std::endl;












  image2d<value::rgb8>
    both = data::convert(value::rgb8(), input);

  image2d<value::rgb8>
    top_l, bot_l;

  if (debug)
  {
    top_l = duplicate(both);
    bot_l = duplicate(both);
  }


  t.restart();
  for_all_comp_data(d, top_accu)
  {
    if (top_accu(d).is_valid()  ||  btop_accu(d).is_valid())
    {
      if (debug)
	if (top_accu(d).is_valid())
	  mln::draw::line(top_l,
			  top_accu(d).to_result().pmin(),
			  point2d(top_accu(d).to_result().pmin().row(),
				  top_accu(d).to_result().pmax().col()),
			  literal::green);


      if (top_accu(d).is_valid())
	mln::draw::line(both,
			top_accu(d).to_result().pmin(),
			point2d(top_accu(d).to_result().pmin().row(),
				top_accu(d).to_result().pmax().col()),
			literal::green);
      else
	if (btop_accu(d).is_valid())
	  mln::draw::line(both,
			  btop_accu(d).to_result().pmin(),
			  point2d(btop_accu(d).to_result().pmin().row(),
				  btop_accu(d).to_result().pmax().col()),
			  literal::yellow);

    }
    if (bot_accu(d).is_valid() ||  bbot_accu(d).is_valid())
    {
      if (debug)
	if (bot_accu(d).is_valid())
	  mln::draw::line(bot_l,
			  point2d(bot_accu(d).to_result().pmax().row(),
				  bot_accu(d).to_result().pmin().col()),
			  bot_accu(d).to_result().pmax(),
			  literal::green);


      if (bot_accu(d).is_valid())
	mln::draw::line(both,
			point2d(bot_accu(d).to_result().pmax().row(),
				bot_accu(d).to_result().pmin().col()),
			bot_accu(d).to_result().pmax(),
			literal::green);
      else
	if (bbot_accu(d).is_valid())
	  mln::draw::line(both,
			  point2d(bbot_accu(d).to_result().pmax().row(),
				  bbot_accu(d).to_result().pmin().col()),
			  bbot_accu(d).to_result().pmax(),
			  literal::yellow);
    }

  }
  t_ = t;
  std::cout << "Drawing output image - " << t_ << std::endl;


  if (debug)
  {
    io::ppm::save(top_l, "top_l.ppm");
    io::ppm::save(bot_l, "bot_l.ppm");
  }

  io::ppm::save(both, argv[5]);
}
