		-*- outline -*-



* basic_maxtree

** features

union-find
p as point2d
p are sorted
par as image<point2d>
isproc as image
level compression
loop is "for all p"

** anti-features

level compression is not finalized (is not _total_)
no auxiliary parent data with full (tree) compression to speed-up find_root
no outer virtual border

** permanent changes

except for this version, we now always perform the following
optimizations

*** isproc
nbh is splitted into pre and post
so isproc is no more aux data
2 functions: isproc_pre and isproc_post
benefit: memory saving

*** node/levroot counting
during the compression
benefit: we need to know nnodes before the 2nd pass
without introducing an intermediate pass



* algorithms deriving from basic_maxtree


** browsing

*** s
when quantization is high
std::sort
browsing is:
| for all p taken with f(p) decreasing
|   union-find

*** h
when quantization is low
counting sort
browsing is:
| for all h
|   for all p fwd s.a. f(p) = h
|     union-find
|   for all p bkd s.a. f(p) = h
|     compression
benefit: usually faster thanx to compression

*** r
raster (classic video scan)
no sorting
browsing is:
| for all p fwd
|   union-find
benefit: incremental, card(nbh)/2
use: insert (p->tree) and update (tree is in/out)


** point encoding

*** p
point = point2d = (int, int)
par[p] = point2d

*** i
point = int
par[p] = point

*** d
point = index = int
dpar[p] = delta point = delta index = int
benefit: make_sets() = memset(dpar, 0)


** compression

*** c
level-compression of par (resp. dpar)
find_root = loop over find_level_root

*** x
use of aux data: c_par (resp. c_dpar)
for full compressed access to root
find_root = quicker

*** .
no level compression
no aux data (for full compression)


** further (later) optims

virtual border...


** status

hpc  impled
hpx  impled
rpc  impled

hdc  impled
hdx  impled

r1ic do not compile (ric specialized for 1D images)

sp   impled
spx  impled


* algorithms deriving from Salembier et al. algorithm

** basic_salembier

flooding
p as point2d
father as std::map<pair_t, pair_t>
hqueue as an array of std::queue<point>
works only on image of unsigned integers (unsigned int or ntg::int_u8
  for instance)

** generic_salembier

flooding
p as point2d
father as std::map<pair, pair>
hqueue as std::map<value, std::queue<point> >
modifiable comparison function on values (defaulting to
  std::greater< oln_value_type(I) >)
works only on any kind of image whose values are comparable

** generic_simplified_salembier

flooding
the algorithm consider that each site (pixel) has a unique ``value''
  within the image (the algorithm no longer works on levels, only on
  points, which are totally ordered)
p as point2d
father as std::map<point, point, point_less<I, point> >
no hqueue, but a set of points instead
works on any kind of image whose values are comparable

** naive_generic_salembier

A previous version of generic_simplified_salembier, probablt no longer
useful.

flooding
the algorithm doesn't really handle flat zones (i.e., contiguous
pixels having the same value).
p as point2d
father as std::map<pair, pair>
hqueue as std::map<V, P>
works on any kind of image whose values are comparable



* fiorio
Max-tree computation based on Fiorio's and Gustedt's labelling
algorithm.

** fiorio-1.hh
My (Roland) first implementation of the max-tree computation using
Fiorio's and Gustedt's algorithm.

** fiorio-2.hh
My second implementation of the max-tree computation using Fiorio's and
Gustedt's algorithm, using routines of Theo's (anc, insert, etc.)

** fiorio-3.hh
A variation on fiorio-2.hh, which computes a max-tree for each line
of the image independently, and then merges them column per column.


Local Variables:
ispell-local-dictionary: "american"
End:
