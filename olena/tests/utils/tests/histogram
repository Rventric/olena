//								    -*- c++ -*-
// Copyright (C) 2004  EPITA Research and Development Laboratory
//
// This file is part of the Olena Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License version 2 as published by the
// Free Software Foundation.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library; see the file COPYING.  If not, write to
// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
// MA 02111-1307, USA.
//
// As a special exception, you may use this file as part of a free
// software library without restriction.  Specifically, if other files
// instantiate templates or use macros or inline functions from this
// file, or you compile this file and link it with other files to
// produce an executable, this file does not by itself cause the
// resulting executable to be covered by the GNU General Public
// License.  This exception does not however invalidate any other
// reasons why the executable file might be covered by the GNU General
// Public License.

#include <ntg/int.hh>
#include <oln/basics2d.hh>
#include <oln/basics1d.hh>
#include <oln/utils/histogram.hh>

#include <iostream>

#include "check.hh"
#include "data.hh"

using namespace oln;
using namespace ntg;
using namespace utils;

#define OK_OR_FAIL				\
      std::cout << "OK" << std::endl;		\
    else					\
      {						\
	std::cout << "FAIL" << std::endl;	\
	fail = true;				\
      }


bool
check_int_u8()
{
  bool res(true);
  image1d<int_u8> iu8(4);
  iu8(0) = 8;
  iu8(1) = 8;
  iu8(2) = 7;
  iu8(3) = 1;
  histogram<int_u8> hu8(iu8);
  res = res &&
    hu8[8] == 2 &&
    hu8[7] == 1 &&
    hu8[1] == 1 &&
    hu8[4] == 0 &&
    hu8[ntg_max_val(int_u8)] == 0 &&
    hu8[ntg_min_val(int_u8)] == 0;
  return res;
}

bool
check_int_s4_and_distr()
{
  bool res(true);
  image1d<int_s<4> > is4(4);
  is4(0) = -8;
  is4(1) = -8;
  is4(2) = +7;
  is4(3) = 0;
  histogram<int_s<4> > his4(is4);
  res = res &&
    his4[-8] == 2 &&
    his4[+7] == 1 &&
    his4[0] == 1 &&
    his4[-7] == 0;
  std::vector<point1d> v1(is4.npoints());
  distrib_sort(is4, v1);
  res = res &&
    (v1[0] == point1d(0) || v1[0] == point1d(1)) &&
    (v1[1] == point1d(0) || v1[1] == point1d(1)) &&
    v1[2] == point1d(3) &&
    v1[3] == point1d(2);

  std::vector<point1d> v2(is4.npoints());

  distrib_sort_inv(is4, v2);

  res = res &&
    v2[0] == point1d(2) &&
    v2[1] == point1d(3) &&
    (v2[2] == point1d(0) || v2[2] == point1d(1)) &&
    (v2[3] == point1d(0) || v2[3] == point1d(1));
  return res;
}



bool
check_min_max()
{
  bool res(true);
  image1d<int_s<4> > is4(4);
  is4(0) = -4;
  is4(1) = -2;
  is4(2) = +3;
  is4(3) = 1;
  histogram<int_s<4> > his4(is4);

  res = res &&
    utils::min(his4) == -4
    &&
    utils::max(his4) == 3;

  histogram_min<int_s<4> > his4_min(is4);
  histogram_max<int_s<4> > his4_max(is4);
  histogram_minmax<int_s<4> > his4_minmax(is4);

  his4_minmax[-5] = his4_min[-5] = his4_max[-5] = his4[-5] = 20;
  his4_minmax[3] = his4_min[3] = his4_max[3] = his4[3] = 0;

  his4_minmax[2] = his4_min[2] = his4_max[2] = his4[2] = 42;

  res = res &&
    utils::min(his4) == -5 &&
    utils::max(his4) == 2 &&
    utils::min(his4) == utils::min(his4_min) &&
    utils::min(his4) == utils::min(his4_max) &&
    utils::min(his4) == utils::min(his4_minmax) &&
    utils::max(his4) == utils::max(his4_min) &&
    utils::max(his4) == utils::max(his4_max) &&
    utils::max(his4) == utils::max(his4_minmax);
  return res;
}


bool
check_rgb_8()
{
  bool res(true);
  image1d<rgb_8> ir8(4);
  ir8(0) = rgb_8(1, 1, 1);
  ir8(1) = rgb_8(1, 2, 1);
  ir8(2) = rgb_8(255, 255, 255);
  ir8(3) = rgb_8(1, 2, 1);

  histogram<rgb_8> hr8(ir8);
  res = res &&
    hr8[rgb_8(1, 1, 1)] == 1 &&
    hr8[rgb_8(1, 2, 1)] == 2 &&
    hr8[rgb_8(255, 255, 255)] == 1 &&
    hr8[rgb_8(0, 0, 0)] == 0 &&
    hr8[rgb_8(44, 44, 44)] == 0;
  return res;
}

bool
check()
{
  bool fail = false;

  typedef image2d<int_u8> input;

  input src = load(rdata("lena256.pgm"));

  std::vector<point2d> v(src.nrows() * src.ncols());

  distrib_sort<input>(src, v);

  fail = fail
    || check_int_u8() == false
    || check_rgb_8() == false
    || check_int_s4_and_distr() == false
    || check_min_max() == false;

  return fail;
}
