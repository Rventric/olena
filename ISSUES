This files describe some know issues with Olena.  Please note that
Olena is a work in progress.  Later versions can be found at
http://www.lrde.epita.fr/olena/.

We are developing under Linux i386 using GCC version 2.95.3 and 3.0.3.
Olena should compile fine with both versions of the compiler.  Keeping
the compatibility with 2.95.3 implies some restrictions over the
template constructions used in Olena, because GCC 2.95.3 still bombs
out on various valid expressions.  Therefore some part of the code
have been arranged to "please" 2.95.3.  There are also a few issues
that need workaround even with GCC 3.0.3.

There is a good reason to maintain 2.95.3 compatibility: performance.
The inlining heuristic have changed between these versions.
Kurt Garloff has some interesting material about this issue on his
web page: http://www.garloff.de/kurt/freesoft/gcc/
Here are some figures to give an idea of the performance penalty.
These are the compilation- and run- times of one program (performing
several morphological operations in a 128x128x128 images) with
different compilations flags.

   GCC       options                     compilation-time  runtime
   2.95.3    -O2 -ftemplate-depth-50          59s	     46s
   3.0.3     -O2                            1m04s	    100s
   3.0.3     -O2 -finline-limit-2500        3m14s	     75s
   3.0.3     -O2 -finline-limit-4000        3m34s	     71s
   3.0.3     -O2 -finline-limit-7000        7m49s	     73s


Speaking about compilers, the following points are likely to cause
trouble when trying to port Olena to another build environment.

- The cast::round function use C99's round() and roundf() function.
  The GNU libc doesn't declare these functions by default, one
  has to explicitly define _ISOC99_SOURCE before including a
  system header.  This definition is actually done in src/config/system.hh,
  which is included by all the src/basic*.hh headers.
  That means that the programmer should include Olena's headers before
  other systems header.

Some code in the I/O assumes little-endian machines.  Output of 16bits
and 32 bits RAW PNM images on big-endian hosts will be wrong.
PLAIN PNM (i.e. text) should be ok.

The full value/ hierarchy is to be rewritten.  This directory contains
classes used to represent the value types.  These classes are
presently programmed using an old paradigm (based on the Barton and
Nackman trick) and will be rewritten using the scheme used for images,
iterators, windows, etc.  The name and overall behavior will be remain
the same, but you should expect some incompatibility if you use some
internal stuff.

The aforementioned image/iterator/window/point/... hierarchies will
themselves be adjusted using Thierry's evil secret plan.  The result
should make the exact types downcasts superfluous in a few cases, and
will allow this classes to be decorated (much rejoicing coming with
this).  This change shouldn't break the user interface, it will just
make it easier.

Presently it's difficult to specialize a processing for a given value
type when the processing takes the aggregate type as parameter.  See
the definitions of min() and max() in src/morpho/stat.hh for an
example.  This should eventually be fixed by adding new "concept"
classes on top of the image hierarchy (something like image_bin<*>,
image_not_bin<*>, image_color<*>, image_not_color<*>, etc...) and
specialize the processing using these types.  This still won't solve
the problem _generally_, but at least it addresses the common needs.
