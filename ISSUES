This files describe some know issues with Olena.  Please note that
Olena is a work in progress.  Later versions can be found at
    http://www.lrde.epita.fr/cgi-bin/twiki/view/Projects/Olena

BUILD AND COMPILER NOTES
========================

Olena has been tested on the following configurations : 
	
  System	Compiler
  ======        ========
  Linux		g++-3.0, g++-3.2
  Linux		Intel C++ Compiler v7 (icc)
  MacOSX	g++-3.1
  NetBSD1.6	g++-3.2

Olena used to be compatible with g++-2.95 for performance
reasons. With g++-3.2, this constraint is becoming obsolete.
Moreover, it has many annoying issues, here are the two more 
important ones :

- rejects valid expressions, often implying ugly workarounds.

- optimizations sometimes generates invalid code, especially with 
  intensive inlining.

Actually Olena yet compiles with g++-2.95, but some wrong code is
generated with data types.

Compilation time may have important differences between compilers, the
following benchmark gives an idea of the time needed to complete a
make check. The tests have been run on a Bi-Xeon 2.4Ghz machine.

  Compiler	Time
  ========      ====
  g++-2.95	16m42s
  g++-3.0	23m20s
  g++-3.2	20m03s
  icc-7		12m52s

These tests include compilation and running time, the following ones
just show the runtime benchmarks for the "extrkiller" test : 

  Compiler	Options				Time
  ========	=======				====  
  g++-2.95	-O3 -finline-limit-1500		3m14s
  g++-3.0	-O3 -finline-limit-1500		2m08s
  g++-3.2	-O3 -finline-limit-1500		1m50s
  icc-7		-O3				5m41s

LANGUAGE ENVIRONMENT
====================

Speaking about compilers, the following points are likely to cause
trouble when trying to port Olena to another build environment.

- Olena uses C99 float functions, usually not available under C++
  (since C++ was standardized in 1998). This is `fixed' with the GNU
  libc headers by the use of the _ISOC99_SOURCE preprocessor macro,
  which forces the declaration of C99 functions. When using Olena with
  another libc, please adjust your CXXFLAGS accordingly.

- The copy constructors of the image classes rely on a GCC optimization.
  There is a thorough explanation of this issue here:
  http://www.lrde.epita.fr/cgi-bin/twiki/view/Projects/OlenaConstImages

Some code in the I/O assumes little-endian machines.  Output of 16bits
and 32 bits RAW PNM images on big-endian hosts will be wrong.
PLAIN PNM (i.e. text) should be ok.

DESIGN CONSIDERATIONS
=====================

The old value/ hierarchy has been rewritten into types/. This
directory contains classes used to represent the data types.  These
classes had several problems, especially with builtin types and type
conversions. The name and overall behavior remain the same, but you
should expect some incompatibility if you use some internal stuff.  In
particular, any code using type attributes (like `T::max()') is
invalidated.

The aforementioned image/iterator/window/point/... hierarchies will
themselves be adjusted using Thierry's evil secret plan.  The result
should make the exact types downcasts superfluous in a few cases, and
will allow this classes to be decorated (much rejoicing coming with
this).  This change shouldn't break the user interface, it will just
make it easier.

Presently it is difficult to specialize a processing for a given value
type when the processing takes the aggregate type as parameter.  See
the definitions of min() and max() in src/morpho/stat.hh for an
example.  This should eventually be fixed by adding new "concept"
classes on top of the image hierarchy (something like image_bin<*>,
image_not_bin<*>, image_color<*>, image_not_color<*>, etc...) and
specialize the processing using these types.  This still won't solve
the problem _generally_, but at least it addresses the common needs.
