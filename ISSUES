This files describe some known issues with Olena.  Please note that
Olena is a work in progress.  Later versions can be found at
http://www.lrde.epita.fr/olena/.

We are developing under Linux i386 using GCC version 2.95.3, 3.0.4,
3.1 and 3.2.  Olena should compile fine with these versions of the
compiler.  Keeping the compatibility with 2.95.3 implies some
restrictions over the template constructions used in Olena, because
GCC 2.95.3 still bombs out on various valid expressions.  Therefore
some part of the code have been arranged to "please" 2.95.3.  There
are also a few issues that need workaround even with latter version of
the compiler.

There is a good reason to maintain 2.95.3 compatibility: performance.
The inlining heuristic have changed between these versions.  Kurt
Garloff has some interesting material about this issue on his web
page: http://www.garloff.de/kurt/freesoft/gcc/ Here are some figures
to give an idea of the performance penalty.  These are the
compilation- and run- times of one program (performing several
morphological operations in a 128x128x128 images) with different
compilations flags.

   GCC       options                     compilation-time  runtime
   2.95.3    -O2 -ftemplate-depth-50          59s	     46s
   3.0.3     -O2                            1m04s	    100s
   3.0.3     -O2 -finline-limit-2500        3m14s	     75s
   3.0.3     -O2 -finline-limit-4000        3m34s	     71s
   3.0.3     -O2 -finline-limit-7000        7m49s	     73s

Here are another series of figures, showing the time of `make check'
with different versions of GCC.  (`make check' run the test suite,
i.e. it compiles *and* runs a set of test programs.)  The machine is a
1GHz bi-PentiumIII.

   GCC     make check
   2.95.3    18m33s
   3.0.3     37m24s
   3.1       30m30s

Speaking about compilers, the following points are likely to cause
trouble when trying to port Olena to another build environment.

- The cast::round function use C99's round() and roundf() function.
  The GNU libc doesn't declare these functions by default, one
  has to explicitly define _ISOC99_SOURCE before including a
  system header.  This definition is actually done in src/config/system.hh,
  which is included by all the src/basic*.hh headers.
  That means that the programmer should include Olena's headers before
  other systems header.

- The copy constructors of the image classes rely on a GCC optimization.
  There is a thorough explanation of this issue here:
  http://www.lrde.epita.fr/cgi-bin/twiki/view/Projects/OlenaConstImages

Some code in the I/O assumes little-endian machines.  Output of 16bits
and 32 bits RAW PNM images on big-endian hosts will be wrong.  PLAIN
PNM (i.e. text) should be ok.

The old value/ hierarchy has been rewritten into types/. This
directory contains classes used to represent the data types.  These
classes had several problems, especially with builtin types and type
conversions. The name and overall behavior remain the same, but you
should expect some incompatibility if you use some internal stuff.  In
particular, any code using type attributes (like `T::max()') is
invalidated.

The aforementioned image/iterator/window/point/... hierarchies will
themselves be adjusted using Thierry's evil secret plan.  The result
should make the exact types downcasts superfluous in a few cases, and
will allow this classes to be decorated (much rejoicing coming with
this).  This change shouldn't break the user interface, it will just
make it easier.

Presently it's difficult to specialize a processing for a given value
type when the processing takes the aggregate type as parameter.  See
the definitions of min() and max() in src/morpho/stat.hh for an
example.  This should eventually be fixed by adding new "concept"
classes on top of the image hierarchy (something like image_bin<*>,
image_not_bin<*>, image_color<*>, image_not_color<*>, etc...) and
specialize the processing using these types.  This still won't solve
the problem _generally_, but at least it addresses the common needs.
