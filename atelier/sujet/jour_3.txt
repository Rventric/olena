	-*- outline -*-


* concepts d'images

** but

On veut différencier :

- value, rvalue et lvalue

  pas dur : value est le type des valeurs associées aux pixels
            rvalue est le type de retour de l'op() const
            lvalue celui de l'op() pas const

  exemple : pour image2d[T], on a
            value = T ; rvalue = const T& ; lvalue = T&

  conclusion : les type de retour des op() apparaissent sans 'const'
               ni '&' et ce sont rvalue et lvalue qui portent
               éventuellement le 'const' ou la '&'

- point et psite

  certaines images ne sont pas accessibles via ima(p) où 'p' est un
  point ; en revanche, il doit toujours être possible d'avoir un
  accès via op() mais l'argument ne sera pas un point, mais un
  "point site" (psite en abrégé)

  exemple : map_image[P,T] contient map_ de type std::map<P,T>
            où point = P et value = T.
            on pourrait penser à :
              
            T op()(point p) const { return map_[p]; }

	    mais ça ne compile pas car map_ est const et l'accés
            op[] pour les std::map n'existe que "non const" car
            il crée une nouvelle entrée clef-valeur (std::pair<P,T>)

            il faudrait écrire en fait :

           T op()(P p) const
           {
             typename std::map<P,T>::const_iterator i
               = this->map_.find(p);
             assert(i != map_.end());
             return *i;
           }

           ce qui serait non acceptable (trop lent !)

           map_image[P] a une méthode spéciale pour insérer un
           couple de point/valeur: .insert(P p, T t) et un
           psite ressemble à :

           map_image_psite_[P,T] = {
             typename std::map<P,T>::const_iterator i;
             ...
           }

           on en déduit :

           T op()(psite p) const { return (p.i)->second; }
                  ^^^^^
                  au lieu de point !


** les concepts

Finalement, on veut :

Image
{
  psite  : type
  point  : type
  value  : type
  rvalue : type
  // ...
  (())  : const (p : psite const&) -> rvalue
  owns_ : const (p : psite const&) -> bool
}

Notez que "owns_" a maintenant un "_" final



Image_2D : class < Image =
{
  rule { @point.grid = grid2d }
  coord : type
  // et rien d'autre maintenant !
}



Mutable_Image : class < Image
{
  rule { stc_type_is_found(lvalue) }
  lvalue : type
  (()) : (p : psite const&) -> lvalue  [1]

  // ajouter la ligne de C++ suivante :
  // using Image<Exact>::operator();
}

[1] pour pouvoir utiliser "psite", vous devez l'importer de la sur-classe
    via stc_using_from(Image, psite);


Constant_Image : class < Image
{
  rule { stc_type_is_not_found(lvalue) }
}


Point_Wise_Accessible_Image : class < Image
{
  rule { psite = point }
  has : (p : point const&) -> bool // [2]
}

[2] Ajouter l'invariant : @has(p) => @owns_(p)


Boxed_Image : class < Image =
{
  bbox : const () -> box_[point]
}

bbox est l'abrégé de "bouding box"


Random_Accessible_Image : class < Image =
{
  index : type
  ([]) : const (i : index) -> rvalue
}

Random_Mutable_Image : class < Random_Accessible_Image =
{
  ([]) : (i : index) -> lvalue
}


** la mise à jour

Etant donné les nouveaux raffinements, vous devez :

 1.  modifier les concepts existants
 1b. modifier les set_impl (behavior::identity)

 2.  ajouter les nouveaux concepts
 2b. ajouter les set_impl correspondants

 3.  adapter vos classes concrètes dont image2d[T] qui ressemble
     maintenant à :

image2d : [T : type] -> class =
{
  point : type = point2d
  psite : type = point
  coord : type = int
   value : type = T
  rvalue : type = const T&
  lvalue : type = T&

  iter : type = image_iterator_[point]
  data : type = array2d_[value, coord]

  ...
}




* value_cast

On veut un type d'image qui caste à la volée ses valeurs.  C'est
utile pour pouvoir écrire :

  image2d<int> ima;
  ima(p) = 3;
  std::cout << value_cast<float>(ima)(p) / 2 << std::endl;
  // donne : 1.5

on a :

  template <typename T, typename I>
  value_cast_image<T, I> value_cast(const Image<I>& input)
  {
    value_cast_image<T, I> tmp(input.exact());
    return tmp;
  }

une telle image n'est pas modifiable :

  typedef image2d<int> I;
  image2d<int> ima;
  value_cast_image<float, I> imaf(ima);
  imaf(p) = 0;  // ne compile pas

Normal car la conversion crée un objet temporaire (donc non
left-value) ; la classe value_cast_image[I] ne doit posséder que la
version const (lecture) de l'op().  Le comportement de cette classe
est donc (presque) l'identité.  Ainsi on aura /automatiquement/ :

   value_cast_image[I].point = I.point

(pas besoin de l'écrire puisque behavior = identity et delegatee = I)

En revanche, si I définit lvalue, et si l'on ne fait rien, alors
on aura également value_cast_image[I].lvalue = I.lvalue donc...
notre morpheur sera équippé automatique d'un "op() NON const"
qu'on ne veut vraiment pas.

L'astuce :

value_cast_image : [I : type < Image] -> class =
{
  lvalue = stc::not_delegated
  ...
}

Cela permet d'ignorer la délégation dans le cas de cette propriété.




* stack

** but

On veut une classe image_stack<n,I> qui fait croire à son utilisateur
que l'image contient des vecteurs :

    s(p) "ressemble à" un vec<n,T>
    lorsque s est une instance d'image_stack<n,I> et T = I.value

tandis qu'elle ne fait qu'enrober n images dont les donnees sont de type T.
On a donc :

  image_stack[n,I].value = vec[n, I.value]

Mais rien ne dit pour l'instant ce que vaut 'lvalue' et 'rvalue'
(ces types peuvent être différents de 'value').

Son utilisation doit etre la suivante :

  {
    typedef image2d<int> I;

    point2d p(0, 0), q(1, 1);
    box2d b(p, q);

    I ima_0(b), ima_1(b);
    ima_0(p) = 5;
    ima_1(p) = 1;

    println(ima_0);
    println(ima_1);

    image_stack<2,I> s;
    s.image(0) = ima_0;
    s.image(1) = ima_1;
    //  ou directement :
    //  image_stack<2,I> s = make_stack(ima_0, ima_1);

    println(s);

    s(p) = make_vec(6, 9);
    std::cout << s(p) << ' '
	      << ima_0(p) << ' '
	      << ima_1(p) << ' ' << std::endl;
  }

Les routines make_stack et make_vec sont bien pratiques pour
construire les objets à la volée.


** la difficulté

Le problème vient du code suivant :

     // s est NON const => on peut lire et/ou écrire
     s(p) = make_vec(6, 9);          // ici écriture
     std::cout << s(p) << std::endl; // ici lecture

Dans les 2 cas, l'op() appelé est la version "NON const" puisque
l'objet est "non const".

On veut donc que l'operator() NON const puisse être utilisé pour lire
et/ou écrire.  En fait (la ruse !), le type image_stack[n,I] est
définit avec :

      lvalue = value_proxy_[ image_stack[n,I] ]

On a :

 lvalue operator()(const psite& p) /* PAS const */
 {
   value_proxy_<I> tmp(*this, p);
   return tmp;
 } 

L'objet temporaire connaît l'image ciblée ainsi que le point ciblé.

value_proxy_ : [I : type < Image] -> class =
{
  // attributs
  ima_ : I
  p_   : I.psite

  // ctor
  make : (ima : I, p : I.psite) = { ima_ := ima; p_ := p }

  // conversion == lecture !
  () : [U : type] -> U =
  {
    return ima_.read(p) // la lecture effective
  }

  // affectation == ecriture !
  (:=) : [U : type] (u : U) -> @type =
  {
    ima_.write(p_, u) // l'écriture effective
    return @
  }

}

=> le type d'image image_stack[n,I] doit être equipé
   des methodes read_ et write_ qui réalisent effectivement
   la lecture et l'écriture

En revanche, lorsque c'est l'opérateur const qui est appelé,
on est sûr qu'il s'agit d'une lecture, donc :

 rvalue operator()(const psite& p) const
 {
   return this->read_(p);
 } 

Au final, la lecture (via read_) et l'écriture (via write_) sont
bien différenciées.

** yapuka

...

On remarque aisément que image_stack[n,I].iter = I.iter
c'est normal puisqu'on ne change pas la topologie de l'image
(même domaine de définition).


* subset

** et d'une définition, une (1)

*** explications

Soit une image de taille 3 lignes x 5 colonnes :

row
 v  0 1 2 3 4 < col
 0  . . . . .
 1  . . . . .
 2  . . . . .


avec ima étant :

1 2 3 4 5
6 7 8 9 0
5 4 3 2 1

une telle image est rectangulaire (son domaine est une box_[point2d],
pas très original...) ; on veut pouvoir restreindre son domaine à
celui-ci :

.   .   .
  .   .  
.   .   .

Pour ça, on veut un nouveau type d'images :

       subset_image_1[I,F]

où F est le type d'une fonction qui à un point p associe un booléen
qui dit si p fait partie du domaine (ou non).

Vous définissez le type de ces fonctions en SCOOP 2 :

fp2b : [Exact : type] -> class =
{
  point : type
  (()) : const (p : const point&) -> bool
}

"fp2b" signifie "function : point -> bool"

Et vous pouvez en dériver une concrète à l'aide de SCOOP 1+ (donc sans
la classe top !)

chessboard_t : class < fp2b[chessboard_t] =
{
  point = point2d
  (()) : const (p : const point&) -> bool =
  {
    return (p.row + p.col) modulo 2 = 0
  }
}

On veut pouvoir écrire "(ima | chessboard2d)" pour créer à la volée
l'image :

1 x 3   5   // le 'x' désigne le trésor
  7   9  
5   3   1

qui ne comporte plus que 8 pixels.  On a :

  point2d x(0, 1);
  assert(ima.has(x) == true);
  assert((ima | chessboard2d).has(x) == false);

*** to-do

On veut surcharger '|' :

(|) : [I : type < Image, F : type < fp2b] (ima : I, f : F) -> subset_image_1[I,F] =
{
   // on construit ici
}

On veut que "subset_image_1[I,F]" ait un comportement correct !  On doit
pouvoir le vérifier avec println (qui affichera : 1 3 5 7 9 5 3 1).  Il
faut donc un itérateur approprié pour ce nouveau type d'images.
La définition de cet itérateur doit s'appuyer sur celle de I.iter
Typiquement :

subset_image_1_iterator_ : [I,F] -> class =
{
  f_ : F
  p_ : I.iter

  ...

  start : () -> void =
  {
    p_.start()
    while (p_.is_valid() and f(p_) == false)
      p_.next()
  }
  next : () -> void =
  {
    do
       p_.next()
    while (p_.is_valid() and f(p_) == false)
  }
}


** et d'une autre définition (2)

*** hop

On veut aussi pouvoir écrire "(ima | ps)" pour dire qu'on restreint le
domaine de l'image 'ima' à l'ensemble de points 'ps' (une instance de
Point_Set).

Exemple :

  point2d p(1,1), q(2,3);
  box2d b(p, q);

Le domaine de 'ima' :

row
 v  0 1 2 3 4 < col
 0  . . . . .
 1  . . . . .
 2  . . . . .

Le domaine de "(ima | b)" :

row
 v  0 1 2 3 4 < col
 0           
 1    . . .  
 2    . . .  

Mais on ne supposera PAS que le domaine de 'ps' est inclus dans
celui de 'ima'.  On n'a PAS toujours : ps.has(p) => ima.has(p).

Remarque : pour le premier cas, on avait :
  ima.has(p) => p in D(f)  // p dans le domaine de définition de f

*** to-do

On veut définir une surcharge pour l'op (|) et une nouvelle classe :

  subset_image_2[I,Ps]

On s'attend à ce que :

  subset_image_2[I,Ps].iter soit défini à partir de I.iter

mais on n'a PAS "subset_image_2[I,Ps].iter est I.iter".
En effet, il faut toujours tester qu'on reste bien dans l'image !
Le code ressemble à du déjà-vu genre :

  start : () -> void =
  {
    p_.start()
    while (p_.is_valid() and not ima.has(p_))
      p_.next()
  }


* map_image

Cf. bla-bla en début de sujet
