							// -*- C++ -*-
#include <functional>
#include <oln/basics2d.hh>
#include <oln/core/apply.hh>
#include <oln/level/fill.hh>
#include <oln/level/compare.hh>
#include <ntg/int.hh>


// Fwd decl.
struct f_mult_3;

// Traits of f_mult_3.
namespace mlc {
  template<>
  struct function_traits<f_mult_3>
  {
    typedef int argument_type;
    typedef int result_type;
  };
} // end of namespace mlc

struct f_mult_3 : public mlc::abstract::unary_function<f_mult_3>
{
  result_type
  impl_op_paren (const argument_type& x) const
  {
    return 3 * x;
  }
};


int
mult_3 (int x)
{
  return 3 * x;
}


bool check()
{
  oln::image2d<int> ima1(10, 10);
  oln::level::fill(ima1, 10);
  oln::image2d<int> ima2(10, 10);
  oln::level::fill(ima2, 30);
  oln::image2d<int> ima3(10, 10);
  oln::level::fill(ima3, -10);

  // oln::apply, with a hand-made mlc::abstract::unary_function.
  {
    oln::image2d<int> ima;
    ima = oln::apply(f_mult_3(), ima1);
    if (oln::level::is_equal(ima, ima2))
      return false;
  }

  // oln::apply, with a mlc::unary_function built using the helper
  // function mlc::make_unary_fun on a classic function.
  {
    oln::image2d<int> ima;
    ima = oln::apply(mlc::make_unary_fun(mult_3), ima1);
    if (oln::level::is_equal(ima, ima2))
      return false;
  }

  // oln::apply, with a mlc::unary_function built using the helper
  // function mlc::make_unary_fun on a std::unary_function.
  {
    oln::image2d<int> ima;
    ima = oln::apply (mlc::make_unary_fun(std::negate<int>()), ima1);
    if (oln::level::is_equal(ima, ima3))
      return false;
  }

  // oln::apply, with a (more complex) mlc::unary_function built using
  // the helper function mlc::make_unary_fun on a std::unary_function.
  {
    oln::image2d<int> ima;
    ima =
      oln::apply (mlc::make_unary_fun(std::bind2nd(std::multiplies<int>(), 3)),
		  ima1);
    if (oln::level::is_equal(ima, ima2))
      return false;
  }

  return true;
}
