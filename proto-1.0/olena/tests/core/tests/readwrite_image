#include <iostream>

#include <ntg/all.hh>
#include <oln/basics2d.hh>

#include "check.hh"
#include "data.hh"

namespace oln {

  struct dummy_image;

  template <>
  struct set_category< dummy_image > { typedef category::image ret; };

  template <>
  struct set_super_type< dummy_image > {
    typedef abstract::image_with_data< dummy_image > ret;
  };

  template <>
  struct set_props <category::image, dummy_image> :
         	public props_of < category::image >
  {
    typedef is_a<abstract::readwrite_image> image_constness;
    typedef is_a<abstract::image2d> image_dimension_type;

    typedef size2d size_type;
    typedef point2d point_type;
    typedef ntg::int_u8 value_type;

    typedef value_type value_storage_type;
    typedef array2d<value_storage_type> storage_type;
  };

  struct dummy_image : public abstract::image_with_data< dummy_image >
  {

    typedef abstract::image_with_data< dummy_image > super_type;

    dummy_image()
    {
      this->exact_ptr = this;
    }

    dummy_image(coord_t nrows, coord_t ncols) :
      super_type(size2d(nrows, ncols))
    {
      this->exact_ptr = this;
    }

  };

} // end of namespace test



bool check()
{
  oln::dummy_image ima(3, 3);
  oln::point2d p(0,0);
  ima[p] = 51;
  std::cout << int(ima[p]) << std::endl;
  return false;
}
