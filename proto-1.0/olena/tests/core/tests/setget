							// -*- C++ -*-
#include <oln/basics.hh>


namespace oln {

  struct dummy_image;

  template <>
  struct set_category< dummy_image >
  {
    typedef category::image ret;
  };

  template <>
  struct set_props < category::image, dummy_image >
  {
    typedef mlc::no_type grid_type;
    typedef mlc::no_type concrete_type;
    typedef mlc::no_type image_rawness_type;
    typedef mlc::no_type image_dimension_type;

    typedef int size_type;
    typedef int point_type;
    typedef int value_type;
    typedef mlc::no_type delegated_type;

    typedef mlc::no_type piter_type;
    typedef mlc::no_type fwd_piter_type;
    typedef mlc::no_type bkd_piter_type;
  };

  struct dummy_image : public abstract::readwrite_image< dummy_image >
  {
    int data;

    dummy_image()
    {
      data = 3;
      exact_ptr = this;
    }

    int impl_size() const { return 1; }
    unsigned long impl_npoints() const { return 1; }
    bool impl_hold(int p) const { return true; }

    const int impl_get(int p) const
    {
      std::cout << "get" << std::endl;
      return data;
    }
    void impl_set(int p, int v)
    {
      std::cout << "set" << std::endl;
      data = v;
    }

  };

} // end of namespace test


bool check()
{
  oln::dummy_image ima;
  int p;

  ima[p] = 51;
  std::cout << ima[p] << std::endl;

  return false;
}
