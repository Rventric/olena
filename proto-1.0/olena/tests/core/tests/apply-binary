							// -*- C++ -*-
#include <functional>
#include <oln/basics2d.hh>
#include <oln/core/apply.hh>
#include <oln/level/fill.hh>
#include <oln/level/compare.hh>
#include <ntg/int.hh>


// Fwd decl.
struct f_mult;

// Traits of f_mult_3.
namespace mlc {
  template<>
  struct function_traits<f_mult>
  {
    typedef int argument1_type;
    typedef int argument2_type;
    typedef int result_type;
  };
} // end of namespace mlc

struct f_mult : public mlc::abstract::binary_function<f_mult>
{
  result_type
  impl_op_paren(const argument1_type& x, const argument1_type& y) const
  {
    return x * y;
  }
};


int
mult(int x, int y)
{
  return x * y;
}


bool check()
{
  oln::image2d<int> ima1(10, 10);
  oln::level::fill(ima1, 3);
  oln::image2d<int> ima2(10, 10);
  oln::level::fill(ima2, 4);
  oln::image2d<int> ima3(10, 10);
  oln::level::fill(ima3, 12);

  // oln::apply2, with a hand-made mlc::abstract::binary_function.
  {
    oln::image2d<int> ima;
    ima = oln::apply2(f_mult(), ima1, ima2);
    if (!oln::level::is_equal(ima, ima3))
      return true;
  }
  // oln::apply2, with a mlc::binary_function built using the helper
  // function mlc::make_binary_fun on a classic function.
  {
    oln::image2d<int> ima;
    ima = oln::apply2(mlc::make_binary_fun(mult), ima1, ima2);
    if (!oln::level::is_equal(ima, ima3))
      return true;
  }

  // oln::apply2, with a mlc::binary_function built using the helper
  // function mlc::make_binary_fun on a std::binary_function.
  {
    oln::image2d<int> ima;
    ima =
      oln::apply2(mlc::make_binary_fun(std::multiplies<int>()), ima1, ima2);
    if (!oln::level::is_equal(ima, ima3))
      return true;
  }

  return false;
}
