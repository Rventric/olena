 ;; -*- Prcs -*-
(Created-By-Prcs-Version 1 3 3)
(Project-Description "Olena")
(Project-Version oln 10 77)
(Parent-Version oln 10 71)
(Version-Log "Index: olena/ChangeLog
from  Giovanni Palma  <giovanni@lrde.epita.fr>

	* oln/morpho/closing.inc: Correct comments.
	* oln/morpho/extrema_killer.hh: Likewise.
	* oln/morpho/attribute_closing_opening_map.hh: Likewise.
	* oln/morpho/extrema.hxx: Likewise.
	* oln/morpho/erosion.hh: Likewise.
	* oln/morpho/extrema.hh: Likewise.
	* oln/morpho/attribute_closing_opening.hh: Likewise.
	* oln/morpho/attribute_union_find.hh: Likewise.
	* oln/morpho/attributes.hh: Likewise.

	* oln/morpho/dilation.hh: Add comments.
	* oln/morpho/fast_morpho.hh: Likewise.
	* oln/morpho/fast_morpho.hxx: Likewise.
	* oln/morpho/geodesic_dilation.hh: Likewise.
	* oln/morpho/geodesic_erosion.hh: Likewise.
	* oln/morpho/gradient.inc: Likewise.
	* oln/morpho/hit_or_miss.inc: Likezise.
	* oln/morpho/laplacian.inc: Likewise.
	* oln/morpho/minmax.hh: Likewise.
	* oln/morpho/opening.inc: Likewise.
	* oln/morpho/reconstruction.hh: Likewise.
	* oln/morpho/splitse.hh: Likewise.
	* oln/morpho/stat.hh: Likewise.
	* oln/morpho/thickening.inc: Likewise.
	* oln/morpho/thinning.inc: Likewise.
	* oln/morpho/top_hat.inc: Likewise.
	* oln/morpho/watershed.hh: Likewise.
	* oln/morpho/watershed.hxx: Likewise.

Index: olena/oln/morpho/closing.inc
--- olena/oln/morpho/closing.inc Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/44_closing.in 1.15 600)
+++ olena/oln/morpho/closing.inc Wed, 10 Mar 2004 19:57:33 +0100 palma_g (oln/44_closing.in 1.15 640)
@@ -30,11 +30,11 @@
  * ns: morpho, morpho::fast
  * what: Morphological closing.
  * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
+ * arg: const abstract::struct_elt<E>&, se, IN, structuring element
  * ret:oln_concrete_type(I)
  * doc:
  *   Compute the morphological closing of \\var{input} using \\var{se}
- *   as structural element.
+ *   as structuring element.
  * see: morpho::erosion
  * see: morpho::dilation
  * see: morpho::closing
@@ -47,14 +47,14 @@
 /*!
 ** \\brief Processing closing.
 **
-** Compute the  morphological closing of input using  se as structural
+** Compute the  morphological closing of input using  se as structuring
 ** element.
 **
-** \\param I: exact type of the input image.
-** \\param E: exact type of the structural element.
+** \\param I Exact type of the input image.
+** \\param E Exact type of the structuring element.
 **
-** \\arg input: input image to close.
-** \\arg se: structural element to use.
+** \\arg input Input image to close.
+** \\arg se Structuring element to use.
 **
 ** \\warning  This  code  is  the  same  for  morpho  and  morpho::fast
 ** namespaces.
Index: olena/oln/morpho/dilation.hh
--- olena/oln/morpho/dilation.hh Thu, 07 Aug 2003 02:08:21 +0200 david (oln/b/5_dilation.h 1.16 600)
+++ olena/oln/morpho/dilation.hh Wed, 10 Mar 2004 19:58:42 +0100 palma_g (oln/b/5_dilation.h 1.16 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -37,42 +37,56 @@
 
   namespace morpho {
 
-    /*=processing dilation
-     * ns: morpho, morpho::fast
-     * what: Morphological dilation.
-     * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
-     * arg: const abstract::struct_elt<E>&, se, IN, structural element
-     * ret:oln_concrete_type(I)
-     * doc:
-     *   Compute the morphological dilation of \\var{input} using \\var{se}
-     *   as structural element.
-     *
-     *   On grey-scale images, each point is replaced by the maximum value
-     *   of its neighbors, as indicated by \\var{se}.  On binary images,
-     *   a logical \\code{or} is performed between neighbors.
-     *
-     *   The \\code{morpho::fast} version of this function use a different
-     *   algorithm: This algorith; is described in
-     * Implementation of morphological operations from:
-     * M. Van Droogenbroeck and H. Talbot.
-     * \"Fast computation of morphological operations with arbitrary
-     * structuring elements\". Pattern Recognition Letters,
-     * 17(14):1451-1460, 1996.
-     *
-     *   An
-     *   histogram of the value of the neighborhood indicated by
-     *   \\var{se} is updated while iterating over all point of the
-     *   image.  Doing so is more efficient  when the
-     *   structural element is large.
-     *
-     * see: morpho::n_dilation
-     * see: morpho::erosion
-     * ex:
-     * $ image2d<ntg::bin> im = load(\"object.pbm\");
-     * $ save(morpho::dilation(im, win_c8p()), \"out.pbm\");
-     * exi: object.pbm
-     * exo: out.pbm
-    =*/
+    /*!
+    ** \\brief Processing dilation.
+    **
+    ** Compute the morphological dilation of input using se
+    ** as structural element.
+    **
+    ** On grey-scale images, each point is replaced by the maximum value
+    ** of its neighbors, as indicated by se.  On binary images,
+    ** a logical or is performed between neighbors.
+    **
+    ** The morpho::fast version of this function use a different
+    ** algorithm: This algorithm is described in
+    ** Implementation of morphological operations from:
+    ** M. Van Droogenbroeck and H. Talbot.
+    ** \"Fast computation of morphological operations with arbitrary
+    ** structuring elements\". Pattern Recognition Letters,
+    ** 17(14):1451-1460, 1996.
+    **
+    ** An histogram of the value of the neighborhood indicated by
+    ** se is updated while iterating over all point of the
+    ** image.  Doing so is more efficient  when the
+    ** structural element is large.
+    **
+    ** \\param I Exact type of the input image.
+    ** \\param E Exact type of the neighborhood.
+    **
+    ** \\arg input The input image.
+    ** \\arg se Structuring element to use.
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/dilation.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::bin>	im_type;
+    **
+    **   im_type im1(oln::load(IMG_IN \"object.pbm\"));
+    **   save(oln::morpho::dilation(im1, oln::win_c8p()), IMG_OUT \"oln_morpho_dilation.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html object.png
+    ** \\image latex object.png
+    ** =>
+    ** \\image html oln_morpho_dilation.png
+    ** \\image latex oln_morpho_dilation.png
+    */
     template<class I, class E>
     oln_concrete_type(I) 
       dilation(const abstract::non_vectorial_image<I> &input, 
@@ -89,18 +103,39 @@
       return output;
     }
 
-    /*=processing n_dilation
-     * ns: morpho
-     * what: Morphological dilation itered n times.
-     * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
-     * arg: const abstract::struct_elt<E>&, se, IN, structural element
-     * arg: unsigned, n, IN, number of iterations
-     * ret:oln_concrete_type(I)
-     * doc:
-     *   Apply \\code{morpho::dilation} \\var{n} times.
-     * see: morpho::dilation
-     * see: morpho::n_erosion
-    =*/
+    /*!
+    ** \\brief Perform morphological dilation iterated n times.
+    **
+    **
+    ** \\param I Exact type of the input image.
+    ** \\param E Exact type of the structuring element.
+    **
+    ** \\arg input Input image.
+    ** \\arg se Structuring element to use.
+    ** \\arg n Number of iterations.
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/dilation.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::bin>	im_type;
+    **
+    **   im_type im1(oln::load(IMG_IN \"object.pbm\"));
+    **   save(oln::morpho::n_dilation(im1, oln::win_c8p(), 5), IMG_OUT \"oln_morpho_n_dilation.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html object.png
+    ** \\image latex object.png
+    ** =>
+    ** \\image html oln_morpho_n_dilation.png
+    ** \\image latex oln_morpho_n_dilation.png
+    **
+    */
     template<class I, class E>
     oln_concrete_type(I) 
       n_dilation(const abstract::non_vectorial_image<I> & input,
Index: olena/oln/morpho/erosion.hh
--- olena/oln/morpho/erosion.hh Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/b/4_erosion.hh 1.18 600)
+++ olena/oln/morpho/erosion.hh Wed, 10 Mar 2004 20:00:55 +0100 palma_g (oln/b/4_erosion.hh 1.18 640)
@@ -40,7 +40,7 @@
     ** \\brief Perform a morphological erosion.
     **
     **   Compute the morphological erosion of input using se
-    **   as structural element.
+    **   as structuring element.
     **
     **   On grey-scale  images, each point is replaced  by the minimum
     **   value  of  its neighbors,  as  indicated  by  se.  On  binary
@@ -48,15 +48,15 @@
     **   morpho::fast  version  of   this  function  use  a  different
     **   algorithm:  an histogram  of  the value  of the  neighborhood
     **   indicated by se is updated  while iterating over all point of
-    **   the image.   Doing so is  more efficient when  the structural
+    **   the image.   Doing so is  more efficient when  the structuring
     **   element is large.
     **
-    ** \\param I: exact type of the input image.
-    ** \\param E: exact type of the structural element.
+    ** \\param I Exact type of the input image.
+    ** \\param E Exact type of the structuring element.
     **
     **
-    ** \\arg input: input image.
-    ** \\arg se: structural element to use.
+    ** \\arg input Input image.
+    ** \\arg se Structuring element to use.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
@@ -97,15 +97,15 @@
     }
 
     /*!
-    ** \\brief Perform morphological erosion itered n times.
+    ** \\brief Perform morphological erosion iterated n times.
     **
     **
-    ** \\param I: exact type of the input image.
-    ** \\param E: exact type of the structural element.
+    ** \\param I Exact type of the input image.
+    ** \\param E Exact type of the structuring element.
     **
-    ** \\arg input: input image.
-    ** \\arg se: structural element to use.
-    ** \\arg n: number of iterations.
+    ** \\arg input Input image.
+    ** \\arg se Structuring element to use.
+    ** \\arg n Number of iterations.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
@@ -151,14 +151,14 @@
       ** \\brief Perform a morphological erosion.
       **
       **   Compute the morphological erosion of input using se
-      **   as structural element.
+      **   as structuring element.
       **
-      ** \\param I: exact type of the input image.
-      ** \\param E: exact type of the structural element.
+      ** \\param I Exact type of the input image.
+      ** \\param E Exact type of the structuring element.
       **
       **
-      ** \\arg input: input image.
-      ** \\arg se: structural element to use.
+      ** \\arg input Input image.
+      ** \\arg se Structuring element to use.
       **
       ** \\code
       ** #include <oln/basics2d.hh>
Index: olena/oln/morpho/extrema.hh
--- olena/oln/morpho/extrema.hh Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/38_extrema.hh 1.12 600)
+++ olena/oln/morpho/extrema.hh Thu, 11 Mar 2004 16:22:19 +0100 palma_g (oln/38_extrema.hh 1.12 640)
@@ -38,7 +38,8 @@
     /*!
     ** \\brief oln::morpho::sure namespace.
     **
-    ** Here come algorithms that are sure.
+    ** Namespace where  you can find reference  algorithms, i.e. those
+    ** that are sure.
     */
     namespace sure {
 # include <oln/morpho/extrema.hxx>
@@ -47,7 +48,7 @@
     /*!
     ** \\brief oln::morpho::sequential namespace.
     **
-    ** Here come algorithms that are sequential.
+    ** Namespace where you can find sequential algorithms.
     */
     namespace sequential {
 # include <oln/morpho/extrema.hxx>
@@ -56,7 +57,7 @@
     /*!
     ** \\brief oln::morpho::hybrid namespace.
     **
-    ** Here come algorithms that are hybrid.
+    ** Namespace where you can find hybrid algorithms.
     */
     namespace hybrid {
 # include <oln/morpho/extrema.hxx>
Index: olena/oln/morpho/extrema.hxx
--- olena/oln/morpho/extrema.hxx Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/j/4_extrema.hx 1.12 600)
+++ olena/oln/morpho/extrema.hxx Wed, 10 Mar 2004 20:02:35 +0100 palma_g (oln/j/4_extrema.hx 1.12 640)
@@ -33,10 +33,10 @@
   /*!
   ** \\brief Create extremum image from another one.
   **
-  ** \\param DestType: type of data in the wanted image.
-  ** \\param I: Exact type of the input image.
+  ** \\param DestType Type of data in the wanted image.
+  ** \\param I Exact type of the input image.
   **
-  ** \\arg input: input image.
+  ** \\arg input Input image.
   */
   template <class DestType, class I>
   typename mute<I, DestType>::ret
@@ -57,9 +57,9 @@
   /*!
   ** \\brief Create binary image from another one.
   **
-  ** \\param I: exact type of the image.
+  ** \\param I Exact type of the image.
   **
-  ** \\arg input: input image.
+  ** \\arg input Input image.
   */
   template <class I>
   typename mute<I, ntg::bin>::ret
@@ -85,13 +85,13 @@
 ** neighborhood. minima_map must  be a bin image (true  for a minimum,
 ** false for a non minimum).  Soille p.172.
 **
-** \\param I: exact type of the first image.
-** \\param I2: exact type of the second image.
-** \\param N: exact type of the neighborhood.
-**
-** \\arg input: input image.
-** \\arg minima_map: minima map image.
-** \\arg Ng: neighborhood to use.
+** \\param I Exact type of the first image.
+** \\param I2 Exact type of the second image.
+** \\param N Exact type of the neighborhood.
+**
+** \\arg input Input image.
+** \\arg minima_map Minima map image.
+** \\arg Ng Neighborhood to use.
 **
 ** \\ref foototo
 ** \\code
@@ -146,11 +146,11 @@
 /*!
 ** \\brief Extract regional minima.
 **
-** \\param I: Exact type of input image.
+** \\param I Exact type of input image.
 ** \\param Exact type of neighborhood.
 **
-** \\arg input: input image.
-** \\arg Ng: neighborhood to use.
+** \\arg input Input image.
+** \\arg Ng Neighborhood to use.
 **
 ** \\code
 ** #include <oln/basics2d.hh>
Index: olena/oln/morpho/extrema_killer.hh
--- olena/oln/morpho/extrema_killer.hh Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/e/19_extrema_ki 1.7.1.4.1.11 600)
+++ olena/oln/morpho/extrema_killer.hh Wed, 10 Mar 2004 20:06:34 +0100 palma_g (oln/e/19_extrema_ki 1.7.1.4.1.11 640)
@@ -51,12 +51,12 @@
     /*!
     ** \\brief Kill connex components smaller than a given area.
     **
-    ** \\param I: exact type of the input image.
-    ** \\param N: exact type of the neighborhood.
+    ** \\param I E xact type of the input image.
+    ** \\param N Exact type of the neighborhood.
     **
-    ** \\arg input: the input image.
-    ** \\arg area: the threshold to use.
-    ** \\arg Ng: the neighborhood to use.
+    ** \\arg input The input image.
+    ** \\arg area The threshold to use.
+    ** \\arg Ng The neighborhood to use.
     */
     template<class I, class N>
     typename mute<I, ntg::bin>::ret
@@ -95,16 +95,16 @@
     ** \\brief Maxima killer.
     **
     ** It removes the small (in area) connected components of the upper
-    ** level sets of input using se as structual element. The implementation
+    ** level sets of input using se as structuring element. The implementation
     ** uses the threshold superposition principle; so it is very slow ! it works only for
     ** int_u8 images.
     **
-    ** \\param I: image exact type.
-    ** \\param N: neighborhood exact type.
+    ** \\param I Image exact type.
+    ** \\param N Neighborhood exact type.
     **
-    ** \\arg input: the input image.
-    ** \\arg area: threshold to use.
-    ** \\arg Ng: the neighborhood to use.
+    ** \\arg input The input image.
+    ** \\arg area Threshold to use.
+    ** \\arg Ng The neighborhood to use.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
@@ -167,17 +167,17 @@
     /*!
     ** \\brief Minima killer.
     **
-    ** It removes the small (in area) connected components of the lower
-    ** level sets of input using se as structual element. The implementation
-    ** uses the threshold superposition principle; so it is very slow ! it works only for
-    ** int_u8 images.
-    **
-    ** \\param I: image exact type.
-    ** \\param N: neighborhood exact type.
-    **
-    ** \\arg input: the input image.
-    ** \\arg area: threshold to use.
-    ** \\arg Ng: the neighborhood to use.
+    ** It  removes the  small (in  area) connected  components  of the
+    ** lower level sets of input  using se as structuring element. The
+    ** implementation uses  the threshold superposition  principle; so
+    ** it is very slow ! it works only for int_u8 images.
+    **
+    ** \\param I Image exact type.
+    ** \\param N Neighborhood exact type.
+    **
+    ** \\arg input The input image.
+    ** \\arg area Threshold to use.
+    ** \\arg Ng The neighborhood to use.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
@@ -245,14 +245,14 @@
     /*!
     ** \\brief Check if a point is a strict minimum.
     **
-    ** \\param P: exact type of the point.
-    ** \\param I: exact type of the image.
-    ** \\param N: exact type of the neighborhood.
+    ** \\param P Exact type of the point.
+    ** \\param I Exact type of the image.
+    ** \\param N Exact type of the neighborhood.
     **
-    ** \\arg p: the point to consider.
-    ** \\arg input: the image where to  get the value of the point to
+    ** \\arg p The point to consider.
+    ** \\arg input The image where to  get the value of the point to
     ** consider.
-    ** \\arg Ng: type of neighborhood to use.
+    ** \\arg Ng Type of neighborhood to use.
     */
     template<class P, class I, class N>
     //    inline
@@ -280,14 +280,14 @@
     /*!
     ** \\brief Check if a point is a strict maximum.
     **
-    ** \\param P: exact type of the point.
-    ** \\param I: exact type of the image.
-    ** \\param N: exact type of the neighborhood.
+    ** \\param P Exact type of the point.
+    ** \\param I Exact type of the image.
+    ** \\param N Exact type of the neighborhood.
     **
-    ** \\arg p: the point to consider.
-    ** \\arg input: the image where to  get the value of the point to
+    ** \\arg p The point to consider.
+    ** \\arg input The image where to  get the value of the point to
     ** consider.
-    ** \\arg Ng: type of neighborhood to use.
+    ** \\arg Ng Type of neighborhood to use.
     */
     template<class P, class I, class N>
     // inline
@@ -321,12 +321,12 @@
     ** implementation  is based  on  stak. Guichard  and Morel,  Image
     ** iterative smoothing and PDE's.  Book in preparation. p 265.
     **
-    ** \\param I: image exact type.
-    ** \\param N: neighborhood exact type.
+    ** \\param I Image exact type.
+    ** \\param N Neighborhood exact type.
     **
-    ** \\arg input: the input image.
-    ** \\arg area: threshold to use.
-    ** \\arg Ng: the neighborhood to use.
+    ** \\arg input The input image.
+    ** \\arg area Threshold to use.
+    ** \\arg Ng The neighborhood to use.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
@@ -446,12 +446,12 @@
     ** implementation  is based  on  stak. Guichard  and Morel,  Image
     ** iterative smoothing and PDE's.  Book in preparation. p 265.
     **
-    ** \\param I: image exact type.
-    ** \\param N: neighborhood exact type.
+    ** \\param I Image exact type.
+    ** \\param N Neighborhood exact type.
     **
-    ** \\arg input: the input image.
-    ** \\arg area: threshold to use.
-    ** \\arg Ng: the neighborhood to use.
+    ** \\arg input The input image.
+    ** \\arg area Threshold to use.
+    ** \\arg Ng The neighborhood to use.
     **
     ** \\code
     ** #include <oln/basics2d.hh>
Index: olena/oln/morpho/fast_morpho.hh
--- olena/oln/morpho/fast_morpho.hh Thu, 07 Aug 2003 02:08:21 +0200 david (oln/46_fast_morph 1.8 600)
+++ olena/oln/morpho/fast_morpho.hh Wed, 10 Mar 2004 17:10:53 +0100 palma_g (oln/46_fast_morph 1.8 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -33,6 +33,10 @@
 
 namespace oln {
   namespace morpho {
+    /*!
+    ** Do not exist !!!
+    ** \\todo FIXME: REMOVE ME.
+    */
     template<class I, class E> inline
     oln_concrete_type(I)
       fast_morpho(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/fast_morpho.hxx
--- olena/oln/morpho/fast_morpho.hxx Thu, 07 Aug 2003 02:08:21 +0200 david (oln/45_fast_morph 1.18 600)
+++ olena/oln/morpho/fast_morpho.hxx Wed, 10 Mar 2004 19:24:52 +0100 palma_g (oln/45_fast_morph 1.18 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -40,12 +40,21 @@
 namespace oln {
   namespace morpho {
 
+    /*!
+    ** \\brief oln::morpho::internal namespace
+    ** Internal stuff.
+    */
     namespace internal {
 
-      // Find structuring elements to be added/removed from the histogram
-      // when we move forward along each direction.
-      // FIXME: add(dp) on w_windows associates a default weight set
-      // to 1 
+      /*!
+      ** \\brief Find structuring elements.
+      **
+      ** Find structuring elements to be added/removed from the histogram
+      ** when we move forward along each direction.
+      **
+      ** \\todo FIXME: add(dp) on w_windows associates a default weight set
+      ** to 1
+      */
       template<class E1, class E2, class E3>
       void
       find_struct_elts(const abstract::struct_elt<E1>& se,
@@ -101,9 +110,12 @@
 	  postcondition(se_add[n].card() == se_rem[n].card());
       }
 
-
-      // Update HIST by adding elements from _SE_ADD, and removing
-      // those from _SE_REM.
+      /*!
+      ** \\brief Update an histogram.
+      **
+      ** Update HIST by adding elements from _SE_ADD, and removing
+      ** those from _SE_REM.
+      */
       template<class I, class E1, class E2, class H>
       // inline
       void
@@ -126,16 +138,20 @@
       }
 
 
-      // We will zigzag over the image so that only one coordinate
-      // changes at each step.  The path looks as follow on
-      // 2D images:
-      //   -----------------.
-      //   ,----------------'
-      //   `----------------.
-      //   ,----------------'
-      //   `-----------------
-      // (The algorithm below handles the n-dimensional case.)
-
+      /*!
+      ** We will zigzag over the image so that only one coordinate
+      ** changes at each step.  The path looks as follow on
+      ** 2D images:\\n
+      ** --------------\\
+      **               |
+      ** /-------------/
+      ** |
+      ** \\-------------\\
+      **               |
+      ** -------------/
+      ** \\n
+      ** (The algorithm below handles the n-dimensional case.)
+      */
       template<unsigned NP1,
 	       unsigned Dim,
 	       typename I,
@@ -145,6 +161,10 @@
 	       typename P,
 	       typename O>
       struct fast_morpho_inner {
+
+	/*!
+	** Perform the action.
+	*/
 	static void
 	doit(I& input, S& size, H& hist,
 	     B* se_add, B* se_rem, B* se_add_back, B* se_rem_back,
@@ -237,23 +257,60 @@
       };
     } // internal
 
-
+    /*!
+    ** \\brief functor to sort dimensions.
+    */
     template<class E>
     struct sort_dimensions
     {
+      /*!
+      ** \\brief Constructor.
+      */
       sort_dimensions(abstract::struct_elt<E> se[mlc::exact<E>::ret::dim])
 	: se_(se) {}
 
+      /*!
+      ** \\brief Parenthesis operator.
+      **
+      ** Call it to use the functor.
+      */
       bool operator()(unsigned a, unsigned b)
       {
 	return se_[a].card() > se_[b].card();
       }
 
     protected:
-      abstract::struct_elt<E>* se_;
+      abstract::struct_elt<E>* se_; ///< Structural element.
     };
     
-    
+    /*!
+    ** \\brief Fast morpho algorithm.
+    **
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/erosion.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::bin>	im_type;
+    **
+    **   im_type im1(oln::load(IMG_IN \"object.pbm\"));
+    **   //save(oln::morpho::fast_morpho<im_type, oln::win_c8p(), utils::histogram_min>
+    **   //            (im1, oln::win_c8p()), IMG_OUT \"oln_morpho_fast_morpho.pbm\");
+    **   save(im1, IMG_OUT \"oln_morpho_fast_morpho.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html object.png
+    ** \\image latex object.png
+    ** =>
+    ** \\image html oln_morpho_fast_morpho.png
+    ** \\image latex oln_morpho_fast_morpho.png
+    ** \\todo FIXME: Correct this function and make the example use it.
+    */
     template<class I, class E, template<typename, typename> class H>
     oln_concrete_type(I)
       fast_morpho(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/geodesic_dilation.hh
--- olena/oln/morpho/geodesic_dilation.hh Wed, 08 Oct 2003 23:36:51 +0200 burrus_n (oln/37_geodesic_d 1.11.1.10 600)
+++ olena/oln/morpho/geodesic_dilation.hh Thu, 11 Mar 2004 19:56:56 +0100 palma_g (oln/37_geodesic_d 1.11.1.10 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -42,28 +42,48 @@
 namespace oln {
   namespace morpho {
 
-    /*=processing geodesic_dilation
-     * ns: morpho
-     * what: Geodesic dilation.
-     * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-     * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-     * arg: const abstract::struct_elt<E>&, se, IN, structural element
-     * ret:oln_concrete_type(I1)
-     * doc:
-     *  Compute the geodesic dilation of \\var{marker} with respect
-     * to the mask \\var{mask} image using \\var{se}
-     *   as structural element. Soille p.156.
-     * Note mask must be greater or equal than marker.
-     * see: morpho::simple_geodesic_dilation
-     * ex:
-     * $ image2d<int_u8> light = load(\"light.pgm\");
-     * $ image2d<int_u8> dark = load(\"dark.pgm\");
-     * $ save(morpho::geodesic_dilation(dark, light, win_c8p()), \"out.pgm\");
-     * exi: light.pgm dark.pgm
-     * exo: out.pgm
-     * wontcompile: fixme
-     =*/
-
+    /*!
+    ** \\brief Processing a geodesic dilation.
+    **
+    ** \\param I1 Exact type of image marker.
+    ** \\param I2 Exact type of image mask.
+    ** \\param N Exact type of neighborhood.
+    **
+    ** \\arg marker Image to work on.
+    ** \\arg mask Image used for geodesic dilation.
+    ** \\arg Ng Neighborhood to use.
+    **
+    ** Compute  the geodesic dilation  of marker  with respect  to the
+    ** mask  image  using  se  as  structuring  element.  Soille
+    ** p.156.
+    ** \\pre Mask must be greater or equal than marker.
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/opening.hh>
+    ** #include <oln/morpho/geodesic_dilation.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::int_u8>	im_type;
+    **
+    **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+    **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+    **
+    **   save(oln::morpho::geodesic_dilation(im2, im1, oln::neighb_c4()),
+    **                                       IMG_OUT \"oln_morpho_geodesic_dilation.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html lena128.png
+    ** \\image latex lena128.png
+    ** =>
+    ** \\image html oln_morpho_geodesic_dilation.png
+    ** \\image latex oln_morpho_geodesic_dilation.png
+    **
+    */
     template<class I1, class I2, class N>
     oln_concrete_type(I1) 
       geodesic_dilation(const abstract::non_vectorial_image<I1> & marker,
@@ -80,29 +100,51 @@
     }
 
     namespace sure {
-      /*=processing simple_geodesic_dilation
-       * ns: morpho
-       * what: Geodesic dilation.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the geodesic dilation of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.156. Computation is
-       * performed by hand (i.e without calling dilation).
-       * Note mask must be greater or equal than marker.
-       * see: morpho::sure_geodesic_dilation
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::simple_geodesic_dilation(dark, light,
-       * $                                       win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+      /*!
+      ** \\brief Processing a geodesic dilation.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic dilation.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** Compute  the geodesic dilation  of marker  with respect  to the
+      ** mask  image  using  se  as  structuring  element.  Soille
+      ** p.156.
+      ** \\pre Mask must be greater or equal than marker.
+      **
+      ** \\warning This version shouldn't  be use, since it exists only
+      ** to have a reference algorithm.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/geodesic_dilation.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   save(oln::morpho::sure::geodesic_dilation(im2, im1, oln::neighb_c4()),
+      **                                       IMG_OUT \"oln_morpho_sure_geodesic_dilation.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sure_geodesic_dilation.png
+      ** \\image latex oln_morpho_sure_geodesic_dilation.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1) 
 	geodesic_dilation(const abstract::non_vectorial_image<I1> & marker,
Index: olena/oln/morpho/geodesic_erosion.hh
--- olena/oln/morpho/geodesic_erosion.hh Wed, 08 Oct 2003 23:36:51 +0200 burrus_n (oln/36_geodesic_e 1.17 600)
+++ olena/oln/morpho/geodesic_erosion.hh Thu, 11 Mar 2004 19:58:19 +0100 palma_g (oln/36_geodesic_e 1.17 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -39,27 +39,49 @@
 namespace oln {
   namespace morpho {
 
-    /*=processing geodesic_erosion
-     * ns: morpho
-     * what: Geodesic erosion.
-     * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-     * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-     * arg: const abstract::struct_elt<E>&, se, IN, structural element
-     * ret:oln_concrete_type(I1)
-     * doc:
-     *  Compute the geodesic erosion of \\var{marker} with respect
-     * to the mask \\var{mask} image using \\var{se}
-     *   as structural element. Soille p.158.
-     * Note marker must be greater or equal than mask.
-     * see: morpho::simple_geodesic_dilation
-     * ex:
-     * $ image2d<int_u8> light = load(\"light.pgm\");
-     * $ image2d<int_u8> dark = load(\"dark.pgm\");
-     * $ save(morpho::geodesic_erosion(light, dark, win_c8p()), \"out.pgm\");
-     * exi: light.pgm dark.pgm
-     * exo: out.pgm
-     * wontcompile: fixme
-     =*/
+    /*!
+    ** \\brief Processing a geodesic erosion.
+    **
+    ** \\param I1 Exact type of image marker.
+    ** \\param I2 Exact type of image mask.
+    ** \\param N Exact type of neighborhood.
+    **
+    ** \\arg marker Image to work on.
+    ** \\arg mask Image used for geodesic dilation.
+    ** \\arg Ng Neighborhood to use.
+    **
+    ** Compute  the geodesic erosion  of marker  with respect  to the
+    ** mask mask image using se as structural element. Soille p.158.
+    **
+    ** \\pre Marker must be greater or equal than mask.
+    **
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/opening.hh>
+    ** #include <oln/morpho/geodesic_erosion.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::int_u8>	im_type;
+    **
+    **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+    **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+    **
+    **   save(oln::morpho::geodesic_erosion(im1, im2, oln::neighb_c4()),
+    **                                       IMG_OUT \"oln_morpho_geodesic_erosion.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html lena128.png
+    ** \\image latex lena128.png
+    ** =>
+    ** \\image html oln_morpho_geodesic_erosion.png
+    ** \\image latex oln_morpho_geodesic_erosion.png
+    **
+    */
     template<class I1, class I2, class N>
     oln_concrete_type(I1)
       geodesic_erosion(const abstract::non_vectorial_image<I1> & marker,
@@ -74,28 +96,53 @@
     }
 
     namespace sure {
-      /*=processing simple_geodesic_erosion
-       * ns: morpho
-       * what: Geodesic erosion.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the geodesic erosion of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.156. Computation is
-       * performed by hand (i.e without calling dilation).
-       * Note marker must be greater or equal than mask.
-       * see: morpho::sure_geodesic_dilation
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::geodesic_erosion(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+      /*!
+      ** \\brief Processing a geodesic erosion.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic dilation.
+      ** \\arg Ng Neighborhood to use.
+      **
+      **  Compute the  geodesic erosion of marker with  respect to the
+      ** mask  mask  image  using  se as  structural  element.  Soille
+      ** p.156. Computation is performed  by hand (i.e without calling
+      ** dilation).
+      **
+      ** \\pre Marker must be greater or equal than mask.
+      **
+      ** \\warning This version shouldn't  be use, since it exists only
+      ** to have a reference algorithm.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/geodesic_erosion.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   save(oln::morpho::sure::geodesic_erosion(im1, im2, oln::neighb_c4()),
+      **                                       IMG_OUT \"oln_morpho_sure_geodesic_erosion.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sure_geodesic_erosion.png
+      ** \\image latex oln_morpho_sure_geodesic_erosion.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1) 
 	geodesic_erosion(const abstract::non_vectorial_image<I1> & marker,
Index: olena/oln/morpho/gradient.inc
--- olena/oln/morpho/gradient.inc Thu, 07 Aug 2003 02:08:21 +0200 david (oln/43_gradient.i 1.13 600)
+++ olena/oln/morpho/gradient.inc Thu, 11 Mar 2004 16:05:01 +0100 palma_g (oln/43_gradient.i 1.13 640)
@@ -1,13 +1,13 @@
 // -*- c++ -*-
-// Copyright (C) 2001  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
 // of the GNU General Public License version 2 as published by the
 // Free Software Foundation.
 //
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// This library is distributed in the hope that it will be useful, but
+// WITHOUT  ANY  WARRANTY;  without   even  the  implied  warranty  of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // General Public License for more details.
 //
@@ -26,28 +26,16 @@
 // reasons why the executable file might be covered by the GNU General
 // Public License.
 
-
-
-/*=processing beucher_gradient
- * ns: morpho, morpho::fast
- * what: Morphological Beucher Gradient.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute the arithmetic difference between the diltation and
- * the erosion of \\var{input}  using \\var{se} as structural element. Soille, p67.
- * see: morpho::erosion
- * see: morpho::dilation
- * see: morpho::external_gradient
- * see: morpho::internal_gradient
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::beucher_gradient(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Process a morphological beucher gradient.
+**
+** Compute  the arithmetic  difference between  the diltation  and the
+** erosion of input using se as structural element. Soille, p67.
+**
+** \\arg c Conversion functor.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 beucher_gradient(const convert::abstract::conversion<C, B>& c,
@@ -57,14 +45,41 @@
   return arith::minus(c, dilation(input, se), erosion(input, se));
 }
 
-
-/*=processingoverload beucher_gradient
- * ns: morpho, morpho::fast
- * what: Morphological Beucher Gradient.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret:oln_concrete_type(I)
-=*/
+/*!
+** \\brief Process a morphological beucher gradient.
+**
+** \\param I Exact type of the input image.
+** \\param E Exact type of the structuring element.
+**
+** \\return The beucher gradient of the input.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/gradient.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+**
+**   save(oln::morpho::beucher_gradient(im1, oln::win_c8p()),
+**        IMG_OUT \"oln_morpho_beucher_gradient.pbm\");
+**   return  0;
+** }
+** \\encode
+**
+** \\image html lena128.png
+** \\image latex lena128.png
+** =>
+** \\image html oln_morpho_beucher_gradient.png
+** \\image latex oln_morpho_beucher_gradient.png
+**
+*/
 template<class I, class E>
 oln_concrete_type(I) 
   beucher_gradient(const abstract::non_vectorial_image<I>& input,
@@ -74,25 +89,20 @@
 }
 
 
-/*=processing internal_gradient
- * ns: morpho, morpho::fast
- * what: Morphological Internal Gradient.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute the arithmetic difference between the original image \\var{input} and
- * the erosion of \\var{input} using \\var{se} as structural element. Soille, p67.
- * see: morpho::beucher_gradient
- * see: morpho::external_gradient
- * see: morpho::erosion
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::internal_gradient(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Process a morphological internal gradient.
+**
+** \\return The internal gradient of the input.
+**
+**
+** \\arg c Conversion functor.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** Compute the arithmetic difference between the original image input and
+** the erosion of input using se as structural element. Soille, p67.
+**
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 internal_gradient(const convert::abstract::conversion<C, B>& c,
@@ -102,13 +112,40 @@
   return arith::minus(c, input, erosion(input, se));
 }
 
-/*=processingoverload internal_gradient
- * ns: morpho, morpho::fast
- * what: Morphological Internal Gradient.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret:oln_concrete_type(I)
-=*/
+/*!
+** \\brief Process a morphological internal gradient.
+**
+** \\param I Exact type of the input image.
+** \\param E Exact type of the structuring element.
+**
+** \\return The internal gradient of the input.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/gradient.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   save(oln::morpho::internal_gradient(im1, oln::win_c8p()),
+**        IMG_OUT \"oln_morpho_internal_gradient.pbm\");
+**   return  0;
+** }
+** \\encode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_internal_gradient.png
+** \\image latex oln_morpho_internal_gradient.png
+*/
 template<class I, class E>
 oln_concrete_type(I) 
   internal_gradient(const abstract::non_vectorial_image<I>& input, const
@@ -117,26 +154,17 @@
   return internal_gradient(convert::force<oln_value_type(I)>(), input, se);
 }
 
-/*=processing external_gradient
- * ns: morpho, morpho::fast
- * what: Morphological External Gradient.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute the arithmetic difference between  and the dilatation of
- * \\var{input} using \\var{se} as structural element, and the original image
- * \\var{input}. Soille, p67.
- * see: morpho::beucher_gradient
- * see: morpho::internal_gradient
- * see: morpho::dilation
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::external_gradient(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Process a morphological external gradient.
+**
+** Compute  the arithmetic  difference between  and the  dilatation of
+** input  using  se as  structural  element,  and  the original  image
+** input. Soille, p67.
+**
+** \\arg c Conversion functor.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 external_gradient(const convert::abstract::conversion<C, B>& c,
@@ -147,13 +175,40 @@
 }
 
 
-/*=processingoverload external_gradient
- * ns: morpho, morpho::fast
- * what: Morphological External Gradient.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret:oln_concrete_type(I)
-=*/
+/*!
+** \\brief Process morphological external gradient.
+**
+** \\param I Exact type of the input image.
+** \\param E Exact type of the structuring element.
+**
+** \\return The external gradient of the input.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/gradient.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   save(oln::morpho::internal_gradient(im1, oln::win_c8p()),
+**        IMG_OUT \"oln_morpho_external_gradient.pbm\");
+**   return  0;
+** }
+** \\encode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_external_gradient.png
+** \\image latex oln_morpho_external_gradient.png
+*/
 template<class I, class E>
 oln_concrete_type(I) 
   external_gradient(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/hit_or_miss.inc
--- olena/oln/morpho/hit_or_miss.inc Thu, 07 Aug 2003 02:37:23 +0200 burrus_n (oln/42_hit_or_mis 1.20 600)
+++ olena/oln/morpho/hit_or_miss.inc Thu, 11 Mar 2004 17:32:46 +0100 palma_g (oln/42_hit_or_mis 1.20 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2001, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -30,36 +30,54 @@
 // note that results depend on the type of image data when it is not bin.
 // you MUST be aware of it.
 
-/*=processing hit_or_miss
- * ns: morpho, morpho::fast
- * what: Hit_or_Miss Transform.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- * Compute the hit_or_miss transform of \\var{input} by the composite structural
- * element (\\var{se1}, \\var{se2}). Soille p.131.
- *
- * By definition \\var{se1} and \\var{se2} must have the same origin, and need to
- * be disjoint. This algorithm has been extended to every data types
- * (althought it is not increasing).  Beware the result depends upon the
- * image data type if it is not \\code{bin}.
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- * $ window2d mywin;
- * $ mywin
- * $  .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
- * $  .add(-2,-1).add(-2,0).add(-2,1)
- * $  .add(-1,0);
- * $ window2d mywin2 = - mywin;
- * $ save(morpho::fast::hit_or_miss(convert::bound<int_u8>(),
- * $                                im, mywin, mywin2), \"out.pgm\");
- * exh: convert/bound.hh
- * exi: object.pbm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Preform a 'hit or miss' transform.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** Compute the hit_or_miss transform of input by the composite structuring
+** element (se1, se2). Soille p.131.\\n
+**
+** By definition se1 and se2 must have the same origin, and need to
+** be disjoint. This algorithm has been extended to every data types
+** (although it is not increasing).  Beware the result depends upon the
+** image data type if it is not bin.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**   oln::save(oln::morpho::hit_or_miss(oln::convert::bound<ntg::int_u8>(), im1, mywin, mywin2),
+**                                       IMG_OUT \"oln_morpho_fast_hit_or_miss.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss.png
+** \\image latex oln_morpho_fast_hit_or_miss.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class C, class B, class I, class E1, class E2>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 hit_or_miss(const convert::abstract::conversion<C, B>& c,
@@ -81,13 +99,49 @@
 		    erosion(level::invert(input), se2));
 }
 
-/*=processingoverload hit_or_miss
- * ns: morpho, morpho::fast
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret:oln_concrete_type(I)
-=*/
+/*!
+** \\brief Preform a 'hit or miss' transform.
+**
+** \\param I Exact type of the input image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**   oln::save(oln::morpho::hit_or_miss(im1, mywin, mywin2),
+**                                      IMG_OUT \"oln_morpho_fast_hit_or_miss_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss_overload.png
+** \\image latex oln_morpho_fast_hit_or_miss_overload.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   hit_or_miss(const abstract::non_vectorial_image<I>& input,
@@ -103,37 +157,57 @@
 //
 ///////////////////////////////////
 
-/*=processing hit_or_miss_opening
- * ns: morpho, morpho::fast
- * what: Hit_or_Miss opening.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret:oln_concrete_type(I)
- * doc:
- *   Compute the hit_or_miss opening of \\var{input} by the composite structural
- * element (\\var{se1}, \\var{se2}). Soille p.134.
- *
- * By definition \\var{se1} and \\var{se2} must have the same origin, and need to
- * be disjoint. This algorithm has been extended to every data types
- * (althought it is not increasing).  Beware the result depends upon the
- * image data type if it is not \\code{bin}.
- * see: morpho::hit_or_miss
- * see: morpho::hit_or_miss_closing
- * see: morpho::hit_or_miss_closing_bg
- * see: morpho::hit_or_miss_opening_bg
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- *  window2d mywin;
- *  mywin
- *   .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
- *   .add(-2,-1).add(-2,0).add(-2,1)
- *   .add(-1,0);
- * window2d mywin2 = - mywin;
- * $ save(morpho::hit_or_miss_opening(im, mywin, mywin2), \"out.pbm\");
- * exi: object.pbm
- * exo: out.pbm
-=*/
+/*!
+** \\brief Perform an hit or miss opening.
+**
+** Compute the hit_or_miss opening of input by the composite structuring
+** element (se1, se2). Soille p.134.\\n
+**
+** By definition se1 and se2 must have the same origin, and need to
+** be disjoint. This algorithm has been extended to every data types
+** (althought it is not increasing).  Beware the result depends upon the
+** image data type if it is not bin.
+**
+** \\param I Exact type of the input image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**    oln::save(oln::morpho::hit_or_miss_opening(im1, mywin, mywin2),
+**                                       IMG_OUT \"oln_morpho_fast_hit_or_miss_opening.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss_opening.png
+** \\image latex oln_morpho_fast_hit_or_miss_opening.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   hit_or_miss_opening(const abstract::non_vectorial_image<I>& input,
@@ -145,38 +219,57 @@
   return dilation(hit_or_miss(input, se1, se2), -se1);
 }
 
-/*=processing hit_or_miss_opening_bg
- * ns: morpho, morpho::fast
- * what: Hit_or_Miss opening of background.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret:oln_concrete_type(I)
- * doc:
- *  Compute the hit_or_miss opening of the background of
- * \\var{input} by the composite structural
- * element (\\var{se1}, \\var{se2}). Soille p.135.
- *
- * By definition \\var{se1} and \\var{se2} must have the same origin, and need to
- * be disjoint. This algorithm has been extended to every data types
- * (althought it is not increasing).  Beware the result depends upon the
- * image data type if it is not \\code{bin}.
- * see: morpho::hit_or_miss
- * see: morpho::hit_or_miss_closing
- * see: morpho::hit_or_miss_closing_bg
- * see: morpho::hit_or_miss_opening
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- *  window2d mywin;
- *  mywin
- *   .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
- *   .add(-2,-1).add(-2,0).add(-2,1)
- *   .add(-1,0);
- * window2d mywin2 = - mywin;
- * $ save(morpho::hit_or_miss_opening_bg(im, mywin, mywin2), \"out.pbm\");
- * exi: object.pbm
- * exo: out.pbm
-=*/
+/*!
+** \\brief Perform an hit or miss opening of background.
+**
+**  Compute the hit_or_miss opening of  the background of input by the
+** composite structuring element (se1, se2). Soille p.135.\\n
+**
+** By definition se1 and se2 must have the same origin, and need to be
+** disjoint.  This algorithm  has been  extended to  every  data types
+** (although it  is not increasing).   Beware the result  depends upon
+** the image data type if it is not bin.
+**
+** \\param I Exact type of the input image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**   oln::save(oln::morpho::hit_or_miss_opening_bg(im1, mywin, mywin2),
+**                                       IMG_OUT \"oln_morpho_fast_hit_or_miss_opening_bg.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss_opening_bg.png
+** \\image latex oln_morpho_fast_hit_or_miss_opening_bg.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   hit_or_miss_opening_bg(const abstract::non_vectorial_image<I>& input,
@@ -192,39 +285,59 @@
 //
 ///////////////////////////////////
 
-/*=processing hit_or_miss_closing
- * ns: morpho, morpho::fast
- * what: Hit_or_Miss closing.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret:oln_concrete_type(I)
- * doc:
- *   Compute the hit_or_miss closing of \\var{input} by the composite structural
- * element (\\var{se1}, \\var{se2}). This is the dual transformation of hit-or-miss opening
- *  with respect to
- * set complementation. Soille p.135.
- *
- * By definition \\var{se1} and \\var{se2} must have the same origin, and need to
- * be disjoint. This algorithm has been extended to every data types
- * (althought it is not increasing).  Beware the result depends upon the
- * image data type if it is not \\code{bin}.
- * see: morpho::hit_or_miss
- * see: morpho::hit_or_miss_closing_bg
- * see: morpho::hit_or_miss_opening
- * see: morpho::hit_or_miss_opening_bg
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- *  window2d mywin;
- *  mywin
- *   .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
- *   .add(-2,-1).add(-2,0).add(-2,1)
- *   .add(-1,0);
- * window2d mywin2 = - mywin;
- * $ save(morpho::hit_or_miss_closing(im, mywin, mywin2), \"out.pbm\");
- * exi: object.pbm
- * exo: out.pbm
-=*/
+/*!
+** \\brief Perform an hit or miss closing.
+**
+**   Compute the hit_or_miss closing of input by the composite structuring
+** element (se1, se2). This is the dual transformation of hit-or-miss opening
+**  with respect to
+** set complementation. Soille p.135.\\n
+**
+** By definition se1 and se2 must have the same origin, and need to
+** be disjoint. This algorithm has been extended to every data types
+** (althought it is not increasing).  Beware the result depends upon the
+** image data type if it is not bin.
+**
+** \\param I Exact type of the input image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**   oln::save(oln::morpho::hit_or_miss_closing(im1, mywin, mywin2),
+**                                       IMG_OUT \"oln_morpho_fast_hit_or_miss_closing.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss_closing.png
+** \\image latex oln_morpho_fast_hit_or_miss_closing.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   hit_or_miss_closing(const abstract::non_vectorial_image<I>& input,
@@ -237,39 +350,59 @@
 					   se1, se2));
 }
 
-/*=processing hit_or_miss_closing_bg
- * ns: morpho, morpho::fast
- * what: Hit_or_Miss closing of background.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se1, IN, structural element
- * arg: const abstract::struct_elt<E>&, se2, IN, structural element
- * ret:oln_concrete_type(I)
- * doc:
- * Compute the hit_or_miss closing of the background of \\var{input} by the composite structural
- * element (\\var{se1}, \\var{se2}). This is the dual transformation of hit-or-miss opening
- *  with respect to
- * set complementation. Soille p.135.
- *
- * By definition \\var{se1} and \\var{se2} must have the same origin, and need to
- * be disjoint. This algorithm has been extended to every data types
- * (althought it is not increasing).  Beware the result depends upon the
- * image data type if it is not \\code{bin}.
- * see: morpho::hit_or_miss
- * see: morpho::hit_or_miss_closing
- * see: morpho::hit_or_miss_opening
- * see: morpho::hit_or_miss_opening_bg
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- *  window2d mywin;
- *  mywin
- *   .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
- *   .add(-2,-1).add(-2,0).add(-2,1)
- *   .add(-1,0);
- * window2d mywin2 = - mywin;
- * $ save(morpho::hit_or_miss_closing_bg(im, mywin, mywin2), \"out.pbm\");
- * exi: object.pbm
- * exo: out.pbm
-=*/
+/*!
+** \\brief Perform an hit or miss closing of background.
+**
+** Compute the hit_or_miss  closing of the background of  input by the
+** composite  structuring  element  (se1,   se2).  This  is  the  dual
+** transformation   of  hit-or-miss  opening   with  respect   to  set
+** complementation. Soille p.135.\\n
+**
+** By definition se1 and se2 must have the same origin, and need to
+** be disjoint. This algorithm has been extended to every data types
+** (althought it is not increasing).  Beware the result depends upon the
+** image data type if it is not bin.
+**
+** \\param I Exact type of the input image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/hit_or_miss.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::window2d mywin;
+**   mywin
+**    .add(-3,-2).add(-3,-1).add(-3,0).add(-3,1).add(-3,2)
+**    .add(-2,-1).add(-2,0).add(-2,1)
+**    .add(-1,0);
+**   oln::window2d mywin2 = - mywin;
+**
+**   oln::save(oln::morpho::hit_or_miss_closing_bg(im1, mywin, mywin2),
+**                                       IMG_OUT \"oln_morpho_fast_hit_or_miss_closing_bg.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_hit_or_miss_closing_bg.png
+** \\image latex oln_morpho_fast_hit_or_miss_closing_bg.png
+**
+** \\todo FIXME: Histogram problems (fast version do not work).
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
 hit_or_miss_closing_bg(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/laplacian.inc
--- olena/oln/morpho/laplacian.inc Thu, 07 Aug 2003 02:08:21 +0200 david (oln/41_laplacian. 1.13 600)
+++ olena/oln/morpho/laplacian.inc Fri, 12 Mar 2004 11:23:14 +0100 palma_g (oln/41_laplacian. 1.13 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2001  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -26,25 +26,40 @@
 // reasons why the executable file might be covered by the GNU General
 // Public License.
 
-/*=processing laplacian
- * ns: morpho, morpho::fast
- * what: Laplacian.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute the laplacian of \\var{input} using \\var{se}
- *   as structural element.
- * see: morpho::dilation
- * see: morpho::erosion
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::laplacian(convert::bound<int_u8>(), im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
- * exh: convert/bound.hh
-=*/
+/*!
+** \\brief Compute the laplacian of an image.
+**
+** Compute the laplacian of input using se as structural element.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/laplacian.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::laplacian(oln::convert::bound<ntg::int_u8>(),
+**                                          im1,
+**                                          oln::win_c8p()),
+**                                          IMG_OUT \"oln_morpho_fast_laplacian.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_laplacian.png
+** \\image latex oln_morpho_fast_laplacian.png
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 laplacian(const convert::abstract::conversion<C, B>& c,
@@ -56,13 +71,39 @@
 		      arith::minus(input, erosion(input, se)));
 }
 
-/*=processingoverload laplacian
- * ns: morpho, morpho::fast
- * what: Laplacian.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I,oln_value_type(I)::slarger_t>::ret
-=*/
+/*!
+** \\brief Compute the laplacian of an image.
+**
+** Compute the laplacian of input using se as structural element.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/laplacian.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::laplacian(oln::convert::bound<ntg::int_u8>(), im1, oln::win_c8p()),
+**                                          IMG_OUT \"oln_morpho_fast_laplacian_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_laplacian_overload.png
+** \\image latex oln_morpho_fast_laplacian_overload.png
+**
+** \\todo FIXME: Call the good laplacian, and correct slarger_t type.
+*/
 template<class I, class E>
 typename mute<I,oln_value_type(I)::slarger_t>::ret
 laplacian(const abstract::non_vectorial_image<I>& input, 
Index: olena/oln/morpho/minmax.hh
--- olena/oln/morpho/minmax.hh Thu, 31 Jul 2003 18:08:39 +0200 burrus_n (oln/b/0_minmax.hh 1.5 600)
+++ olena/oln/morpho/minmax.hh Fri, 12 Mar 2004 13:19:34 +0100 palma_g (oln/b/0_minmax.hh 1.5 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -34,20 +34,20 @@
 namespace oln {
   namespace morpho {
 
-    /*
-      Before olena v0.6, bin type was represented by \"true\" and
-      \"false\", so it did not make sense to implement a min and max for
-      it. However, morphological operatators defined on binary image
-      usually needs min and max operators, this is why it was previouly
-      implemented here.
-
-      But since v0.6 and higher, bin type is represented by '0' and
-      '1', so it has min and max operators. Thus arith::min and
-      arith::max should be used instead of obsolete these morpho::min
-      and morpho::max.
-      
-      These operators are kept here for compatibility with older
-      versions.
+    /*!
+    **  Before olena v0.6, bin type was represented by \"true\" and
+    **  \"false\", so it did not make sense to implement a min and max for
+    **  it. However, morphological operatators defined on binary image
+    **  usually needs min and max operators, this is why it was previouly
+    **  implemented here.\\n
+    **
+    **  But since v0.6 and higher, bin type is represented by '0' and
+    **  '1', so it has min and max operators. Thus arith::min and
+    **  arith::max should be used instead of obsolete these morpho::min
+    **  and morpho::max.\\n
+    **
+    **  These operators are kept here for compatibility with older
+    **  versions.
     */
 
     using arith::min;
Index: olena/oln/morpho/opening.inc
--- olena/oln/morpho/opening.inc Thu, 07 Aug 2003 02:37:23 +0200 burrus_n (oln/40_opening.in 1.13 600)
+++ olena/oln/morpho/opening.inc Thu, 11 Mar 2004 19:29:17 +0100 palma_g (oln/40_opening.in 1.13 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2001, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -26,24 +26,43 @@
 // reasons why the executable file might be covered by the GNU General
 // Public License.
 
-/*=processing opening
- * ns: morpho, morpho::fast
- * what: Morphological opening.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret:oln_concrete_type(I)
- * doc:
- *   Compute the morphological opening of \\var{input} using \\var{se}
- *   as structural element.
- * see: morpho::erosion
- * see: morpho::dilation
- * see: morpho::closing
- * ex:
- * $ image2d<ntg::bin> im = load(\"object.pbm\");
- * $ save(morpho::opening(im, win_c8p()), \"out.pbm\");
- * exi: object.pbm
- * exo: out.pbm
-=*/
+/*!
+** \\brief Perform a morphological opening.
+**
+**   Compute  the   morphological  opening   of  input  using   se  as
+**   structuring element.
+**
+** \\param I Exact type of the input image.
+** \\param E Exact type of the structuring element.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/opening.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::bin>	im_type;
+**
+**   im_type	im(oln::load(IMG_IN \"object.pbm\"));
+**
+**   oln::save(oln::morpho::opening(im, oln::win_c8p()),
+**                                       IMG_OUT \"oln_morpho_fast_opening.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html object.png
+** \\image latex object.png
+** =>
+** \\image html oln_morpho_fast_opening.png
+** \\image latex oln_morpho_fast_opening.png
+**
+** \\todo FIXME: Histogram problems (fast version do not compile).
+*/
 template<class I, class E>
 oln_concrete_type(I) 
 opening(const abstract::non_vectorial_image<I>& input, 
Index: olena/oln/morpho/reconstruction.hh
--- olena/oln/morpho/reconstruction.hh Wed, 08 Oct 2003 23:36:51 +0200 burrus_n (oln/35_reconstruc 1.13.1.11 600)
+++ olena/oln/morpho/reconstruction.hh Thu, 11 Mar 2004 21:01:45 +0100 palma_g (oln/35_reconstruc 1.13.1.11 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -43,27 +43,54 @@
 namespace oln {
   namespace morpho {
     namespace sure {
-      /*=processing sure_geodesic_reconstruction_dilation
-       * ns: morpho
-       * what: Geodesic reconstruction by dilation.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by dilation of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160. This is the simplest algorithm:
-       * iteration is performed until stability.
-       * see: morpho::simple_geodesic_dilation
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::sure_geodesic_reconstruction_dilation(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+      /*!
+      ** \\brief Perform a geodesic reconstruction dilation.
+      **
+      ** Compute the reconstruction by dilation of marker with respect
+      ** to   the   mask   mask   image  using   se   as   structuring
+      ** element.  Soille  p.160.  This  is  the  simplest  algorithm:
+      ** iteration is performed until stability.
+      **
+      ** \\warning This version is slow, since it is a sure one.
+      **
+      ** \\pre Mask must be greater or equal than marker.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic dilation.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::sure::geodesic_reconstruction_dilation(im2,
+      **                                                                 im1,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_sure_geodesic_reconstruction_dilation.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sure_geodesic_reconstruction_dilation.png
+      ** \\image latex oln_morpho_sure_geodesic_reconstruction_dilation.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_dilation(const abstract::non_vectorial_image<I1> & marker,
@@ -88,30 +115,54 @@
 
 
     namespace sequential {
-      /*=processing sequential_geodesic_reconstruction_dilation
-       * ns: morpho
-       * what: Geodesic reconstruction by dilation.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by dilation of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160. The algorithm used is the
-       * one defined as sequential
-       * in Vincent(1993), Morphological grayscale reconstruction in
-       *  image analysis: applications and efficient algorithms, itip, 2(2),
-       * 176--201.
-       * see: morpho::simple_geodesic_dilation
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::sequential_geodesic_reconstruction_dilation(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+      /*!
+      ** \\brief Perform a geodesic reconstruction dilation.
+      **
+      ** Compute the reconstruction by dilation of marker with respect
+      ** to  the mask  image using  se as  structuring  element. Soille
+      ** p.160. The algorithm used is the one defined as sequential in
+      ** Vincent(1993),  Morphological   grayscale  reconstruction  in
+      ** image analysis: applications  and efficient algorithms, itip,
+      ** 2(2), 176--201.
+      **
+      ** \\pre Mask must be greater or equal than marker.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic dilation.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::sequential::geodesic_reconstruction_dilation(im2,
+      **                                                                 im1,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_sequential_geodesic_reconstruction_dilation.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sequential_geodesic_reconstruction_dilation.png
+      ** \\image latex oln_morpho_sequential_geodesic_reconstruction_dilation.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_dilation(const abstract::non_vectorial_image<I1> & marker,
@@ -152,6 +203,14 @@
 
       namespace internal {
 
+	/*!
+	** \\brief Check if it exists initialization for dilation.
+	**
+	** \\arg p Point to consider.
+	** \\arg marker Image to work on.
+	** \\arg mask Image used as mask.
+	** \\arg Ng Neighborhood to use.
+	*/
 	template<class P, class I1, class I2, class E> inline
 	static bool 
 	exist_init_dilation(const abstract::point<P>& p,
@@ -172,30 +231,54 @@
 
       } //internal
 
-      /*=processing hybrid_geodesic_reconstruction_dilation
-       * ns: morpho
-       * what: Geodesic reconstruction by dilation.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by dilation of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160. The algorithm used is the
-       * one defined as hybrid
-       * in Vincent(1993), Morphological grayscale reconstruction in
-       *  image analysis: applications and efficient algorithms, itip, 2(2),
-       * 176--201.
-       * see: morpho::simple_geodesic_dilation
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::hybrid_geodesic_reconstruction_dilation(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+      /*!
+      ** \\brief Perform a geodesic reconstruction dilation.
+      **
+      **  Compute  the  reconstruction  by  dilation  of  marker  with
+      ** respect   to  the   mask  image   using  se   as  structuring
+      ** element. Soille p.160. The  algorithm used is the one defined
+      ** as   hybrid   in   Vincent(1993),   Morphological   grayscale
+      ** reconstruction in image  analysis: applications and efficient
+      ** algorithms, itip, 2(2), 176--201.
+      **
+      ** \\pre Mask must be greater or equal than marker.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic dilation.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::hybrid::geodesic_reconstruction_dilation(im2,
+      **                                                                 im1,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_hybrid_geodesic_reconstruction_dilation.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_hybrid_geodesic_reconstruction_dilation.png
+      ** \\image latex oln_morpho_hybrid_geodesic_reconstruction_dilation.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_dilation(const abstract::non_vectorial_image<I1> & marker,
@@ -252,27 +335,55 @@
     //GEODESIC RECONSTRUCTION EROSION
 
     namespace sure {
-      /*=processing sure_geodesic_reconstruction_erosion
-       * ns: morpho
-       * what: Geodesic reconstruction by erosion.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by erosion of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160. This is the simplest algorithm :
-       * iteration is performed until stability.
-       * see: morpho::simple_geodesic_erosion
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::sure_geodesic_reconstruction_erosion(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+
+      /*!
+      ** \\brief Perform a geodesic reconstruction erosion.
+      **
+      **  Compute the reconstruction by erosion of marker with respect
+      ** to  the mask image  using se  as structuring  element. Soille
+      ** p.160. This is the simplest algorithm: iteration is performed
+      ** until stability.
+      **
+      ** \\warning This version is slow, since it is a sure one.
+      **
+      ** \\pre Marker must be greater or equal than mask.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic erosion.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::sure::geodesic_reconstruction_erosion(im1,
+      **                                                                 im2,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_sure_geodesic_reconstruction_erosion.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sure_geodesic_reconstruction_erosion.png
+      ** \\image latex oln_morpho_sure_geodesic_reconstruction_erosion.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_erosion(const abstract::non_vectorial_image<I1> & marker,
@@ -297,30 +408,55 @@
 
 
     namespace sequential {
-      /*=processing sequential_geodesic_reconstruction_erosion
-       * ns: morpho
-       * what: Geodesic reconstruction by erosion.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by erosion of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160.  The algorithm used is the
-       * one defined as sequential
-       * in Vincent(1993), Morphological grayscale reconstruction in
-       *  image analysis: applications and efficient algorithms, itip, 2(2),
-       * 176--201.
-       * see: morpho::simple_geodesic_erosion
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::sequential_geodesic_reconstruction_erosion(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
+
+      /*!
+      ** \\brief Perform a geodesic reconstruction erosion.
+      **
+      **  Compute the reconstruction by erosion of marker with respect
+      ** to  the mask image  using se  as structuring  element. Soille
+      ** p.160.  The  algorithm used is the one  defined as sequential
+      ** in  Vincent(1993), Morphological grayscale  reconstruction in
+      ** image analysis: applications  and efficient algorithms, itip,
+      ** 2(2), 176--201.
+      **
+      ** \\pre Marker must be greater or equal than mask.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic erosion.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::sequential::geodesic_reconstruction_erosion(im1,
+      **                                                                 im2,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_sequential_geodesic_reconstruction_erosion.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_sequential_geodesic_reconstruction_erosion.png
+      ** \\image latex oln_morpho_sequential_geodesic_reconstruction_erosion.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_erosion(const abstract::non_vectorial_image<I1>& marker,
@@ -358,6 +494,14 @@
 
     namespace hybrid {
       namespace internal {
+	/*!
+	** \\brief Check if it exists initialization for erosion.
+	**
+	** \\arg p Point to consider.
+	** \\arg marker Image to work on.
+	** \\arg mask Image used as mask.
+	** \\arg Ng Neighborhood to use.
+	*/
 	template<class P, class I1, class I2, class E> inline
 	static bool 
 	exist_init_erosion(const abstract::point<P>& p,
@@ -377,31 +521,54 @@
 	}
       } // internal
 
-      /*=processing hybrid_geodesic_reconstruction_erosion
-       * ns: morpho
-       * what: Geodesic reconstruction by erosion.
-       * arg: const abstract::non_vectorial_image<I1>&, marker, IN, marker image
-       * arg: const abstract::non_vectorial_image<I2>&, mask, IN, mask image
-       * arg: const abstract::struct_elt<E>&, se, IN, structural element
-       * ret:oln_concrete_type(I1)
-       * doc:
-       *  Compute the reconstruction by erosion of \\var{marker} with respect
-       * to the mask \\var{mask} image using \\var{se}
-       *   as structural element. Soille p.160.  The algorithm used is the
-       * one defined as hybrid
-       * in Vincent(1993), Morphological grayscale reconstruction in
-       *  image analysis: applications and efficient algorithms, itip, 2(2),
-       * 176--201.
-       * see: morpho::simple_geodesic_erosion
-       * ex:
-       * $ image2d<int_u8> light = load(\"light.pgm\");
-       * $ image2d<int_u8> dark = load(\"dark.pgm\");
-       * $ save(morpho::sequential_geodesic_reconstruction_erosion(light, dark, win_c8p()), \"out.pgm\");
-       * exi: light.pgm dark.pgm
-       * exo: out.pgm
-       * wontcompile: fixme
-       =*/
-
+      /*!
+      ** \\brief Perform a geodesic reconstruction erosion.
+      **
+      **  Compute the reconstruction by erosion of marker with respect
+      ** to   the   mask   mask   image  using   se   as   structuring
+      ** element. Soille p.160.  The algorithm used is the one defined
+      ** as   hybrid   in   Vincent(1993),   Morphological   grayscale
+      ** reconstruction in image  analysis: applications and efficient
+      ** algorithms, itip, 2(2), 176--201.
+      **
+      ** \\pre Marker must be greater or equal than mask.
+      **
+      ** \\param I1 Exact type of image marker.
+      ** \\param I2 Exact type of image mask.
+      ** \\param N Exact type of neighborhood.
+      **
+      ** \\arg marker Image to work on.
+      ** \\arg mask Image used for geodesic erosion.
+      ** \\arg Ng Neighborhood to use.
+      **
+      ** \\code
+      ** #include <oln/basics2d.hh>
+      ** #include <oln/morpho/opening.hh>
+      ** #include <oln/morpho/reconstruction.hh>
+      ** #include <oln/level/compare.hh>
+      ** #include <ntg/all.hh>
+      ** int main()
+      ** {
+      **   typedef oln::image2d<ntg::int_u8>	im_type;
+      **
+      **   im_type	im1(oln::load(IMG_IN \"lena128.pgm\"));
+      **   im_type	im2(oln::morpho::opening(im1, oln::win_c4p()));
+      **
+      **   oln::save(oln::morpho::hybrid::geodesic_reconstruction_erosion(im1,
+      **                                                                 im2,
+      **                                                                 oln::neighb_c4()),
+      **             IMG_OUT \"oln_morpho_hybrid_geodesic_reconstruction_erosion.pbm\");
+      **   return  0;
+      ** }
+      ** \\endcode
+      **
+      ** \\image html lena128.png
+      ** \\image latex lena128.png
+      ** =>
+      ** \\image html oln_morpho_hybrid_geodesic_reconstruction_erosion.png
+      ** \\image latex oln_morpho_hybrid_geodesic_reconstruction_erosion.png
+      **
+      */
       template<class I1, class I2, class N>
       oln_concrete_type(I1)
 	geodesic_reconstruction_erosion(const abstract::non_vectorial_image<I1> & marker,
Index: olena/oln/morpho/splitse.hh
--- olena/oln/morpho/splitse.hh Thu, 07 Aug 2003 02:08:21 +0200 david (oln/34_splitse.hh 1.7 600)
+++ olena/oln/morpho/splitse.hh Thu, 11 Mar 2004 21:38:23 +0100 palma_g (oln/34_splitse.hh 1.7 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -33,6 +33,18 @@
 namespace oln {
   namespace morpho {
 
+    /*!
+    ** \\brief Get a sub part of a structuring element.
+    **
+    ** \\param E Exact type of the structuring element.
+    **
+    ** \\arg se The structuring element.
+    **
+    ** A point p take part of the new structuring element if it exists
+    ** a i  that belongs to [[0..dim-1]] like  p(i) < 0 and  for all j
+    ** that belongs to [[0..i-1]] p(j) = 0.
+    **
+    */
     template<class E>
     mlc_exact_type(E) 
       get_plus_se_only(const abstract::struct_elt<E>& se)
@@ -54,6 +66,19 @@
       return out;
     }
 
+    /*!
+    ** \\brief Get a sub part of a structuring element.
+    **
+    ** \\param E Exact type of the structuring element.
+    **
+    ** \\arg se The structuring element.
+    **
+    ** A point p take part of the new structuring element if it exists
+    ** a i  that belongs to [[0..dim-1]] like  p(i) < 0 and  for all j
+    ** that  belongs to  [[0..i-1]] p(j)  =  0 or  if for  all i  that
+    ** belongs to [[0..dim-1]] p(i) = 0.
+    **
+    */
     template<class E>
     mlc_exact_type(E) 
       get_plus_se_p(const abstract::struct_elt<E>& se)
@@ -78,6 +103,18 @@
       return out;
     }
 
+    /*!
+    ** \\brief Get a sub part of a structuring element.
+    **
+    ** \\param E Exact type of the structuring element.
+    **
+    ** \\arg se The structuring element.
+    **
+    ** A point p take part of the new structuring element if it exists
+    ** a i  that belongs to [[0..dim-1]] like  p(i) > 0 and  for all j
+    ** that  belongs to  [[0..i-1]] p(j)  =  0.
+    **
+    */
     template<class E>
     mlc_exact_type(E) 
       get_minus_se_only(const abstract::struct_elt<E>& se)
@@ -99,6 +136,19 @@
       return out;
     }
 
+    /*!
+    ** \\brief Get a sub part of a structuring element.
+    **
+    ** \\param E Exact type of the structuring element.
+    **
+    ** \\arg se The structuring element.
+    **
+    ** A point p take part of the new structuring element if it exists
+    ** a i  that belongs to [[0..dim-1]] like  p(i) > 0 and  for all j
+    ** that  belongs to  [[0..i-1]] p(j)  =  0 or  if for  all i  that
+    ** belongs to [[0..dim-1]] p(i) = 0.
+    **
+    */
     template<class E>
     mlc_exact_type(E) 
       get_minus_se_p(const abstract::struct_elt<E>& se)
Index: olena/oln/morpho/stat.hh
--- olena/oln/morpho/stat.hh Thu, 07 Aug 2003 02:37:23 +0200 burrus_n (oln/50_stat.hh 1.8.1.11 600)
+++ olena/oln/morpho/stat.hh Fri, 12 Mar 2004 11:04:47 +0100 palma_g (oln/50_stat.hh 1.8.1.11 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -37,12 +37,29 @@
 
     namespace internal {
 
-      /* We need to use this inner definition in order to specialize
-	 max and min on binary images.  */
-
+      /*!
+      ** \\brief Min and Max on a structuring element.
+      **
+      ** We need to use this inner definition in order to specialize
+      ** max and min on binary images.
+      **
+      ** \\param I Image exact type.
+      ** \\param E Structuring element type.
+      ** \\param V Associated value type.
+      */
       template <class I, class E, class V =oln_value_type(I)>
       struct stat_ 
       {
+	/*!
+	** \\brief Maximum of a structuring element.
+	**
+	** Look for  the maximum in the structuring  element se disposed
+	** on the image input, at the point p.
+	**
+	** \\arg input Input image.
+	** \\arg p Point of the image to move the structuring element on.
+	** \\arg se The structuring element to use.
+	*/
 	static V
 	max(const I& input, const oln_point_type(I)& p, const E& se)
 	{
@@ -57,6 +74,16 @@
 	  return val;
 	}
 
+	/*!
+	** \\brief Minimum of a structuring element.
+	**
+	** Look for  the minimum in the structuring  element se disposed
+	** on the image input, at the point p.
+	**
+	** \\arg input Input image.
+	** \\arg p Point of the image to move the structuring element on.
+	** \\arg se The structuring element to use.
+	*/
 	static V
 	min(const I& input, const oln_point_type(I)& p, const E& se)
 	{
@@ -103,6 +130,19 @@
 
     } // internal
 
+    /*!
+    ** \\brief Maximum of a structuring element.
+    **
+    ** Look for  the maximum in the structuring  element se disposed
+    ** on the image input, at the point p.
+    **
+    ** \\param I Image exact type.
+    ** \\param E Structuring element type.
+    **
+    ** \\arg input Input image.
+    ** \\arg p Point of the image to move the structuring element on.
+    ** \\arg se The structuring element to use.
+    */
     template<class I, class E>
     oln_value_type(I) 
     max(const abstract::non_vectorial_image<I>& input,
@@ -113,6 +153,18 @@
       return internal::stat_<I, E>::max(input.exact(), p, se.exact());
     }
     
+    /*! ** \\brief Minimum of a structuring element.
+    **
+    ** Look for  the minimum in the structuring  element se disposed
+    ** on the image input, at the point p.
+    **
+    ** \\param I Image exact type.
+    ** \\param E Structuring element type.
+    **
+    ** \\arg input Input image.
+    ** \\arg p Point of the image to move the structuring element on.
+    ** \\arg se The structuring element to use.
+    */
     template<class I, class E>
     oln_value_type(I) 
     min(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/thickening.inc
--- olena/oln/morpho/thickening.inc Thu, 07 Aug 2003 02:08:21 +0200 david (oln/e/28_thickening 1.10 600)
+++ olena/oln/morpho/thickening.inc Fri, 12 Mar 2004 11:12:52 +0100 palma_g (oln/e/28_thickening 1.10 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2002  EPITA Research and Development Laboratory
+// Copyright (C) 2002, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -26,7 +26,43 @@
 // reasons why the executable file might be covered by the GNU General
 // Public License.
 
-
+/*!
+** \\brief Thicken an image.
+**
+** \\param I Exact type of the image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/thickening.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::thickening(im1,
+**                                          oln::win_c8p(),
+**                                          oln::win_c8p()),
+**                                          IMG_OUT \"oln_morpho_fast_thickening.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_thickening.png
+** \\image latex oln_morpho_fast_thickening.png
+**
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   thickening(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/thinning.inc
--- olena/oln/morpho/thinning.inc Thu, 07 Aug 2003 02:08:21 +0200 david (oln/e/26_thinning.i 1.11 600)
+++ olena/oln/morpho/thinning.inc Fri, 12 Mar 2004 11:15:59 +0100 palma_g (oln/e/26_thinning.i 1.11 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -26,7 +26,43 @@
 // reasons why the executable file might be covered by the GNU General
 // Public License.
 
-
+/*!
+** \\brief Thin an image.
+**
+** \\param I Exact type of the image.
+** \\param E1 Exact type of the first structuring element.
+** \\param E2 Exact type of the second structuring element.
+**
+** \\arg input Image to process.
+** \\arg se1 First structuring element.
+** \\arg se2 Second structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/thinning.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::thinning(im1,
+**                                          oln::win_c8p(),
+**                                          oln::win_c8p()),
+**                                          IMG_OUT \"oln_morpho_fast_thinning.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_thinning.png
+** \\image latex oln_morpho_fast_thinning.png
+**
+*/
 template<class I, class E1, class E2>
 oln_concrete_type(I) 
   thinning(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/top_hat.inc
--- olena/oln/morpho/top_hat.inc Thu, 07 Aug 2003 02:08:21 +0200 david (oln/39_top_hat.in 1.13 600)
+++ olena/oln/morpho/top_hat.inc Fri, 12 Mar 2004 12:08:33 +0100 palma_g (oln/39_top_hat.in 1.13 640)
@@ -1,5 +1,5 @@
 // -*- c++ -*-
-// Copyright (C) 2002  EPITA Research and Development Laboratory
+// Copyright (C) 2002, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -27,24 +27,41 @@
 // Public License.
 
 
-
-/*=processing white_top_hat
- * ns: morpho, morpho::fast
- * what: White top hat.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute white top hat of \\var{input} using \\var{se}
- *   as structural element. Soille p.105.
- * see: morpho::opening
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::white_top_hat(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Compute the white top hat of an image.
+**
+** Compute   white  top   hat  of   input  using   se   as  structuring
+** element. Soille p.105.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::white_top_hat(oln::convert::bound<ntg::int_u8>(),
+**                                             im1,
+**                                             oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_white_top_hat.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_white_top_hat.png
+** \\image latex oln_morpho_fast_white_top_hat.png
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 white_top_hat(const convert::abstract::conversion<C, B>& c,
@@ -54,13 +71,39 @@
   return arith::minus(c, input, opening(input, se));
 }
 
-/*=processingoverload white_top_hat
- * ns: morpho, morpho::fast
- * what: White top hat.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret:oln_concrete_type(I)
-=*/
+/*!
+** \\brief Compute the white top hat of an image.
+**
+** \\param I Exact type of the image.
+** \\param E Exact type of the structuring element.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::white_top_hat(im1,
+**                                              oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_white_top_hat_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_white_top_hat_overload.png
+** \\image latex oln_morpho_fast_white_top_hat_overload.png
+*/
 template<class I, class E>
 oln_concrete_type(I) 
   white_top_hat(const abstract::non_vectorial_image<I>& input,
@@ -72,23 +115,41 @@
 
 // black top-hat
 
-/*=processing black_top_hat
- * ns: morpho, morpho::fast
- * what: Black top hat.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute black top hat of \\var{input} using \\var{se}
- *   as structural element. Soille p.105.
- * see: morpho::closing
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::black_top_hat(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
+/*!
+** \\brief Compute the black top hat of an image.
+**
+** Compute   black  top   hat  of   input  using   se   as  structuring
+** element. Soille p.105.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::black_top_hat(oln::convert::bound<ntg::int_u8>(),
+**                                             im1,
+**                                             oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_black_top_hat.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_black_top_hat.png
+** \\image latex oln_morpho_fast_black_top_hat.png
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 black_top_hat(const convert::abstract::conversion<C, B>& c,
@@ -99,13 +160,39 @@
 }
 
 
-/*=processingoverload balck_top_hat
- * ns: morpho, morpho::fast
- * what: Black top hat.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
-=*/
+/*!
+** \\brief Compute the black top hat of an image.
+**
+** \\param I Exact type of the image.
+** \\param E Exact type of the structuring element.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::black_top_hat(im1,
+**                                              oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_black_top_hat_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_black_top_hat_overload.png
+** \\image latex oln_morpho_fast_black_top_hat_overload.png
+*/
 template<class I, class E>
 oln_concrete_type(I) 
   black_top_hat(const abstract::non_vectorial_image<I>& input,
@@ -120,25 +207,42 @@
 //  = (input - opening) + (closing - input)
 //  = closing - opening
 
-/*=processing self_complementary_top_hat
- * ns: morpho, morpho::fast
- * what: Self complementary top hat.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Compute self complementary top hat of \\var{input} using \\var{se}
- *   as structural element. Soille p.106.
- * see: morpho::closing
- * see: morpho::opening
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::self_complementary_top_hat(im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
-=*/
 
+/*!
+** \\brief Compute the self complementary top hat of an image.
+**
+** Compute self complementary top hat of input using se as structuring
+** element. Soille p.106.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::self_complementary_top_hat(oln::convert::bound<ntg::int_u8>(),
+**                                                           im1,
+**                                                           oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_self_complementary_top_hat.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_self_complementary_top_hat.png
+** \\image latex oln_morpho_fast_self_complementary_top_hat.png
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 self_complementary_top_hat(const convert::abstract::conversion<C, B>& c,
@@ -148,13 +252,38 @@
   return arith::minus(c, closing(input, se), opening(input, se));
 }
 
-/*=processingoverload self_complementary_top_hat
- * ns: morpho, morpho::fast
- * what: Self complementary top hat.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
-=*/
+/*!
+** \\brief Compute the self complementary top hat of an image.
+**
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::self_complementary_top_hat(im1,
+**                                                           oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_self_complementary_top_hat_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_self_complementary_top_hat_overload.png
+** \\image latex oln_morpho_fast_self_complementary_top_hat_overload.png
+*/
 template<class I, class E>
 oln_concrete_type(I) 
 self_complementary_top_hat(const abstract::non_vectorial_image<I>& input,
@@ -166,28 +295,43 @@
 
 // top-hat contrast operator
 
-/*=processing top_hat_contrast_op
- * ns: morpho, morpho::fast
- * what: Top hat contrastor operator.
- * arg: const convert::abstract::conversion<C, B>&, c, IN, conversion object
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
- * doc:
- *   Enhance contrast \\var{input} by adding the white top hat, then
- * substracting the black top hat to \\var{input}. Top hats are computed using
- * \\var{se} as structural element. Soille p.109.
- * see: morpho::white_top_hat
- * see: morpho::black_top_hat
- * ex:
- * $ image2d<int_u8> im = load(\"lena256.pgm\");
- * $ save(morpho::top_hat_contrast_op(convert::bound<int_u8>(),
- *                                    im, win_c8p()), \"out.pgm\");
- * exi: lena256.pgm
- * exo: out.pgm
- * exh: convert/bound.hh
-=*/
 
+/*!
+** \\brief Top hat contrast operator.
+**
+** Enhance  contrast   input  by  adding  the  white   top  hat,  then
+** subtracting the black top hat to input. Top hats are computed using
+** se as structuring element. Soille p.109.
+**
+** \\arg c Conversion object.
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   oln::save(oln::morpho::fast::top_hat_contrast_op(oln::convert::bound<ntg::int_u8>(),
+**                                                           im1,
+**                                                           oln::win_c8p()),
+**             IMG_OUT \"oln_morpho_fast_top_hat_contrast_op.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_top_hat_contrast_op.png
+** \\image latex oln_morpho_fast_top_hat_contrast_op.png
+*/
 template<class C, class B, class I, class E>
 typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
 top_hat_contrast_op(const convert::abstract::conversion<C, B>& c,
@@ -200,13 +344,44 @@
 				  black_top_hat(input, se)));
 }
 
-/*=processingoverload top_hat_contrast_op
- * ns: morpho, morpho::fast
- * what: Top hat contrastor operator.
- * arg: const abstract::non_vectorial_image<I>&, input, IN, input image
- * arg: const abstract::struct_elt<E>&, se, IN, structural element
- * ret: typename mute<I, typename convoutput<C, B,oln_value_type(I)>::ret>::ret
-=*/
+
+/*!
+** \\brief Top hat contrast operator.
+**
+** Enhance  contrast   input  by  adding  the  white   top  hat,  then
+** subtracting the black top hat to input. Top hats are computed using
+** se as structuring element. Soille p.109.
+**
+** \\arg input Image to process.
+** \\arg se Structuring element.
+**
+** \\code
+** #include <oln/basics2d.hh>
+** #include <oln/morpho/top_hat.hh>
+** #include <oln/level/compare.hh>
+** #include <ntg/all.hh>
+** int main()
+** {
+**   typedef oln::image2d<ntg::int_u8>	im_type;
+**
+**   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+**
+**   //oln::save(oln::morpho::fast::top_hat_contrast_op(im1,
+**   //                                                 oln::win_c8p()),
+**   //          IMG_OUT \"oln_morpho_fast_top_hat_contrast_op_overload.pbm\");
+**   oln::save(im1, IMG_OUT \"oln_morpho_fast_top_hat_contrast_op_overload.pbm\");
+**   return  0;
+** }
+** \\endcode
+**
+** \\image html lena256.png
+** \\image latex lena256.png
+** =>
+** \\image html oln_morpho_fast_top_hat_contrast_op_overload.png
+** \\image latex oln_morpho_fast_top_hat_contrast_op_overload.png
+**
+** \\todo FIXME: Seems not to work with convert::force converter.
+*/
 template<class I, class E>
 oln_concrete_type(I) 
 top_hat_contrast_op(const abstract::non_vectorial_image<I>& input,
Index: olena/oln/morpho/watershed.hh
--- olena/oln/morpho/watershed.hh Sat, 27 Sep 2003 18:30:39 +0200 burrus_n (oln/48_watershed. 1.11 600)
+++ olena/oln/morpho/watershed.hh Fri, 12 Mar 2004 12:55:40 +0100 palma_g (oln/48_watershed. 1.11 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -34,95 +34,157 @@
 
   namespace morpho {
 
-    /*=processing watershed_seg
-     * what: Segmented Watershed.
-     * ns: morpho
-     * tpl: class, DestValue, type of output labels
-     * arg: const abstract::non_vectorial_image<I>&, im, IN, image of levels
-     * arg: const abstract::neighborhood<N>&, ng, IN, neighborhood to consider
-     * ret: typename mute<I, DestValue>::ret
-     * doc:
-     *   Compute the segmented watershed for image \\var{im} using
-     *   neighborhood \\var{ng}.
-     *
-     *   \\code{watershed_seg} creates an ouput image whose values have
-     *   type \\var{DestValue} (which should be discrete).  In this output
-     *   image, \\code{DestValue::max()} indicates a watershed, and all
-     *   basins are labeled using values from \\code{DestValue::min()} to
-     *   \\code{DestValue::max() - 4} (the remaining values are used internally
-     *   by the algorithm).
-     *
-     *   When there are more basins than \\code{DestValue} can hold,
-     *   wrapping occurs (i.e., the same label is used for several
-     *   basin).
-     * ref:
-     *   This is based on the original algorithm
-     *   presented by Vincent and Soille. (FIXME: ref?)
-    =*/
+    /*!
+    ** \\brief Segmented watershed.
+    **
+    **   Compute   the  segmented   watershed  for   image   im  using
+    **   neighborhood ng.\\n
+    **
+    **   watershed_seg creates  an ouput image whose  values have type
+    **   DestValue (which should be  discrete).  In this output image,
+    **   DestValue::max()  indicates a watershed,  and all  basins are
+    **   labeled    using     values    from    DestValue::min()    to
+    **   DestValue::max()   -  4  (the   remaining  values   are  used
+    **   internally by the algorithm).\\n
+    **
+    **   When there are more  basins than DestValue can hold, wrapping
+    **   occurs (i.e., the same label is used for several basin).
+    **
+    ** \\ref  This is  based  on the  original  algorithm presented  by
+    ** Vincent and Soille. (FIXME: ref?)
+    **
+    ** \\param DestValue Type of the data in output image.
+    ** \\param I Exact type of the image.
+    ** \\param N Exact type of the neighborhood.
+    **
+    ** \\arg im_i Image of levels.
+    ** \\arg Ng Neighborhood to consider.
+    **
+    ** \\pre DestValue should be large enough.
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/watershed.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::int_u8>	im_type;
+    **
+    **   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+    **
+    **   oln::save(oln::morpho::watershed_seg<ntg::int_u16>(im1,
+    **                                                      oln::neighb_c4()),
+    **             IMG_OUT \"oln_morpho_watershed_seg.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html lena256.png
+    ** \\image latex lena256.png
+    ** =>
+    ** \\image html oln_morpho_watershed_seg.png
+    ** \\image latex oln_morpho_watershed_seg.png
+    **
+    ** \\todo Find a more pertinent example.
+    */
     template<class DestValue, class I, class N>
     typename mute<I, DestValue>::ret
     watershed_seg(const abstract::non_vectorial_image<I>& im_i, 
 		  const abstract::neighborhood<N>& Ng);
     
-    /*=processing watershed_con
-     * what: Connected Watershed.
-     * ns: morpho
-     * tpl: class, DestValue, type of output labels
-     * arg: const abstract::non_vectorial_image<I>&, im, IN, image of levels
-     * arg: const abstract::neighborhood<N>&, ng, IN, neighborhood to consider
-     * ret: typename mute<I, DestValue>::ret
-     * doc:
-     *   Compute the connected watershed for image \\var{im} using
-     *   neighborhood \\var{ng}.
-     *
-     *   \\code{watershed_con} creates an ouput image whose values have
-     *   type \\var{DestValue} (which should be discrete).  In this output
-     *   all basins are labeled using values from \\code{DestValue::min()} to
-     *   \\code{DestValue::max() - 4} (the remaining values are used internally
-     *   by the algorithm).
-     *
-     *   When there are more basins than \\code{DestValue} can hold, wrapping
-     *   occurs (i.e., the same label is used for several basin).  This is
-     *   potentially harmful, because if two connected basins are labeled
-     *   with the same value they will appear as one basin.
-     * ref:
-     *   This is based on the original algorithm
-     *   presented by Vincent and Soille, but modified to not output
-     *   watersheds.
-    =*/
+
+    /*!
+    ** \\brief Connected watershed.
+    **
+    ** Compute the connected watershed for image im using
+    ** neighborhood ng.\\n
+    **
+    ** watershed_con creates an ouput image whose values have
+    ** type DestValue (which should be discrete).  In this output
+    ** all basins are labeled using values from DestValue::min() to
+    ** DestValue::max() - 4 (the remaining values are used internally
+    ** by the algorithm).\\n
+    **
+    ** When there are more basins than DestValue can hold, wrapping
+    ** occurs (i.e., the same label is used for several basin).  This is
+    ** potentially harmful, because if two connected basins are labeled
+    ** with the same value they will appear as one basin.\\n
+    **
+    ** \\ref This is based on the original algorithm
+    ** presented by Vincent and Soille, but modified to not output
+    ** watersheds.
+    **
+    ** \\param DestValue Type of the data in output image.
+    ** \\param I Exact type of the image.
+    ** \\param N Exact type of the neighborhood.
+    **
+    ** \\arg input Image of levels.
+    ** \\arg Ng Neighborhood to consider.
+    **
+    ** \\pre DestValue should be large enough.
+    **
+    ** \\code
+    ** #include <oln/basics2d.hh>
+    ** #include <oln/morpho/watershed.hh>
+    ** #include <oln/level/compare.hh>
+    ** #include <ntg/all.hh>
+    ** int main()
+    ** {
+    **   typedef oln::image2d<ntg::int_u8>	im_type;
+    **
+    **   im_type	im1(oln::load(IMG_IN \"lena256.pgm\"));
+    **
+    **   oln::save(oln::morpho::watershed_con<ntg::int_u16>(im1,
+    **                                                      oln::neighb_c4()),
+    **             IMG_OUT \"oln_morpho_watershed_con.pbm\");
+    **   return  0;
+    ** }
+    ** \\endcode
+    **
+    ** \\image html lena256.png
+    ** \\image latex lena256.png
+    ** =>
+    ** \\image html oln_morpho_watershed_con.png
+    ** \\image latex oln_morpho_watershed_con.png
+    **
+    ** \\todo Find a more pertinent example.
+    */
     template<class DestValue, class I, class N>
     typename mute<I, DestValue>::ret
     watershed_con(const abstract::non_vectorial_image<I>& im_i, const abstract::neighborhood<N>& Ng);
 
-    /*=processing watershed_seg_or
-     * what: Segmented Watershed with user-supplied starting points.
-     * ns: morpho
-     * arg: const abstract::non_vectorial_image<I1>&, levels, IN, image of levels
-     * arg: abstract::non_vectorial_image<I2>&, markers, INOUT, image of markers
-     * arg: const abstract::neighborhood<N>&, ng, IN, neighborhood to consider
-     * ret:oln_concrete_type(I2)&
-     * doc:
-     *   Compute a segmented watershed for image \\var{levels} using
-     *   neighborhood \\var{ng}, and \\var{markers} as starting point for
-     *   the flooding algorithm.
-     *
-     *   \\var{markers} is an image of the same size as \\var{levels}
-     *   and containing discrete values indicating label associated to
-     *   each basin.  On input, fill \\var{markers} with
-     *   \\code{oln_value_type(I2)::min()} (this is the \\emph{unknown} label)
-     *   and mark the starting points or regions
-     *   (usually these are minima in \\var{levels}) using a value
-     *   between \\code{oln_value_type(I2)::min()+1} and \\code{oln_value_type(I2)::max()-1}.
-     *
-     *   \\code{watershed_seg_or} will flood \\var{levels} from these
-     *   non-\\emph{unknown} starting points, labeling basins using
-     *   the value you assigned to them, and markining watershed lines
-     *   with \\code{oln_value_type(I2)::max()}.  \\var{markers} should not contains
-     *   any \\code{oln_value_type(I2)::min()} value on output.
-     * ref:
-     *   This is based on the original algorithm
-     *   presented by D'Ornellas et al. (FIXME: ref?)
-    =*/
+    /*!
+    ** \\brief Segmented watershed with user-supplied starting points.
+    **
+    ** Compute   a  segmented   watershed  for   image   levels  using
+    ** neighborhood ng, and markers as starting point for the flooding
+    ** algorithm.\\n
+    **
+    ** markers is an  image of the same size  as levels and containing
+    ** discrete values indicating label  associated to each basin.  On
+    ** input, fill markers with oln_value_type(I2)::min() (this is the
+    ** unknown label) and mark the starting points or regions (usually
+    ** these   are   minima  in   levels)   using   a  value   between
+    ** oln_value_type(I2)::min()+1 and oln_value_type(I2)::max()-1.\\n
+    **
+    ** watershed_seg_or  will  flood  levels  from  these  non-unknown
+    ** starting points,  labeling basins using the  value you assigned
+    ** to    them,     and    markining    watershed     lines    with
+    ** oln_value_type(I2)::max().   markers  should  not contains  any
+    ** oln_value_type(I2)::min() value on output.
+    **
+    ** \\ref  This is  based  on the  original  algorithm presented  by
+    ** D'Ornellas et al. (FIXME: ref?)
+    **
+    ** \\param I1 Exact type of the D image.
+    ** \\param I2 Exact type of the M image.
+    ** \\param N Exact type of the neighborhood.
+    **
+    ** \\arg D Input image.
+    ** \\arg M Image of labels.
+    ** \\arg Ng Neighborhood to consider.
+    */
     template<class I1, class I2, class N>
     oln_concrete_type(I2)&
     watershed_seg_or(const abstract::non_vectorial_image<I1>& D,
Index: olena/oln/morpho/watershed.hxx
--- olena/oln/morpho/watershed.hxx Sat, 27 Sep 2003 18:30:39 +0200 burrus_n (oln/47_watershed. 1.9.1.5.1.5 600)
+++ olena/oln/morpho/watershed.hxx Fri, 12 Mar 2004 12:58:17 +0100 palma_g (oln/47_watershed. 1.9.1.5.1.5 640)
@@ -1,4 +1,4 @@
-// Copyright (C) 2001, 2002, 2003  EPITA Research and Development Laboratory
+// Copyright (C) 2001, 2002, 2003, 2004  EPITA Research and Development Laboratory
 //
 // This file is part of the Olena Library.  This library is free
 // software; you can redistribute it and/or modify it under the terms
@@ -141,6 +141,10 @@
 	}
       };
       
+      /*!
+      ** \\brief Check  if the second element  of p1 is  lower than the
+      ** second one of p2.
+      */
       template<class Point, class T> inline
       bool 
       watershed_seg_sort_(const std::pair<Point, T>& p1,
@@ -149,7 +153,9 @@
 	return p1.second < p2.second;
       }
 
-      // Algorithm by Vincent and Soille
+      /*!
+      ** \\brief Algorithm by Vincent and Soille.
+      */
       template<class PointHandler, class DestValue, class I, class N>
       typename mute<I, DestValue>::ret
       soille_watershed_(const abstract::non_vectorial_image<I>& im_i, 
@@ -284,10 +290,12 @@
     }
 
 
-    // cmp_queue_elt is a comparison function for the elements from
-    // the priority queue used in watershed_seg_or.  Note that we
-    // return true when l is greater than r, because we when the queue
-    // sorted in increasing order.
+    /*!
+    ** cmp_queue_elt is a comparison function for the elements from
+    ** the priority queue used in watershed_seg_or.  Note that we
+    ** return true when l is greater than r, because we when the queue
+    ** sorted in increasing order.
+    */
     template <class T>
     struct cmp_queue_elt
     {
Index: olena/oln/morpho/attribute_closing_opening.hh
--- olena/oln/morpho/attribute_closing_opening.hh Thu, 11 Mar 2004 15:41:55 +0100 van-vl_n (oln/q/49_attribute_ 1.18 600)
+++ olena/oln/morpho/attribute_closing_opening.hh Thu, 11 Mar 2004 15:44:41 +0100 palma_g (oln/q/49_attribute_ 1.18 640)
@@ -58,14 +58,14 @@
 	  /*!
 	  ** \\brief Perform an attribute closing.
 	  **
-	  ** \\param I: image exact type.
-	  ** \\param N: neighborhood exact type.
-	  ** \\param A: Attribute exact type.
-	  **
-	  ** \\arg input: input image.
-	  ** \\arg Ng: neighborhood to use.
-	  ** \\arg lambda: threshold to use.
-	  ** \\arg env: environment.
+	  ** \\param I Image exact type.
+	  ** \\param N Neighborhood exact type.
+	  ** \\param A Attribute exact type.
+	  **
+	  ** \\arg input Input image.
+	  ** \\arg Ng Neighborhood to use.
+	  ** \\arg lambda Threshold to use.
+	  ** \\arg env Environment.
 	  */
 	  template<class I, class N, class A>
 	  oln_concrete_type(I)
@@ -82,14 +82,14 @@
 	  /*!
 	  ** \\brief Perform an attribute opening.
 	  **
-	  ** \\param I: image exact type.
-	  ** \\param N: neighborhood exact type.
-	  ** \\param A: Attribute exact type.
-	  **
-	  ** \\arg input: input image.
-	  ** \\arg Ng: neighborhood to use.
-	  ** \\arg lambda: threshold to use.
-	  ** \\arg env: environment.
+	  ** \\param I Image exact type.
+	  ** \\param N Neighborhood exact type.
+	  ** \\param A Attribute exact type.
+	  **
+	  ** \\arg input Input image.
+	  ** \\arg Ng Neighborhood to use.
+	  ** \\arg lambda Threshold to use.
+	  ** \\arg env Environment.
 	  */
 	  template<class I, class N, class A>
 	  oln_concrete_type(I)
Index: olena/oln/morpho/attribute_union_find.hh
--- olena/oln/morpho/attribute_union_find.hh Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/q/50_attribute_ 1.14 600)
+++ olena/oln/morpho/attribute_union_find.hh Wed, 10 Mar 2004 19:56:59 +0100 palma_g (oln/q/50_attribute_ 1.14 640)
@@ -43,11 +43,11 @@
 
 	/*!
 	** \\brief  Struct  that  contains  everything  to  compute  an
-	** attribute opening or closing
+	** attribute opening or closing.
 	**
-	** \\param T: exact type of images to process.
-	** \\param ATTRIBUTE: exact type of attribute to use.
-	** \\param Env: type of environment to use.
+	** \\param T Exact type of images to process.
+	** \\param ATTRIBUTE Exact type of attribute to use.
+	** \\param Env Type of environment to use.
 	*/
 	template<class T, class ATTRIBUTE, class Env = attr_env_type(ATTRIBUTE)>
 	struct tarjan_set
@@ -60,8 +60,8 @@
 
 	  /*!
 	  ** \\brief tarjan_set constructor.
-	  ** \\param ima: image to open/close.
-	  ** \\param env: environment to use to compute attributes.
+	  ** \\param ima Image to open/close.
+	  ** \\param env Environment to use to compute attributes.
 	  */
 	  tarjan_set(const image_type& ima, const env_type &env) : input_(ima),
 								   parent_(ima.size()),
@@ -73,11 +73,11 @@
 
 	  /*!
 	  ** \\brief Main method to perform an attribute opening/closing.
-	  ** \\param closing: true -> a closing is performed, an opening otherwise.
+	  ** \\param closing True -> a closing is performed, an opening otherwise.
 	  **
-	  ** \\param lambda: threshold to use for attribute growing.
-	  ** \\param Ng: neighborhood to use in the algorithm.
-	  ** \\return the resulting image.
+	  ** \\param lambda Threshold to use for attribute growing.
+	  ** \\param Ng Neighborhood to use in the algorithm.
+	  ** \\return The resulting image.
 	  */
 	  template<bool closing, class N>
 	  image_type
@@ -162,7 +162,7 @@
 
 	  /*!
 	  ** \\brief Make a new component from a point.
-	  ** \\arg x: root of the component.
+	  ** \\arg x Root of the component.
 	  */
 	  void
 	  make_set(const point_type& x)
@@ -174,7 +174,7 @@
 
 	  /*!
 	  ** \\brief find the root of a component.
-	  ** \\arg x: a point of the component.
+	  ** \\arg x A point of the component.
 	  */
 	  point_type
 	  find_root(const point_type& x)
@@ -190,8 +190,8 @@
 
 	  /*!
 	  ** \\brief Check if two components should be merged.
-	  ** \\arg x: a point of the first component.
-	  ** \\arg y: a point of the second component.
+	  ** \\arg x A point of the first component.
+	  ** \\arg y A point of the second component.
 	  */
 	  bool
 	  criterion(const point_type& x, const point_type& y)
@@ -203,8 +203,8 @@
 
 	  /*!
 	  ** \\brief Do union of two components.
-	  ** \\arg n: a point of the first component.
-	  ** \\arg p: a point of the second component.
+	  ** \\arg n A point of the first component.
+	  ** \\arg p A point of the second component.
 	  */
 	  void
 	  uni(const point_type& n, const point_type& p)
Index: olena/oln/morpho/attributes.hh
--- olena/oln/morpho/attributes.hh Wed, 10 Mar 2004 16:20:23 +0100 palma_g (oln/j/45_attributes 1.6 600)
+++ olena/oln/morpho/attributes.hh Wed, 10 Mar 2004 19:50:24 +0100 palma_g (oln/j/45_attributes 1.6 644)
@@ -128,7 +128,7 @@
     // the traits fwd declaration
     /*!
     ** Traits  for attributes information.
-    ** \\param T: exact type of the attribute.
+    ** \\param T Exact type of the attribute.
     */
     template <class T>
     struct attr_traits;
@@ -728,8 +728,8 @@
       *-----------*/
     /*!
     ** \\brief Max value attribute.
-    ** \\param T: data type.
-    ** \\param Exact: the exact type.
+    ** \\param T Data type.
+    ** \\param Exact The exact type.
     */
     template <class T = unsigned, class Exact = mlc::final>
     class maxvalue_type:
@@ -752,7 +752,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       maxvalue_type(const lambda_type &lambda): value_(lambda)
 	{
@@ -761,10 +761,10 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\param I: image exact type.
+      ** \\param I Image exact type.
       **
-      ** \\arg input: input image.
-      ** \\arg p: point to consider in the image.
+      ** \\arg input Input image.
+      ** \\arg p Point to consider in the image.
       */
       template <class I>
 	maxvalue_type(const abstract::image<I> &input,
@@ -844,8 +844,8 @@
       *-----------*/
     /*!
     ** \\brief Min value attribute.
-    ** \\param T: data type.
-    ** \\param Exact: the exact type.
+    ** \\param T Data type.
+    ** \\param Exact The exact type.
     */
     template <class T = unsigned, class Exact = mlc::final>
     class minvalue_type:
@@ -868,7 +868,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       minvalue_type(const lambda_type &lambda): value_(lambda)
 	{
@@ -877,10 +877,10 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\param I: image exact type.
+      ** \\param I Image exact type.
       **
-      ** \\arg input: input image.
-      ** \\arg p: point to consider in the image.
+      ** \\arg input Input image.
+      ** \\arg p Point to consider in the image.
       */
       template <class I>
 	minvalue_type(const abstract::image<I> &input,
@@ -960,8 +960,8 @@
 	*-----------*/
     /*!
     ** \\brief Ball attribute.
-    ** \\param I: exact type of images to process.
-    ** \\param Exact: the exact type.
+    ** \\param I Exact type of images to process.
+    ** \\param Exact The exact type.
     */
     template <class I, class Exact = mlc::final>
     class ball_type:
@@ -989,7 +989,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       ball_type(const lambda_type &lambda): value_(lambda), pts_()
 	{
@@ -999,7 +999,7 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\arg p: point to consider in the image.
+      ** \\arg p Point to consider in the image.
       */
       ball_type(const im_type&, const point_type &p, const env_type &) :
 	value_(ntg_zero_val(value_type)), pts_()
@@ -1123,8 +1123,8 @@
 	*-----------*/
     /*!
     ** \\brief Dist attribute.
-    ** \\param I: exact type of images to process.
-    ** \\param Exact: the exact type.
+    ** \\param I Exact type of images to process.
+    ** \\param Exact The exact type.
     */
     template <class I, class Exact = mlc::final>
     class dist_type:
@@ -1150,7 +1150,7 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\arg p: point to consider in the image.
+      ** \\arg p Point to consider in the image.
       */
       dist_type(const im_type&,
 		const point_type &p,
@@ -1174,7 +1174,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       dist_type(const lambda_type lambda): value_(lambda)
 	{
@@ -1275,8 +1275,8 @@
 	*-----------*/
     /*!
     ** \\brief Cube attribute.
-    ** \\param I: exact type of images to process.
-    ** \\param Exact: the exact type.
+    ** \\param I Exact type of images to process.
+    ** \\param Exact The exact type.
     */
     template <class I, class Exact = mlc::final>
     class cube_type:
@@ -1304,7 +1304,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       cube_type(const lambda_type &lambda):
 	mins_(dim),
@@ -1321,7 +1321,7 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\arg p: point to consider in the image.
+      ** \\arg p Point to consider in the image.
       */
       cube_type(const im_type&,
 		const point_type &p,
@@ -1336,7 +1336,7 @@
       ** \\brief Accessor to minimums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th minimum.
       ** \\see getMin_impl()
       */
@@ -1349,7 +1349,7 @@
       ** \\brief Accessor to maximums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th maximum.
       ** \\see getMax_impl()
       */
@@ -1444,8 +1444,8 @@
 	*-----*/
     /*!
     ** \\brief Box attribute.
-    ** \\param I: exact type of images to process.
-    ** \\param Exact: the exact type.
+    ** \\param I Exact type of images to process.
+    ** \\param Exact The exact type.
     */
     template <class I, class Exact = mlc::final>
     class box_type:
@@ -1462,7 +1462,7 @@
       /*!
       ** \\brief Ctor from a lambda_type value.
       **
-      ** \\arg lambda: value of the attribute.
+      ** \\arg lambda Value of the attribute.
       */
       box_type(const lambda_type &lambda): maxs_(dim), mins_(dim)
 	{
@@ -1486,7 +1486,7 @@
       /*!
       ** \\brief Ctor from a point and an image.
       **
-      ** \\arg p: point to consider in the image.
+      ** \\arg p Point to consider in the image.
       */
       box_type(const im_type&, const point_type &p, const env_type &): maxs_(dim), mins_(dim)
 	{
@@ -1498,7 +1498,7 @@
       ** \\brief Accessor to minimums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th minimum.
       ** \\see getMin_impl()
       */
@@ -1512,7 +1512,7 @@
       ** \\brief Accessor to maximums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th maximum.
       ** \\see getMax_impl()
       */
@@ -1526,7 +1526,7 @@
       ** \\brief Accessor to minimums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th minimum.
       ** \\see getMin_impl()
       */
@@ -1540,7 +1540,7 @@
       ** \\brief Accessor to maximums.
       **
       ** Virtual method.
-      ** \\arg i: index of the minimum wanted.
+      ** \\arg i Index of the minimum wanted.
       ** \\return the i th maximum.
       ** \\see getMax_impl()
       */
Index: olena/oln/morpho/attribute_closing_opening_map.hh
--- olena/oln/morpho/attribute_closing_opening_map.hh Thu, 11 Mar 2004 15:41:55 +0100 van-vl_n (oln/j/49_attribute_ 1.5 600)
+++ olena/oln/morpho/attribute_closing_opening_map.hh Thu, 11 Mar 2004 15:43:32 +0100 palma_g (oln/j/49_attribute_ 1.5 600)
@@ -60,9 +60,9 @@
       ** See \"Fast morphological attribute operations using Tarjan's union-find
       ** algorithm\" by Michael H. F. Wilkinson and Jos B. T. M. Roerdink
       **
-      ** \\param I: image exact type.
-      ** \\param D: attribute exact type.
-      ** \\param Env: type of environment.
+      ** \\param I Image exact type.
+      ** \\param D Attribute exact type.
+      ** \\param Env Type of environment.
       */
       template <class I, class D, class Env = morpho::NullEnv>
       struct f_tarjan_map
@@ -90,13 +90,13 @@
 	/*!
 	** \\brief Perform an attribute opening/closing.
 	**
-	** \\param N: exact type of neighborhood
+	** \\param N Exact type of neighborhood
 	**
-	** \\arg is_closing: choose between closing and opening.
-	** \\arg input: input image.
-	** \\arg ng: neighborhood to use.
-	** \\arg lambda: threshold.
-	** \\arg env: environment.
+	** \\arg is_closing Choose between closing and opening.
+	** \\arg input Input image.
+	** \\arg ng Neighborhood to use.
+	** \\arg lambda Threshold.
+	** \\arg env Environment.
 	*/
 	template <class N>
 	f_tarjan_map(bool is_closing,
@@ -105,7 +105,7 @@
 		     const lambda_type& lambda,
 		     const Env & env = Env());
 	/*!
-	** \\brief return the result of the opening/closing.
+	** \\brief Return the result of the opening/closing.
 	*/
 	oln_concrete_type(I)
 	  res()
@@ -128,22 +128,22 @@
 
 	/*!
 	** \\brief Make a new component from a point.
-	** \\arg x: root of the component.
+	** \\arg x Root of the component.
 	*/
 	void
 	make_set(const point_type& x);
 
 	/*!
 	** \\brief link two components
-	** \\arg x: a point of the first component.
-	** \\arg y: a point of the second component.
+	** \\arg x A point of the first component.
+	** \\arg y A point of the second component.
 	*/
 	void
 	link(const point_type& x, const point_type& y);
 
 	/*!
 	** \\brief find the root of a component.
-	** \\arg x: a point of the component.
+	** \\arg x A point of the component.
 	*/
 	point_type
 	find_root(const point_type& x);
@@ -157,8 +157,8 @@
 
 	/*!
 	** \\brief link two components if they have to be linked
-	** \\arg n: a point of the first component.
-	** \\arg p: a point of the second component.
+	** \\arg n A point of the first component.
+	** \\arg p A point of the second component.
 	*/
 	void
 	do_union(const point_type& n, const point_type& p);

")
(New-Version-Log "")
(Checkin-Time "Fri, 12 Mar 2004 13:29:59 +0100")
(Checkin-Login palma_g)
;; diff-ignore tests/data/.*pbm$
;; diff-ignore .*\.pbm$
;; diff-ignore .*\.pgm$
;; diff-ignore .*\.pnm$
;; diff-ignore doc/doc/ref-morpho.tex$
;; diff-ignore doc/doc/ref-level.tex$
;; diff-ignore oln/oln/config/pconf-inc.in$
(Populate-Ignore ("~$"
                  "\\.\\(bak\\|old\\|rej\\|orig\\)$"
                  "\\.o$"
                  "\\.cmi$"
                  "\\.cmx$"
                  "\\.a$"
                  "\\.s$"
                  "\\.so$"
                  "\\.gz$"
                  "\\.out$"
                  "\\.err$"
                  "\\.log$"
                  "\\.pyc$"
                  "\\.cache$"
                  "\\.status$"
                  "\\.deps/"
                  "/Makefile$"
                  "^Makefile$"
                  "stamp-h\\([0-9]\\)\\?$"
                  "CVS/"
                  ".cvsignore$"
                  "obsolete/"
                  "/obsolete/"
                  "autom4te.cache"
                  "\\.html$"
                  "\\.png$"
                  "\\.pdf$"
                  "\\.eps$"
                  "tools/swilena/.*_wrap.cxx$"
                  "doc/ref/.*\\.pbm$"
                  "doc/ref/bin/.*$"
                  "doc/ref/html/.*$"
                  "doc/ref/oln-ref.\\(dvi\\|tmp\\|toc\\|pg\\|ps\\|ky\\|tp\\|vr\\|fn\\|cps\\?\\|aux\\|info\\)$"
                  "doc/dev/oln-dev.\\(dvi\\|tmp\\|toc\\|pg\\|ps\\|ky\\|tp\\|vr\\|fn\\|cps\\?\\|aux\\|info\\)$"
                  "doc/dev/version.texi$"
                  "src/tests/convert/.*-.*-.*$"
                  "\\.#"
                  "^#"
                  "/#"
                  "metalic/tests/check/defs$"
                  "integre/tests/check/defs$"
                  "olena/tests/check/defs$"
                  "\\(TAGS\\|tags\\)$"
                  "diffs.patch$"
                  "/Makefile.in$"
                  "^Makefile.in$"
		  "/makefile.swig"
                  "/\\(py-compile\\|missing\\|install-sh\\|mkinstalldirs\\|depcomp\\|mdate-sh\\)$"
                  "\\(texinfo\\.tex\\)$"
                  "^\\(.*/\\)\\?aclocal.m4$"
                  "/configure$"
                  "^configure$"
                  "utilities/morpho/morpho-rules.make$"
                  "doc/ref/filelists.make$"
                  "config.h\\(in\\)\\?$"
                  "doc/ref/ref-level.tex"
                  "doc/ref/ref-morpho.tex"
                  "utilities/.*\\.1$"
                  "^attic/"
                  "oln-"
                  "stamp-vti$"
                  "^\\(BUILD\\|FAQ\\|INSTALL\\|README\\|THANKS\\)$"
                  "olena/img/se9.ppbm"
                  "olena/img/neighbor.ppbm"
                  "^olena/tests/check/defs$"
                  "olena/oln/config/pconf.hh$"
                  "olena/img/lena.ppgm"
                  "olena/img/lena.pgm"
                  "olena/img/se.ppbm"
                  "olena/img/lena.pbm"
                  "olena/img/lena.pppm"
                  "olena/img/lena128.pgm"
                  "olena/img/lena.ppbm"
                  "olena/img/neighbor9.ppbm"
                  "^CODING_STYLE$"
                  "olena/img/lena16b.ppgm"
                  "olena/img/lena16b.pgm"
                  "^tools/swilena/src/.*\\.i"
                  "olena/img/lena1d.ppbm"
                  "olena/img/lena1d128.pgm"
                  "olena/img/lena1d.pppm"
                  "olena/img/lena3d.pgm"
                  "olena/img/lena3d.pbm"
                  "olena/img/lena1d16b.pgm"
                  "olena/img/lena1d16b.ppgm"
                  "olena/img/lena1d.ppgm"
                  "olena/img/lena1d.pgm"
                  "olena/img/lena1d.pbm"
                  "olena/img/lena1d16b.ppbm"
                  "\\.xvpics/"
                  "old/"))
(Project-Keywords)
(Files

  (ChangeLog (oln/o/33_ChangeLog 1.37.1.16.1.17.1.15 640))
  (doc/ChangeLog (oln/o/31_ChangeLog 1.38.1.7.1.5.1.6 640))
  (integre/ChangeLog (oln/q/35_ChangeLog 1.12.1.2.1.35 640))
  (metalic/ChangeLog (oln/q/30_ChangeLog 1.3.1.38 640))
  (olena/ChangeLog (oln/o/30_ChangeLog 1.27.1.36.1.3.1.11.1.5.1.64.1.47.1.19 640))
  (tools/ChangeLog (oln/o/32_ChangeLog 1.10.1.12 640))
  (tools/swilena/ChangeLog (oln/n/37_ChangeLog 1.7.1.21 640))

  (olena/ChangeLog.0 (oln/6_ChangeLog 1.50.1.98.1.5 640))
  (doc/ChangeLog.0 (oln/e/1_ChangeLog 1.31 640))
  (attic/tests-ChangeLog (oln/e/30_ChangeLog 1.52 640))

  (bootstrap.sh (oln/j/16_bootstrap. 1.11 750))

  (cleanup.sh (oln/o/29_cleanup.sh 1.5 750))

  (configure.ac (oln/3_configure. 1.47.1.1.1.1.1.4.1.15.1.15 640))

  (doc/demo/image.cc (oln/d/46_image.cc 1.8 640))
  (doc/demo/Makefile.am (oln/d/44_Makefile.a 1.16.1.2 640))
  (doc/demo/morpholena.cc (oln/d/43_morpholena 1.11 640))
  (olena/tests/morpho/tests/test-reconstruction (oln/e/22_test-recon 1.7.1.3.1.2 640))
  (doc/demo/tour.cc (oln/d/45_tour.cc 1.13 640))
  (doc/ref/bin () :directory)
  
  (doc/ref/Makefile.am (oln/d/51_Makefile.a 1.27.1.12 640))
  (doc/dev/oln-dev.texi (oln/j/1_oln-dev.te 1.6.1.5 640))
  (doc/ref/oln-ref.tex (oln/f/14_oln-ref.te 1.3.1.3 640))
  (doc/ref/integre-ref.tex (oln/g/34_ref-types. 1.12 640))
  (doc/Makefile.am (oln/e/0_Makefile.a 1.14 640))
  (doc/ref/processing.tpl (oln/d/48_processing 1.16 640))

  (Makefile.am (oln/n/32_Makefile.a 1.17.1.2.1.7 640))
  (NEWS (oln/0_NEWS 1.21 640))

  (olena/img/face_se.pbm (oln/n/17_face_se.pb 1.1 640) :no-keywords)
  (olena/img/lena256.pgm (oln/n/14_lena256.pg 1.1 640) :no-keywords)
  (olena/img/lena_dark.pgm (oln/n/13_lena_dark. 1.1 640) :no-keywords)
  (olena/img/lena.ppm (oln/n/10_lena.ppm 1.1 640) :no-keywords)
  (olena/img/Makefile.am (oln/o/34_Makefile.a 1.9 640) :no-keywords)
  ; (oln/img/Makefile.in ())
  (olena/img/map.pbm (oln/n/12_map.pbm 1.1 640) :no-keywords)
  (olena/img/neighbor9.pbm (oln/n/8_neighbor9. 1.1 640) :no-keywords)
  (olena/img/neighbor.pbm (oln/n/9_neighbor.p 1.1 640) :no-keywords)
  (olena/img/object.pbm (oln/n/11_object.pbm 1.1 640) :no-keywords)
  (olena/img/random.pgm (oln/n/7_random.pgm 1.1 640) :no-keywords)
  (olena/img/se9.pbm (oln/n/5_se9.pbm 1.1 640) :no-keywords)
  (olena/img/se.pbm (oln/n/6_se.pbm 1.1 640) :no-keywords)

  (olena/Makefile.am (oln/2_Makefile.a 1.30.1.1.1.2.1.10 640))
  (olena/oln/arith/internal/opdecls.hh (oln/b/22_opdecls.hh 1.15 640))
  (olena/oln/arith/logic.hh (oln/b/24_logic.hh 1.6.1.3 640))
  (olena/oln/arith/ops.hh (oln/b/23_ops.hh 1.5.1.2.1.8 640))
  (olena/oln/basics1d.hh (oln/d/41_basics1d.h 1.5 640))
  (olena/oln/basics2d.hh (oln/b/7_basics2d.h 1.6 640))
  (olena/oln/basics3d.hh (oln/28_basics3d.h 1.4 640))
  (olena/oln/basics.hh (oln/d/42_basics.hh 1.13 640))


  (olena/oln/config/system.hh (oln/7_system.hh 1.17 640))
  (olena/oln/convert/basics.hh (oln/23_basics.hh 1.6 640))
  (olena/oln/convert/bound.hh (oln/22_bound.hh 1.10 640))
  (olena/oln/convert/abstract/colorconv.hh (oln/18_colorconv. 1.10 640))
  (olena/oln/convert/conversion.hh (oln/21_conversion 1.16 640))
  (olena/oln/convert/conversion_ng_se.hh (oln/e/24_conversion 1.11 640))
  (olena/oln/convert/force.hh (oln/20_force.hh 1.12 640))
  
  
  
  (olena/oln/convert/nrgbxyz.hh (oln/16_nrgbxyz.hh 1.12 640))
  
  
  (olena/oln/convert/rgbnrgb.hh (oln/17_rgbnrgb.hh 1.11 640))
  (olena/oln/convert/rgbxyz.hh (oln/19_rgbxyz.hh 1.12 640))
  (olena/oln/convert/stretch.hh (oln/f/51_stretch.hh 1.13 640))
  (olena/oln/convol/convolution.hh (oln/f/39_convolutio 1.4.1.4.1.6.1.1 640))
  (olena/oln/convol/fast_gaussian_coefficient.hh (oln/24_fast_gauss 1.5.1.6 640))
  (olena/oln/convol/fast_gaussian.hh (oln/26_fast_gauss 1.6.1.6.1.4 640))
  (olena/oln/convol/fast_gaussian.hxx (oln/25_fast_gauss 1.7.1.8.1.6 640))
  (olena/oln/core/accum.hh (oln/d/40_accum.hh 1.4 640))
  (olena/oln/core/apply.hh (oln/d/39_apply.hh 1.14 640))
  (olena/oln/core/bkd_iter1d.hh (oln/d/38_bkd_iter1d 1.16 640))
  (olena/oln/core/bkd_iter2d.hh (oln/d/37_bkd_iter2d 1.16 640))
  (olena/oln/core/bkd_iter3d.hh (oln/d/36_bkd_iter3d 1.16 640))
  
  
  
  
  (olena/oln/core/box.hh (oln/o/51_box.hh 1.3.1.3 640))
  (olena/oln/core/box.hxx (oln/p/0_box.hxx 1.4.1.1.1.5 640))
  (olena/oln/core/compose.hh (oln/c/22_compose.hh 1.5 640))
  (metalic/mlc/contract.hh (oln/d/31_contract.h 1.10 640))
  (olena/oln/core/coord.hh (oln/d/29_coord.hh 1.3 640))
  (olena/oln/core/dpoint1d.hh (oln/d/27_dpoint1d.h 1.13 640))
  (olena/oln/core/dpoint1d.hxx (oln/d/26_dpoint1d.h 1.8 640))
  (olena/oln/core/dpoint2d.hh (oln/d/25_dpoint2d.h 1.12 640))
  (olena/oln/core/dpoint2d.hxx (oln/d/24_dpoint2d.h 1.6 640))
  (olena/oln/core/dpoint3d.hh (oln/d/23_dpoint3d.h 1.12 640))
  (olena/oln/core/dpoint3d.hxx (oln/d/22_dpoint3d.h 1.6 640))
  (olena/oln/core/abstract/dpoint.hh (oln/d/28_dpoint.hh 1.19 640))
  
  (olena/oln/core/fold.hh (oln/c/7_fold.hh 1.13 640))
  (olena/oln/core/fwd_iter1d.hh (oln/d/21_fwd_iter1d 1.13 640))
  (olena/oln/core/fwd_iter2d.hh (oln/d/20_fwd_iter2d 1.13 640))
  (olena/oln/core/fwd_iter3d.hh (oln/d/19_fwd_iter3d 1.13 640))
  (olena/oln/core/generate.hh (oln/f/12_generate.h 1.18 640))
  (olena/oln/core/image1d.hh (oln/c/47_image1d.hh 1.28.1.1 640))
  (olena/oln/core/image1d_size.hh (oln/c/46_image1d_si 1.10 640))
  (olena/oln/core/image2d.hh (oln/c/45_image2d.hh 1.30.1.1 640))
  (olena/oln/core/image2d_size.hh (oln/c/44_image2d_si 1.10 640))
  (olena/oln/core/image3d.hh (oln/c/43_image3d.hh 1.27.1.1 640))
  (olena/oln/core/image3d_size.hh (oln/c/42_image3d_si 1.10 640))
  (olena/oln/core/image.hh (oln/d/18_image.hh 1.20.2.1 640))
  
  (olena/oln/core/abstract/image_size.hh (oln/c/41_image_size 1.11 640))
  (olena/oln/core/internal/fake.hh (oln/d/17_fake.hh 1.3 640))
  
  
  
  
  
  
  (olena/oln/core/abstract/iter1d.hh (oln/d/10_iter1d.hh 1.16 640))
  (olena/oln/core/abstract/iter2d.hh (oln/d/9_iter2d.hh 1.16 640))
  (olena/oln/core/abstract/iter3d.hh (oln/d/8_iter3d.hh 1.16 640))
  

  
  
  
  
  
  
  (olena/oln/core/abstract/iter.hh (oln/c/40_iter.hh 1.17 640))
  (olena/oln/core/macros.hh (oln/c/39_macros.hh 1.5 640))
  (olena/oln/core/neighborhood1d.hh (oln/c/37_neighborho 1.15 640))
  (olena/oln/core/neighborhood2d.hh (oln/c/36_neighborho 1.16 640))
  (olena/oln/core/neighborhood3d.hh (oln/c/35_neighborho 1.15 640))
  (olena/oln/core/abstract/neighborhood.hh (oln/c/38_neighborho 1.19 640))
  (metalic/mlc/objs.hh (oln/c/34_objs.hh 1.7 640))
  (olena/oln/core/point1d.hh (oln/c/32_point1d.hh 1.14 640))
  (olena/oln/core/point1d.hxx (oln/c/31_point1d.hx 1.6 640))
  (olena/oln/core/point2d.hh (oln/c/30_point2d.hh 1.12 640))
  (olena/oln/core/point2d.hxx (oln/c/29_point2d.hx 1.6 640))
  (olena/oln/core/point3d.hh (oln/c/28_point3d.hh 1.14 640))
  (olena/oln/core/point3d.hxx (oln/c/27_point3d.hx 1.5 640))
  (olena/oln/core/abstract/point.hh (oln/c/33_point.hh 1.16 640))
  
  (olena/oln/core/abstract/binary_image.hh (oln/c/24_pred_image 1.6 640))
  
  (olena/oln/core/abstract/struct_elt.hh (oln/c/25_structelt. 1.20 640))
  (olena/oln/core/traverse.hh (oln/d/30_traverse.h 1.11 640))
  (metalic/mlc/typeadj.hh (oln/e/25_typeadj.hh 1.6 640))
  (metalic/mlc/type.hh (oln/c/21_type.hh 1.28 640))
  (olena/oln/core/window1d.hh (oln/c/15_window1d.h 1.15 640))
  (olena/oln/core/window2d.hh (oln/c/14_window2d.h 1.17 640))
  (olena/oln/core/window3d.hh (oln/c/13_window3d.h 1.16 640))
  (olena/oln/core/abstract/window.hh (oln/c/16_window.hh 1.17 640))
  (olena/oln/core/winiter.hh (oln/c/12_winiter.hh 1.12 640))
  (olena/oln/core/winneighb.hh (oln/c/11_winneighb. 1.14 640))
  (olena/oln/core/w_window1d.hh (oln/c/19_w_window1d 1.16 640))
  (olena/oln/core/w_window2d.hh (oln/c/18_w_window2d 1.6.1.11 640))
  (olena/oln/core/w_window3d.hh (oln/c/17_w_window3d 1.16 640))
  (olena/oln/core/abstract/w_window.hh (oln/c/20_w_window.h 1.14 640))
  (olena/oln/io/base.hh (oln/b/20_base.hh 1.8 640))
  
  (olena/oln/io/basics.hh (oln/b/12_basics.hh 1.6 640))
  (olena/oln/io/file.hh (oln/b/17_file.hh 1.5 640))
  (olena/oln/io/gz.hh (oln/f/16_gz.hh 1.6 640))
  (olena/oln/io/gz_stream.hh (oln/f/17_gz_stream. 1.9 640))
  
  
  (olena/oln/io/pnm_read_3d.hh (oln/b/11_pnm_read3d 1.13 640))
  
  (olena/oln/io/pnm_read.hh (oln/b/16_pnm_read.h 1.9.1.10 640))
  (olena/oln/io/pnm_write_3d.hh (oln/b/9_pnm_write3 1.1.1.13 640))
  
  (olena/oln/io/pnm_write.hh (oln/b/15_pnm_write. 1.8.1.13 640))
  (olena/oln/io/readable.hh (oln/b/13_readable.h 1.12 640))
  (olena/oln/io/se.hh (oln/i/45_se.hh 1.4 640))
  (olena/oln/io/se_neighborhood.hh (oln/i/47_se_neighbo 1.13 640))
  (olena/oln/io/se_window.hh (oln/i/46_se_window. 1.14 640))
  (olena/oln/level/cc.hh (oln/e/20_cc.hh 1.11.1.10 640))
  (olena/oln/level/compare.hh (oln/31_compare.hh 1.9 640))
  (olena/oln/level/connected.hh (oln/30_connected. 1.9.1.12 640))
  (olena/oln/level/fill.hh (oln/32_fill.hh 1.10 640))
  (olena/oln/level/invert.hh (oln/33_invert.hh 1.5.2.2.1.11 640))
  (olena/oln/level/lut.hh (oln/29_lut.hh 1.10 640))
  (olena/oln/level/set_level.hh (oln/p/1_set_level. 1.10 640))
  (olena/oln/level/threshold.hh (oln/f/15_threshold. 1.13 640))
  (config/oln.m4 (oln/j/15_oln.m4 1.36 640))

  (olena/oln/math/macros.hh (oln/b/21_macros.hh 1.6.1.11 640))
  (metalic/mlc/array/1d.hh (oln/f/23_array1d.hh 1.11 640))
  (metalic/mlc/array/1d.hxx (oln/f/22_array1d.hx 1.10 640))
  (metalic/mlc/array/2d.hh (oln/f/21_array2d.hh 1.11 640))
  (metalic/mlc/array/2d.hxx (oln/f/20_array2d.hx 1.9 640))
  (metalic/mlc/array/3d.hh (oln/f/19_array3d.hh 1.12 640))
  (metalic/mlc/array/3d.hxx (oln/f/18_array3d.hx 1.10 640))
  (metalic/mlc/array/all.hh (oln/f/36_array.hh 1.7 640))
  (metalic/mlc/array/nd.hh (oln/f/35_arraynd.hh 1.4 640))
  (metalic/mlc/bool.hh (oln/c/4_basics.hh 1.15 640))
  (metalic/mlc/cmp.hh (oln/c/3_cmp.hh 1.9 640))
  (metalic/mlc/loop.hh (oln/c/2_control.hh 1.7 640))

  (metalic/mlc/optional.hh (oln/o/41_optional.h 1.7 640))
  (metalic/mlc/is_a.hh (oln/g/33_type.hh 1.12 640))

  (metalic/mlc/math.hh (oln/b/51_ufuncs.hh 1.10 640))
  (olena/oln/morpho/closing.hh (oln/b/6_closing.hh 1.6 640))
  (olena/oln/morpho/closing.inc (oln/44_closing.in 1.16 640))
  (olena/oln/morpho/dilation.hh (oln/b/5_dilation.h 1.17 640))
  (olena/oln/morpho/erosion.hh (oln/b/4_erosion.hh 1.19 640))
  (olena/oln/morpho/extrema.hh (oln/38_extrema.hh 1.13 640))
  (olena/oln/morpho/extrema.hxx (oln/j/4_extrema.hx 1.13 640))
  (olena/oln/morpho/extrema_killer.hh (oln/e/19_extrema_ki 1.7.1.4.1.12 640))
  (olena/oln/morpho/fast_morpho.hh (oln/46_fast_morph 1.9 640))
  (olena/oln/morpho/fast_morpho.hxx (oln/45_fast_morph 1.19 640))
  (olena/oln/morpho/geodesic_dilation.hh (oln/37_geodesic_d 1.11.1.11 640))
  (olena/oln/morpho/geodesic_erosion.hh (oln/36_geodesic_e 1.18 640))
  (olena/oln/morpho/gradient.hh (oln/b/3_gradient.h 1.6 640))
  (olena/oln/morpho/gradient.inc (oln/43_gradient.i 1.14 640))
  (olena/oln/morpho/hit_or_miss.hh (oln/b/2_hit_or_mis 1.7 640))
  (olena/oln/morpho/hit_or_miss.inc (oln/42_hit_or_mis 1.21 640))
  (olena/oln/morpho/laplacian.hh (oln/b/1_laplacian. 1.6 640))
  (olena/oln/morpho/laplacian.inc (oln/41_laplacian. 1.14 640))
  (olena/oln/morpho/minmax.hh (oln/b/0_minmax.hh 1.6 640))
  (olena/oln/morpho/opening.hh (oln/51_opening.hh 1.6 640))
  (olena/oln/morpho/opening.inc (oln/40_opening.in 1.14 640))
  (olena/oln/morpho/reconstruction.hh (oln/35_reconstruc 1.13.1.12 640))
  (olena/oln/morpho/splitse.hh (oln/34_splitse.hh 1.8 640))
  (olena/oln/morpho/stat.hh (oln/50_stat.hh 1.8.1.12 640))
  (olena/oln/morpho/thickening.hh (oln/e/29_thickening 1.7 640))
  (olena/oln/morpho/thickening.inc (oln/e/28_thickening 1.11 640))
  (olena/oln/morpho/thinning.hh (oln/e/27_thinning.h 1.7 640))
  (olena/oln/morpho/thinning.inc (oln/e/26_thinning.i 1.12 640))
  (olena/oln/morpho/top_hat.hh (oln/49_top_hat.hh 1.4 640))
  (olena/oln/morpho/top_hat.inc (oln/39_top_hat.in 1.14 640))
  (olena/oln/morpho/watershed.hh (oln/48_watershed. 1.12 640))
  (olena/oln/morpho/watershed.hxx (oln/47_watershed. 1.9.1.5.1.6 640))
  (olena/oln/topo/dmap.hh (oln/p/2_dmap.hh 1.7 640))
  (olena/oln/topo/dmap.hxx (oln/p/3_dmap.hxx 1.7.1.9 640))
  (olena/oln/transforms/dwt.hh (oln/i/35_dwt.hh 1.2.1.4.1.10 640))
  (olena/oln/transforms/fft.hh (oln/i/36_fft.hh 1.4.1.8 640))
  (olena/oln/transforms/wavelet_coeffs.hh (oln/i/34_wavelet_co 1.7 640))
  (integre/ntg/all.hh (oln/g/32_all.hh 1.10.1.8 640))
  (integre/ntg/real/behavior.hh (oln/g/31_behaviour. 1.13.1.15.1.1 640))

  (integre/ntg/utils/cast.hh (oln/i/26_cast.hh 1.3.1.12 640))
  (integre/ntg/vect/cplx_representation.hh (oln/i/3_cplx_repre 1.5 640))
  (integre/ntg/utils/debug.hh (oln/i/8_debug.hh 1.2.1.8 640))
  (integre/ntg/core/internal/global_ops_defs.hh (oln/g/26_global_ops 1.17 640))
  (integre/ntg/core/internal/global_ops.hh (oln/g/27_global_ops 1.11.1.14 640))
  (integre/ntg/core/internal/global_ops_traits.hh (oln/g/25_global_ops 1.7.1.10 640))
  (integre/ntg/color/hsi.hh (oln/i/20_hsi.hh 1.3.1.7 640))
  (integre/ntg/color/hsl.hh (oln/i/21_hsl.hh 1.3.1.4 640))
  (integre/ntg/color/hsv.hh (oln/i/22_hsv.hh 1.3.1.5 640))
  (integre/ntg/core/interval.hh (oln/g/22_interval.h 1.6.1.8 640))
  (integre/ntg/real/int_s.hh (oln/g/24_int_s.hh 1.16.1.16.1.1 640))
  (integre/ntg/real/int_u.hh (oln/g/23_int_u.hh 1.19.1.16.1.1 640))
  (integre/ntg/color/nrgb.hh (oln/i/19_nrgb.hh 1.5.1.6 640))





  (integre/ntg/real/optraits_builtin_int.hh (oln/g/18_optraits_b 1.6.1.8.1.1 640))






  (integre/ntg/real/optraits_real_defs.hh (oln/g/11_optraits_s 1.14.1.1 640))
  (integre/ntg/real/optraits_real.hh (oln/g/12_optraits_s 1.11.1.8.1.1 640))

  (integre/ntg/core/predecls.hh (oln/g/10_predecls.h 1.10.1.3.1.2 640))
  (integre/ntg/core/value.hh (oln/g/8_rec_value. 1.8.1.8.1.1 640))
  (integre/ntg/color/rgb.hh (oln/i/18_rgb.hh 1.3.1.4 640))

  (integre/ntg/core/type.hh (oln/g/6_type.hh 1.10 640))



  (integre/ntg/real/typetraits_builtin_int.hh (oln/g/3_typetraits 1.7.1.11.1.1 640))

  (integre/ntg/color/xyz.hh (oln/i/24_xyz.hh 1.3.1.7 640))
  (integre/ntg/color/yiq.hh (oln/i/23_yiq.hh 1.3.1.7 640))
  (integre/ntg/color/yuv.hh (oln/i/25_yuv.hh 1.3.1.7 640))
  (olena/oln/utils/copy.hh (oln/i/29_copy.hh 1.7 640))
  (olena/oln/utils/histogram.hh (oln/10_histogram. 1.6.1.14.1.6 640))
  (olena/oln/utils/stat.hh (oln/9_stat.hh 1.5.1.9 640))
  (olena/oln/utils/timer.hh (oln/8_timer.hh 1.8 640))
  (olena/tests/arith/Makefile.am (oln/o/43_Makefile.a 1.5.1.1 640))
  
  (olena/tests/arith/tests/min1 (oln/o/44_min1 1.1.1.8 640))
  (metalic/tests/check/check.hh (oln/e/40_check.hh 1.4 640))
  (olena/tests/check/data.cc (oln/f/5_data.cc 1.9 640))
  (olena/tests/check/data.hh (oln/f/6_data.hh 1.4 640))
  (metalic/tests/check/main.cc (oln/e/43_main.cc 1.1 640))
  (metalic/tests/check/Makefile.am (oln/e/44_Makefile.a 1.10 640))
  (metalic/tests/check/Makefile.check (oln/e/37_Makefile.c 1.8 640))
  (metalic/tests/check/Makefile.flags (oln/e/36_Makefile.f 1.12.1.3 640))
  (metalic/tests/check/srcdir.cc (oln/e/38_srcdir.cc 1.7 640))
  (metalic/tests/check/srcdir.hh (oln/e/35_srcdir.hh 1.6 640))
  (metalic/tests/check/verbose.cc (oln/e/41_verbose.cc 1.3 640))
  (metalic/tests/check/verbose.hh (oln/e/42_verbose.hh 1.3 640))

  (olena/tests/convert/convcomp.cc (oln/f/3_convcomp.c 1.9 640))
  (olena/tests/convert/convcomp.hh (oln/f/1_convcomp.h 1.10 640))
  (olena/tests/convert/Makefile.am (oln/f/0_Makefile.a 1.14 640))

  (olena/tests/convol/Makefile.am (oln/f/38_Makefile.a 1.13 640))
  (olena/tests/convol/tests/slow_sum_2d_1 (oln/f/41_slow_sum_2 1.2.1.5 640))
  (olena/tests/convol/tests/slow_sum_2d_2 (oln/f/40_slow_sum_2 1.2.1.4 640))
  (olena/tests/convol/tests/sobel_gradient (oln/f/45_sobel_grad 1.3.1.6 640))
  (olena/tests/convol/sum_on_random.pgm (oln/f/42_sum_on_ran 1.1 640) :no-keywords)

  (olena/tests/io/tests/2d (oln/e/47_2d.cc 1.7.1.7 640))
  (olena/tests/io/loadsave.hh (oln/e/48_loadsave.h 1.7.1.10 640))
  (olena/tests/io/Makefile.am (oln/e/49_Makefile.a 1.24 640))
  (olena/tests/io/tests/pretty (oln/i/42_pretty.cc 1.2 640))
  (olena/tests/io/tests/se_fail (oln/i/43_se_fail.cc 1.3 640))
  (olena/tests/io/tests/se_pass (oln/i/44_se_pass.cc 1.2 640))
  (olena/tests/Makefile.am (oln/e/45_Makefile.a 1.20 640))

  (metalic/tests/array/gen_test.cc (oln/f/34_gen_test.c 1.11.1.4 640))
  (metalic/tests/array/gen_test_utils/errors.cc (oln/f/33_errors.cc 1.1 640))
  (metalic/tests/array/gen_test_utils/errors.hh (oln/f/32_errors.hh 1.1 640))
  (metalic/tests/array/gen_test_utils/postlude (oln/f/31_postlude 1.1 640))
  (metalic/tests/array/gen_test_utils/prelude (oln/f/30_prelude 1.5 640))
  (metalic/tests/array/Makefile.am (oln/f/27_Makefile.a 1.6.1.2 640))
  (metalic/tests/array/test_array1d.cc (oln/f/26_test_array 1.5 640))
  (metalic/tests/array/test_array2d.cc (oln/f/25_test_array 1.5 640))
  (metalic/tests/array/test_array3d.cc (oln/f/24_test_array 1.5 640))
  (olena/tests/morpho/tests/edoc (oln/f/13_edoc.cc 1.4.1.5 640))
  (olena/tests/morpho/tests/extrkiller (oln/e/31_extrkiller 1.5.1.7 640))
  (olena/tests/morpho/Makefile.am (oln/e/32_Makefile.a 1.13 640))
  (olena/tests/morpho/tests/reconstruction (oln/e/34_reconstruc 1.12 640))
  (olena/tests/README (oln/f/4_README 1.6 640))
  (olena/tests/sanity/includes.test (oln/f/46_includes.t 1.8 750))
  (olena/tests/sanity/Makefile.am (oln/f/48_Makefile.a 1.4.1.2 640))
  (olena/tests/transforms/tests/dwt (oln/i/38_dwt.cc 1.8.1.5 640))
  (olena/tests/transforms/tests/fft (oln/i/37_fft.cc 1.6.1.4 640))
  (olena/tests/transforms/Makefile.am (oln/i/40_Makefile.a 1.12 640))
;;  (oln/tests/transforms/output () :directory)
  (integre/tests/types/Makefile.am (oln/h/5_Makefile.a 1.11 640))
  (integre/tests/types/runtests (oln/h/3_runtests 1.14.1.7 750))
  (integre/tests/types/tests/bin1 (oln/i/28_bin1 1.1 640))
  (integre/tests/types/tests/bin2 (oln/o/42_bin2 1.2 640))
  (integre/tests/types/tests/bin3 (oln/o/46_bin3 1.1 640))
  (integre/tests/types/tests/comp1 (oln/h/9_comp1 1.1 640))
  (integre/tests/types/tests/comp2 (oln/h/8_comp2 1.1 640))
  (integre/tests/types/tests/comp3 (oln/h/7_comp3 1.1 640))
  (integre/tests/types/tests/conv1 (oln/g/49_conv1 1.3 640))
  (integre/tests/types/tests/conv2 (oln/g/42_conv2 1.3 640))
  (integre/tests/types/tests/cplx1 (oln/i/2_cplx1 1.2 640))
  (integre/tests/types/tests/cplx2 (oln/i/1_cplx2 1.2 640))
  (integre/tests/types/tests/cplx3 (oln/i/0_cplx3 1.2 640))
  (integre/tests/types/tests/cplx4 (oln/h/51_cplx4 1.2 640))
  (integre/tests/types/tests/cplx5 (oln/i/7_cplx5 1.1 640))
  (integre/tests/types/tests/cplx6 (oln/i/6_cplx6 1.4 640))
  (integre/tests/types/tests/float1 (oln/h/12_float1 1.2 640))
  (integre/tests/types/tests/float2 (oln/h/40_float2 1.2 640))
  (integre/tests/types/tests/float_c1 (oln/h/13_float_c1 1.2 640))
  (integre/tests/types/tests/float_r1 (oln/h/10_float_r1 1.3 640))
  (integre/tests/types/tests/float_r2 (oln/h/11_float_r2 1.2 640))
  (integre/tests/types/tests/int1b (oln/g/48_int1b 1.1 640))
  (integre/tests/types/tests/int1 (oln/h/1_int1 1.1 640))
  (integre/tests/types/tests/int2 (oln/h/0_int2 1.1 640))
  (integre/tests/types/tests/int3 (oln/g/51_int3 1.1 640))
  (integre/tests/types/tests/int4b (oln/h/35_int4b 1.1 640))
  (integre/tests/types/tests/int4 (oln/g/50_int4 1.1 640))
  (integre/tests/types/tests/int5 (oln/g/47_int5 1.1 640))
  (integre/tests/types/tests/int6b (oln/g/45_int6b 1.1 640))
  (integre/tests/types/tests/int6c (oln/g/44_int6c 1.1 640))
  (integre/tests/types/tests/int6d (oln/g/43_int6d 1.1 640))
  (integre/tests/types/tests/int6 (oln/g/46_int6 1.1 640))
  (integre/tests/types/tests/int7 (oln/h/14_int7 1.1 640))
  (integre/tests/types/tests/int_s1 (oln/g/40_int_s1 1.1 640))
  (integre/tests/types/tests/int_s2b (oln/g/38_int_s2b 1.1 640))
  (integre/tests/types/tests/int_s2 (oln/g/39_int_s2 1.1 640))
  (integre/tests/types/tests/int_sc1 (oln/g/37_int_sc1 1.2 640))
  (integre/tests/types/tests/int_sc2 (oln/g/36_int_sc2 1.1 640))
  (integre/tests/types/tests/int_sc3 (oln/g/35_int_sc3 1.1 640))
  (integre/tests/types/tests/int_sc4 (oln/h/39_int_sc4 1.2 640))
  (integre/tests/types/tests/int_u1 (oln/h/22_int_u1 1.1 640))
  (integre/tests/types/tests/int_u2a (oln/h/17_int_u2a 1.1 640))
  (integre/tests/types/tests/int_u2b (oln/h/20_int_u2b 1.1 640))
  (integre/tests/types/tests/int_u2c (oln/h/21_int_u2c 1.1 640))
  (integre/tests/types/tests/int_u2d (oln/h/16_int_u2d 1.1 640))
  (integre/tests/types/tests/int_u2e (oln/h/38_int_u2e 1.1 640))
  (integre/tests/types/tests/int_u2f (oln/h/41_int_u2f 1.1 640))
  (integre/tests/types/tests/int_u3a (oln/h/18_int_u3a 1.1 640))
  (integre/tests/types/tests/int_u3b (oln/h/23_int_u3b 1.1 640))
  (integre/tests/types/tests/int_u4 (oln/h/19_int_u4 1.1 640))
  (integre/tests/types/tests/int_u6 (oln/h/37_int_u6 1.2 640))
  (integre/tests/types/tests/op1 (oln/h/15_op1 1.2 640))
  (integre/tests/types/tests/op2 (oln/h/6_op2 1.2 640))
  (integre/tests/types/tests/optrait1a (oln/h/25_optrait1a 1.3 640))
  (integre/tests/types/tests/optrait1b (oln/h/26_optrait1b 1.3 640))
  (integre/tests/types/tests/optrait2a (oln/h/28_optrait2a 1.4 640))
  (integre/tests/types/tests/optrait2b (oln/h/27_optrait2b 1.3 640))
  (integre/tests/types/tests/optrait3 (oln/h/24_optrait3 1.6 640))
  (integre/tests/types/tests/range1 (oln/h/34_range1 1.2 640))
  (integre/tests/types/tests/range2b (oln/h/36_range2b 1.1 640))
  (integre/tests/types/tests/range2 (oln/h/33_range2 1.1 640))
  (integre/tests/types/tests/range3b (oln/h/32_range3b 1.1 640))
  (integre/tests/types/tests/range3c (oln/h/30_range3c 1.1 640))
  (integre/tests/types/tests/range3d (oln/h/29_range3d 1.1 640))
  (integre/tests/types/tests/range3 (oln/h/31_range3 1.1 640))
  (integre/tests/types/tests/sizes (oln/i/15_sizes 1.1 640))
  (integre/tests/types/tests/unsafe1 (oln/h/2_unsafe1 1.1 640))
  (integre/tests/types/tests/unsafe2 (oln/g/41_unsafe2 1.1 640))
  (integre/tests/types/tests/vec1 (oln/h/49_vec1 1.1 640))
  (integre/tests/types/tests/vec2 (oln/h/48_vec2 1.1 640))
  (integre/tests/types/tests/vec3 (oln/h/47_vec3 1.1 640))
  (integre/tests/types/tests/vec4 (oln/h/46_vec4 1.1 640))
  (integre/tests/types/tests/vec5 (oln/h/45_vec5 1.2 640))
  (integre/tests/types/tests/vec6 (oln/h/44_vec6 1.1 640))
  (integre/tests/types/tests/vec7 (oln/h/50_vec7 1.1 640))

  (prj (oln.prj) :symlink)



  (tools () :directory)
  (tools/Makefile.am (oln/o/37_Makefile.a 1.7 640))
  (tools/swilena/configure.ac (oln/o/26_configure. 1.2 640))
  (tools/swilena/doc/Makefile.am (oln/n/39_Makefile.a 1.3 640))
  (tools/swilena/doc/swilena.texi (oln/n/40_swilena.te 1.1.1.4 600))
  
  ; (tools/swilena/java/Makefile.in ())
  (tools/swilena/Makefile.am (oln/o/25_Makefile.a 1.5 640))
;  (tools/swilena/python/Makefile.am (oln/n/44_Makefile.a 1.4 640))
;  (tools/swilena/python/typedefs.hh (oln/n/43_typedefs.h 1.3 640))
  (tools/swilena/README (oln/n/35_README 1.1 640))
  (tools/swilena/src () :directory)
;  (tools/swilena/src/lena128.pgm (oln/o/19_lena128.pg 1.1 640) :no-keywords)
;  (tools/swilena/src/lena2.pgm (oln/o/14_lena2.pgm 1.1 640) :no-keywords)
;  (tools/swilena/src/lena3.pgm (oln/o/5_lena3.pgm 1.1 640) :no-keywords)
;  (tools/swilena/src/lena3.pnm (oln/o/4_lena3.pnm 1.1 640) :no-keywords)
;  (tools/swilena/src/lena.pgm (oln/o/20_lena.pgm 1.1 640) :no-keywords)
;  (tools/swilena/src/Makefile.am (oln/o/23_Makefile.a 1.1 640))
  (tools/swilena/meta () :directory)
  (tools/swilena/meta/attic () :directory)
  (tools/swilena/meta/attic/swilena1d_convert.i (oln/n/48_swilena1d_ 1.1 640))
  (tools/swilena/meta/attic/swilena1d.i (oln/o/17_swilena1d. 1.1 640))
  (tools/swilena/meta/attic/swilena1d_morpho.i (oln/o/0_swilena1d_ 1.1 640))
  (tools/swilena/meta/attic/swilena2d_convert.i (oln/n/47_swilena2d_ 1.1 640))
  (tools/swilena/meta/attic/swilena2d.i (oln/o/2_swilena2d. 1.1 640))
  (tools/swilena/meta/attic/swilena2d_morpho.i (oln/n/51_swilena2d_ 1.1 640))
  (tools/swilena/meta/attic/swilena3d_convert.i (oln/n/46_swilena3d_ 1.1 640))
  (tools/swilena/meta/attic/swilena3d.i (oln/o/1_swilena3d. 1.1 640))
  (tools/swilena/meta/attic/swilena3d_morpho.i (oln/n/45_swilena3d_ 1.1 640))
  (tools/swilena/meta/attic/swilena_conversions.i (oln/o/15_swilena_co 1.1 640))
  (tools/swilena/meta/attic/swilena_convert_dim.i (oln/n/49_swilena_co 1.2 640))
  (tools/swilena/meta/attic/swilena_convoldefs.i (oln/o/10_swilena_co 1.2 640))
  (tools/swilena/meta/attic/swilena_dim.i (oln/o/22_swilena_di 1.3 640))
  (tools/swilena/meta/attic/swilena_dpoint.i (oln/o/13_swilena_dp 1.1 640))
  (tools/swilena/meta/attic/swilena_exceptions.i (oln/o/21_swilena_ex 1.1 640))
  (tools/swilena/meta/attic/swilena_image.i (oln/o/12_swilena_im 1.1 640))
  (tools/swilena/meta/attic/swilena.i (oln/o/24_swilena.i 1.2 640))
  (tools/swilena/meta/attic/swilena_meta_win.i (oln/o/7_swilena_me 1.1 640))
  (tools/swilena/meta/attic/swilena_morphodefs.i (oln/o/18_swilena_mo 1.2 640))
  (tools/swilena/meta/attic/swilena_morpho_dim.i (oln/n/50_swilena_mo 1.3 640))
  (tools/swilena/meta/attic/swilena_neighborhood.i (oln/o/8_swilena_ne 1.1 640))
  (tools/swilena/meta/attic/swilena_point.i (oln/o/11_swilena_po 1.1 640))
  (tools/swilena/meta/attic/swilena_typedefs.i (oln/o/16_swilena_ty 1.2 640))
  (tools/swilena/meta/attic/swilena_types.i (oln/o/3_swilena_ty 1.4 640))
  (tools/swilena/meta/attic/swilena_window.i (oln/o/9_swilena_wi 1.1 640))
  (tools/swilena/meta/attic/swilena_w_window.i (oln/o/6_swilena_w_ 1.1 640))
;  (tools/swilena/swilena.prj (oln/n/38_swilena.pr 1.1 640))
  (tools/swilena/TODO (oln/n/36_TODO 1.3 640))
  (tools/utilities/configure.ac (oln/o/27_configure. 1.2 640))
  (tools/utilities/Makefile.am (oln/g/2_Makefile.a 1.12.1.5 640))
  (tools/utilities/morpho/generate_morpho.sh (oln/i/30_generate_m 1.3.1.5.1.2 750))
  (tools/utilities/morpho/Makefile.am (oln/i/32_Makefile.a 1.9.1.5 640))
  (tools/utilities/morpho/morpho_template.cc (oln/i/33_morpho_tem 1.5.1.2.1.4 640))
  (tools/utilities/morpho/morpho_template_extrema.cc (oln/j/5_morpho_tem 1.1.1.2.1.3 640))
  (tools/utilities/morpho/morpho_template_gaussian.cc (oln/j/8_morpho_tem 1.1.1.2.1.4 640))
  (tools/utilities/morpho/morpho_template_watershed.cc (oln/j/6_morpho_tem 1.1.1.2.1.3 640))
  (tools/utilities/morpho/morpho_template_with_functor.cc (oln/j/10_morpho_tem 1.1.1.2.1.3 640))
  (tools/utilities/morpho/morpho_template_with_neighb.cc (oln/j/7_morpho_tem 1.1.1.2.1.3 640))
  (tools/utilities/morpho/morpho_template_with_twowin.cc (oln/j/9_morpho_tem 1.1.1.2.1.3 640))
  (tools/utilities/mosaic.cc (oln/g/0_mosaic.cc 1.5.1.5 640))

;; Files added by populate at Sun, 19 Jan 2003 21:48:10 +0100,
;; to version 7.25(w), by raph:

  (doc/demo/morpholena-wshed.cc (oln/p/5_morpholena 1.3 640))
  (doc/demo/morpholena-base.cc (oln/p/6_morpholena 1.4 640))
  (doc/demo/morpholena-grad.cc (oln/p/7_morpholena 1.3 640))
  (doc/demo/morpholena-hats.cc (oln/p/8_morpholena 1.4 640))

  (doc/demo/morpholena-hit-miss.cc (oln/p/10_morpholena 1.3 640))
  (doc/demo/morpholena-ops.cc (oln/p/11_morpholena 1.3 640))
  (doc/demo/morpholena-minima.cc (oln/p/12_morpholena 1.4 640))

  (doc/demo/convol-gaussian.cc (oln/p/14_morpholena 1.7 640))
  (doc/demo/morpholena-wshed-beucher.cc (oln/p/15_morpholena 1.3 640))


;; Files added by populate at Sun, 19 Jan 2003 21:48:32 +0100,
;; to version 7.25(w), by raph:

  (olena/oln/config/pconf-hh.in (oln/p/17_pconf-hh.i 1.1 640))

;; Files deleted by depopulate at Sun, 19 Jan 2003 21:50:24 +0100,
;; from version 7.25(w), by raph:

  ; (oln/oln/config/pconf.hh ())

;; Files deleted by depopulate at Sun, 19 Jan 2003 21:50:40 +0100,
;; from version 7.25(w), by raph:

  ; (oln/oln/config/pconf-inc.in ())

;; Files deleted by depopulate at Sun, 19 Jan 2003 21:56:13 +0100,
;; from version 7.25(w), by raph:

  ; (oln/tests/configure.ac ())

;; Files added by populate at Mon, 20 Jan 2003 11:43:58 +0100,
;; to version 7.27(w), by raph:

  (olena/conf/configure.ac (oln/p/23_configure. 1.5.1.2 640))
  (olena/conf/gen-scripts.sh (oln/p/24_gen-script 1.3.1.1 750))
  (olena/conf/oln-config.shin (oln/p/25_oln-config 1.1.1.2 640))
  (olena/conf/compilers.def (oln/p/26_compilers. 1.3 640))

;; Files added by populate at Tue, 21 Jan 2003 00:25:46 +0100,
;; to version 7.29(w), by raph:

  (tools/lib/Makefile.am (oln/p/27_Makefile.a 1.2 640))

;; Files added by populate at Tue, 21 Jan 2003 00:25:52 +0100,
;; to version 7.29(w), by raph:

  (tools/lib/getopt1.c (oln/p/28_getopt1.c 1.2 640))
  (tools/lib/oln_getopt.h (oln/p/29_getopt.h 1.2 640))
  (tools/lib/getopt.c (oln/p/30_getopt.c 1.2 640))

;; Files added by populate at Tue, 21 Jan 2003 00:33:22 +0100,
;; to version 7.29(w), by raph:

  (tools/lib/gettext.h (oln/p/31_gettext.h 1.1 640))

;; Files added by populate at Tue, 21 Jan 2003 00:57:11 +0100,
;; to version 7.29(w), by raph:

  (tools/lib/getopt.hh (oln/p/32_getopt.hh 1.2 640))

;; Files added by populate at Tue, 21 Jan 2003 09:12:30 +0100,
;; to version 7.29(w), by raph:

  (integre/ntg/config/math.hh (oln/p/33_math.hh 1.6 640))

;; Files deleted by depopulate at Wed, 22 Jan 2003 13:34:58 +0100,
;; from version 7.31(w), by raph:

  ; (component.m4 ())
  ; (oln-version.m4 ())

;; Files added by populate at Wed, 22 Jan 2003 18:36:01 +0100,
;; to version 7.33(w), by raph:

  (metalic/tests/check/compile.hh (oln/p/35_compile.hh 1.1 640))
  (metalic/tests/check/compile.cc (oln/p/36_compile.cc 1.1 640))

;; Files deleted by depopulate at Wed, 22 Jan 2003 18:58:45 +0100,
;; from version 7.33(w), by raph:

  ; (tools/configure.ac ())

;; Files deleted by depopulate at Wed, 22 Jan 2003 18:58:48 +0100,
;; from version 7.33(w), by raph:

  ; (doc/configure.ac ())

;; Files deleted by depopulate at Wed, 22 Jan 2003 18:58:51 +0100,
;; from version 7.33(w), by raph:

  ; (oln/configure.ac ())

;; Files added by populate at Thu, 23 Jan 2003 14:26:31 +0100,
;; to version 7.36(w), by raph:

  (config/oln-local.m4 (oln/p/37_oln-local. 1.7 640))

;; Files deleted by depopulate at Thu, 23 Jan 2003 14:57:33 +0100,
;; from version 7.37(w), by raph:

  ; (doc/demo/morpholena-fast-hats.cc ())

;; Files deleted by depopulate at Thu, 23 Jan 2003 14:57:58 +0100,
;; from version 7.37(w), by raph:

  ; (doc/demo/morpholena-minima-imp.cc ())
  ; (doc/demo/morpholena-opening-closing.cc ())

;; Files added by populate at Thu, 23 Jan 2003 15:43:23 +0100,
;; to version 7.39(w), by raph:

  (doc/dev/Makefile.am (oln/p/38_Makefile.a 1.6.1.4 640))

;; Files deleted by depopulate at Fri, 24 Jan 2003 10:54:23 +0100,
;; from version 7.40(w), by raph:

  ; (THANKS ())

;; Files added by populate at Fri, 24 Jan 2003 11:03:53 +0100,
;; to version 7.40(w), by raph:

  (doc/dev/biblio.texi (oln/p/39_biblio.tex 1.4 640))
  (doc/dev/thanks.texi (oln/p/40_thanks.tex 1.6 640))
  (doc/dev/abstract.texi (oln/p/41_abstract.t 1.7.1.2 640))

;; Files deleted by depopulate at Fri, 24 Jan 2003 11:04:25 +0100,
;; from version 7.40(w), by raph:

  ; (README ())

;; Files added by populate at Fri, 24 Jan 2003 14:34:30 +0100,
;; to version 7.40(w), by raph:

  (doc/dev/build.texi (oln/p/42_build.texi 1.11 640))

;; Files added by populate at Fri, 24 Jan 2003 14:34:47 +0100,
;; to version 7.40(w), by raph:

  (doc/dev/install.texi (oln/p/43_install.te 1.3 640))

  (doc/dev/faq.texi (oln/p/44_faq.texi 1.10 640))

;; Files added by populate at Sat, 25 Jan 2003 19:02:34 +0100,
;; to version 7.45(w), by raph:

  (doc/dev/srctree.texi (oln/p/45_srctree.te 1.6 640))
  (doc/dev/conf.texi (oln/q/2_conf.texi 1.4 640))

;; Files added by populate at Sat, 08 Feb 2003 13:38:09 +0100,
;; to version 7.48(w), by raph:

  (doc/ref/gen_filelists.sh (oln/q/4_gen_fileli 1.1 640))

;; Files added by populate at Mon, 10 Feb 2003 09:36:58 +0100,
;; to version 7.52(w), by raph:

  (doc/dev/design.texi (oln/q/5_design.tex 1.3 640))


;; Files added by populate at Tue, 04 Mar 2003 19:30:28 +0100,
;; to version 8.9(w), by jerome:

  (olena/oln/morpho/attribute_closing_opening.hh (oln/q/49_attribute_ 1.19 640))
  (olena/oln/morpho/attribute_union_find.hh (oln/q/50_attribute_ 1.15 640))

  (olena/tests/convol () :directory)
  (metalic/config (../config) :symlink)
  (metalic/m4 () :directory)
  (metalic/doc () :directory)
  (metalic/tests () :directory)
  (metalic/mlc () :directory)
  (metalic/lib (../lib) :symlink)
  (olena/lib (../lib) :symlink)
  (metalic/tests/Makefile.am (oln/q/31_Makefile.a 1.4 640))
  (metalic/Makefile.am (oln/q/32_Makefile.a 1.3 640))
  (metalic/mlc/Makefile.am (oln/q/33_Makefile.a 1.7 640))
  (integre () :directory)
  (integre/ntg () :directory)
  (integre/Makefile.am (oln/q/34_Makefile.a 1.3 640))
  (integre/ntg/Makefile.am (oln/q/36_Makefile.a 1.8.1.1 640))
  (olena/tests/check/defs.in (oln/q/37_defs.in 1.1 640))
  (olena/tests/check/Makefile.am (oln/q/38_Makefile.a 1.4 640))
  (olena/tests/check/Makefile.flags (oln/q/39_Makefile.f 1.4.1.1 640))
  (olena/tests/check/Makefile.check (oln/q/40_Makefile.c 1.4 640))
  (integre/tests/Makefile.am (oln/q/41_Makefile.a 1.4 640))
  (integre/tests/check/defs.in (oln/q/42_defs.in 1.1 640))
  (metalic/mlc/array/objs.hh (oln/q/45_objs.hh 1.3 640))
  (metalic/mlc/config/system.hh (oln/q/46_system.hh 1.2 640))
  (olena/oln/Makefile.am (oln/q/47_Makefile.a 1.3.1.1.1.6.1.7.1.2 640))
  (integre/ntg/config/system.hh (oln/q/48_system.hh 1.2 640))
  (metalic/tests/main/tests/is_a1 (oln/r/17_is_a1 1.3 640))
  (metalic/tests/main/tests/ensure3 (oln/r/18_ensure3 1.3 640))
  (metalic/tests/main/tests/ensure2 (oln/r/19_ensure2 1.3 640))
  (metalic/tests/main/tests/pow2sup2 (oln/r/20_pow2sup2 1.2 640))
  (metalic/tests/main/tests/ensure1 (oln/r/21_ensure1 1.2 640))
  (metalic/tests/main/tests/pow2sup1 (oln/r/22_pow2sup1 1.2 640))
  (metalic/tests/main/Makefile.am (oln/r/23_Makefile.a 1.2 640))
  
  (metalic/tests/check/defs.in (oln/r/25_defs.in 1.1 640))
;; Files added by populate at Wed, 19 Mar 2003 13:39:57 +0100,
;; to version 8.21(w), by sylvain:

  (olena/tests/topo/Makefile.am (oln/r/26_Makefile.a 1.3.1.3 640))
  (olena/tests/topo/tests/inter-pixel (oln/r/27_test-inter 1.6 640))
  (olena/tests/topo/tests/cmap (oln/r/28_test-cmap. 1.8 640))
  
  
  
  
  (olena/oln/topo/tarjan/union.hh (oln/r/33_union.hh 1.8 640))
  (olena/oln/topo/inter-pixel/inter-pixel.hh (oln/r/34_inter-pixe 1.12 640))
  (olena/oln/topo/tarjan/flat-zone.hh (oln/r/35_flat-zone. 1.9 640))
  (olena/oln/topo/combinatorial-map/cmap.hh (oln/r/36_cmap.hh 1.11 640))

;; Files added by populate at Thu, 20 Mar 2003 18:06:35 +0100,
;; to version 8.22(w), by sylvain:

  
  
  
  (olena/img/test-cmap.pgm (oln/r/40_test-cmap. 1.1 640) :no-keywords)

;; Files added by populate at Mon, 31 Mar 2003 15:17:00 +0200,
;; to version 8.26(w), by sylvain:

  (olena/oln/topo/combinatorial-map/internal/zeta.hh (oln/r/43_zeta.hh 1.3 640))
  (olena/oln/topo/inter-pixel/fwd-dir-iter.hh (oln/r/44_fwd-dir-it 1.4 640))
  (olena/oln/topo/inter-pixel/bkd-dir-iter.hh (oln/r/45_bkd-dir-it 1.4 640))
  (olena/oln/topo/inter-pixel/node.hh (oln/r/46_node.hh 1.4 640))
  (olena/oln/topo/inter-pixel/internal/dir-iter.hh (oln/r/47_dir-iter.h 1.5 640))
  (olena/oln/topo/inter-pixel/internal/dir.hh (oln/r/48_dir.hh 1.2 640))
  

;; Files added by populate at Wed, 09 Apr 2003 22:18:27 +0200,
;; to version 8.31(w), by nes:

  (doc/dev/upgrading.texi (oln/r/50_upgrading. 1.3 640))


  (integre/tests/types/tests/builtin1 (oln/s/7_builtin1 1.1 640))
  (olena/tests/core/tests/w_window (oln/s/8_w_window 1.1 640))
  
  (olena/tests/core/Makefile.am (oln/s/10_Makefile.a 1.7.1.2 640))
  (integre/tests/types/tests/int_u5c (oln/s/11_int_u5c 1.1 640))
;; Files added by populate at Tue, 06 May 2003 06:05:19 +0200,
;; to version 8.33(w), by raph:

  (tools/swilena/expand.sh (oln/s/25_expand.sh 1.12 750))

;; Files added by populate at Tue, 06 May 2003 06:05:41 +0200,
;; to version 8.33(w), by raph:

  (tools/swilena/meta/Makefile.am (oln/s/26_Makefile.a 1.3 640))

;; Files added by populate at Tue, 06 May 2003 06:05:43 +0200,
;; to version 8.33(w), by raph:

  (tools/swilena/meta/swilena_w_win.i (oln/s/27_swilena_w_ 1.2 640))
  (tools/swilena/meta/swilena_structelt.i (oln/s/28_swilena_st 1.3 640))
  (tools/swilena/meta/swilena_point.i (oln/s/29_swilena_po 1.3 640))
  
  
  
  (tools/swilena/meta/swilena_ntg.i (oln/s/33_swilena_nt 1.7 640))
  (tools/swilena/meta/swilena_morpho.i (oln/s/34_swilena_mo 1.2 640))
  (tools/swilena/meta/swilena_imagesize.i (oln/s/35_swilena_im 1.2 640))
  (tools/swilena/meta/swilena_image.i (oln/s/36_swilena_im 1.7 640))
  (tools/swilena/meta/swilena_exception.i (oln/s/37_swilena_ex 1.2 640))
  (tools/swilena/meta/swilena_describe.i (oln/s/38_swilena_de 1.3 640))
  (tools/swilena/meta/swilena_decl.i (oln/s/39_swilena_de 1.2 640))
  (tools/swilena/meta/swilena_core.i (oln/s/40_swilena_co 1.1 640))


  (integre/ntg/int.hh (oln/s/0_int.hh 1.3 640))
  (integre/ntg/float.hh (oln/s/1_float.hh 1.3 640))
  (integre/ntg/real/real_value.hh (oln/s/15_real_value 1.2.1.1 640))
  (integre/ntg/core/internal/traits.hh (oln/s/16_traits.hh 1.4.1.1 640))
  (integre/ntg/core/internal/macros.hh (oln/s/17_macros.hh 1.2 640))
  (integre/ntg/core/type_traits.hh (oln/s/18_type_trait 1.3 640))
  (integre/ntg/core/macros.hh (oln/s/19_macros.hh 1.9 640))
  (integre/ntg/core/abstract_hierarchy.hh (oln/s/20_abstract_h 1.2.1.2 640))
  (integre/ntg/basics.hh (oln/s/21_basics.hh 1.3.1.1 640))
  (integre/ntg/vect/vect_value.hh (oln/s/22_vect_value 1.2.1.1 640))
  (integre/ntg/enum/enum_value.hh (oln/s/23_enum_value 1.1.1.1 640))
  (integre/tests/types/tests/range4 (oln/s/24_range4 1.1 640))
  (integre/tests/utils/tests/debug1 (oln/s/41_debug1 1.3 640))
  
  (integre/tests/utils/Makefile.am (oln/s/43_Makefile.a 1.3 640))

  (integre/ntg/core/contract.hh (oln/s/45_contract.h 1.3 640))
  (integre/ntg/real/builtin_int.hh (oln/s/46_builtin_in 1.1 640))
  (integre/ntg/real/builtin_float.hh (oln/s/47_builtin_fl 1.2.1.2 640))
  (integre/ntg/real/builtin_properties.hh (oln/s/48_builtin_pr 1.1 640))
  (integre/ntg/enum/builtin_bool.hh (oln/s/50_builtin_bo 1.4.1.1 640))
  (integre/tests/sanity/includes.test (oln/s/51_includes.t 1.1 750))
  (integre/tests/sanity/Makefile.am (oln/t/0_Makefile.a 1.1 640))
  (metalic/tests/sanity/includes.test (oln/t/1_includes.t 1.1 750))
  (metalic/tests/sanity/Makefile.am (oln/t/2_Makefile.a 1.1 640))
  (integre/tests/types/tests/int_sc5 (oln/t/3_int_sc5 1.2 640))

;; Files added by populate at Mon, 02 Jun 2003 17:20:22 +0200,
;; to version 9.5(w), by burrus_n:

  (integre/ntg/vec.hh (oln/t/10_vec.hh 1.1 640))
  (integre/ntg/range.hh (oln/t/11_range.hh 1.1 640))
  (integre/ntg/cycle.hh (oln/t/12_cycle.hh 1.1 640))
  (integre/ntg/cplx.hh (oln/t/13_cplx.hh 1.1 640))
  (integre/ntg/color.hh (oln/t/14_color.hh 1.1 640))
  (integre/ntg/bin.hh (oln/t/15_bin.hh 1.1 640))

;; Files added by populate at Mon, 02 Jun 2003 17:25:14 +0200,
;; to version 9.7(w), by burrus_n:

  (integre/ntg/real/range.hh (oln/t/16_range.hh 1.3.1.1 640))
  (integre/ntg/real/cycle.hh (oln/t/17_cycle.hh 1.2.1.1 640))
  (integre/ntg/vect/vec.hh (oln/t/18_vec.hh 1.7.1.2 640))
  (integre/ntg/vect/cplx.hh (oln/t/19_cplx.hh 1.5 640))
  (integre/ntg/color/color.hh (oln/t/20_color.hh 1.6 640))
  (integre/ntg/enum/bin.hh (oln/t/21_bin.hh 1.5.1.1 640))

;; Files deleted by populate at Mon, 30 Jun 2003 20:01:55 +0200,
;; from version 9.10(w), by nes:

  ; (integre/tests/types/tests/debug1 ())

;; Files added by populate at Fri, 11 Jul 2003 18:21:00 +0200,
;; to version 9.11(w), by burrus_n:

  (olena/tests/core/tests/print_image (oln/t/22_print_imag 1.2 640))

;; Files added by populate at Sat, 12 Jul 2003 20:10:15 +0200,
;; to version 9.14(w), by burrus_n:

  (integre/tests/types/tests/char1 (oln/t/23_char1 1.1 600))
  (olena/tests/core/image_print.sh (oln/t/24_image_prin 1.2 640))


  (olena/oln/core/abstract/image.hh (oln/t/25_image.hh 1.23 640))
  (olena/oln/core/abstract/image_with_dim.hh (oln/t/26_image_with 1.20 600))
  (olena/oln/core/abstract/image_with_impl.hh (oln/t/27_image_with 1.14.1.9 640))
  (olena/oln/core/abstract/image_with_type.hh (oln/t/28_image_with 1.12 640))
  (olena/oln/core/impl/image_impl.hh (oln/t/29_image_impl 1.16 640))
  (olena/oln/core/impl/image_array.hh (oln/t/30_image_arra 1.14 640))
  (olena/tests/core/tests/image1 (oln/t/31_image1 1.4 640))
  (olena/oln/core/impl/image_array3d.hh (oln/t/32_image_arra 1.10 640))
  (olena/oln/core/impl/image_array2d.hh (oln/t/33_image_arra 1.11 640))
  (olena/oln/core/impl/image_array1d.hh (oln/t/34_image_arra 1.12 640))
  (olena/tests/core/tests/borders (oln/t/35_borders 1.3 640))
  (olena/tests/core/tests/clone (oln/t/36_clone 1.1 640))
  (olena/tests/core/tests/ref (oln/t/37_ref 1.3 640))
  (olena/oln/io/pnm_common.hh (oln/t/40_pnm_common 1.4 600))
  (olena/oln/io/image_base.hh (oln/t/41_image_base 1.4 600))
  (olena/oln/io/image_write.hh (oln/t/42_image_writ 1.9 600))
  (olena/oln/io/stream_wrapper.hh (oln/t/43_stream_wra 1.3.1.1 600))
  (olena/oln/io/utils.hh (oln/t/44_utils.hh 1.3 600))
  (olena/oln/io/image_read.hh (oln/t/45_image_read 1.9 600))
  (olena/tests/level/Makefile.am (oln/t/46_Makefile.a 1.3 600))
  (olena/tests/level/tests/cc (oln/t/47_cc.cc 1.1 600))
  (olena/tests/level/tests/compare (oln/t/48_compare.cc 1.1 600))
  (olena/tests/level/tests/connected (oln/t/49_connected. 1.2 600))
  (olena/tests/level/tests/invert (oln/t/50_invert.cc 1.2 600))
  (olena/tests/level/tests/set_level (oln/t/51_set_level. 1.1 600))
  (olena/tests/level/tests/threshold (oln/u/0_threshold. 1.1 600))
  (olena/tests/core/tests/window (oln/u/1_window 1.1 640))
  (olena/tests/core/tests/neighborhood (oln/u/2_neighborho 1.1 640))
  (olena/oln/core/abstract/window_base.hh (oln/u/3_window_bas 1.9 640))
  (olena/oln/core/abstract/windownd.hh (oln/u/4_windownd.h 1.7 640))
  (olena/oln/core/abstract/w_windownd.hh (oln/u/5_w_windownd 1.6 640))
  (olena/oln/core/abstract/neighborhoodnd.hh (oln/u/6_neighborho 1.6 640))
  (olena/tests/core/tests/traverse (oln/u/7_traverse 1.1 640))
  (integre/tests/types/tests/int_u7 (oln/u/8_int_u7 1.1 640))
  (olena/oln/io/pnm_read_data.hh (oln/u/9_pnm_read_d 1.5 640))
  (olena/oln/io/pnm_write_data.hh (oln/u/10_pnm_write_ 1.6 640))
  (olena/oln/io/image.hh (oln/u/11_image.hh 1.2 600))
  (olena/tests/convert/conv.cc (oln/u/12_conv.cc 1.2 640))
  (olena/tests/convert/conv.hh (oln/u/13_conv.hh 1.1 640))
  (olena/tests/io/tests/bin (oln/u/20_bin.cc 1.1 640))
  (olena/img/black.pbm (oln/u/21_black.pbm 1.1 640))
  (olena/img/white.pbm (oln/u/22_white.pbm 1.1 640) :no-keywords)
  (olena/tests/topo/tests/dmap (oln/u/23_test-dmap. 1.2 600))
  (olena/tests/core/multiple_sources_2.cc (oln/u/24_multiple_s 1.1 640))
  (olena/tests/core/multiple_sources_1.cc (oln/u/25_multiple_s 1.1 640))
  (olena/tests/utils/Makefile.am (oln/u/26_Makefile.a 1.2 600))
  (olena/tests/utils/tests/histogram (oln/u/27_histogram. 1.2.1.3 600))
  (olena/tests/utils/tests/stat (oln/u/28_stat.cc 1.2 600))
  (olena/tests/utils/tests/timer (oln/u/29_timer.cc 1.4 600))
  (olena/tests/topo/tests/tarjan (oln/u/30_test-tarja 1.1 600))
  (olena/oln/convert/abstract/conversion.hh (oln/u/31_conversion 1.4 640))
  (olena/tests/check/Makefile.runtests (oln/u/32_Makefile.r 1.2 600))
  (contrib/runtests (oln/u/33_runtests 1.4 700))
  (metalic/tests/check/Makefile.runtests (oln/u/34_Makefile.r 1.1 600))
  (integre/tests/check/Makefile.runtests (oln/u/35_Makefile.r 1.2 600))
  (integre/tests/check/Makefile.flags (oln/u/36_Makefile.f 1.1 600))
  (olena/tests/math/tests/macros (oln/u/37_macros 1.2 600))
  (olena/tests/math/Makefile.am (oln/u/38_Makefile.a 1.1 600))
  (olena/tests/io/tests/1d (oln/u/39_1d 1.2 640))
  (olena/img/lena1d.ppm (oln/u/40_lena1d.ppm 1.1 640))
  (olena/tests/core/tests/image_list (oln/u/41_image_list 1.1 600))
  (olena/tests/io/tests/3d (oln/u/42_3d 1.2 600))
  (olena/oln/io/pnm_read_2d.hh (oln/u/43_pnm_read_2 1.4 600))
  (olena/oln/io/pnm_write_2d.hh (oln/u/44_pnm_write_ 1.5 600))
  (olena/img/lena3d.ppm (oln/u/45_lena3d.ppm 1.1 600))
  (olena/tests/io/tests/se_3d (oln/u/46_se_3d 1.1 600))
  (olena/tests/io/tests/se_1d (oln/u/47_se_1d 1.1 600))
  (olena/img/wrong_3d.pbm (oln/u/48_wrong_3d.p 1.1 600) :no-keywords)
  (olena/img/se_3d.pbm (oln/u/49_se_3d.pbm 1.1 600) :no-keywords)
  (olena/img/se_1d.pbm (oln/u/50_se_1d.pbm 1.1 600))
  (olena/img/se9_1d.pbm (oln/u/51_se9_1d.pbm 1.1 600))
  (olena/tests/core/tests/label_images (oln/v/0_label_imag 1.1 600))
  (olena/oln/topo/combinatorial-map/internal/allfunc.hh (oln/v/1_allfunc.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/alpha.hh (oln/v/2_alpha.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/anyfunc.hh (oln/v/3_anyfunc.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/beta.hh (oln/v/5_beta.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/lambda.hh (oln/v/6_lambda.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/level.hh (oln/v/7_level.hh 1.2 600))
  (olena/oln/topo/combinatorial-map/internal/sigma.hh (oln/v/9_sigma.hh 1.2 600))
  (olena/oln/core/abstract/image_with_type_with_dim.hh (oln/v/11_image_with 1.5 600))
  (olena/tests/core/tests/image2 (oln/v/12_image2 1.2 600))
  (olena/tests/utils/tests/copy (oln/v/13_copy 1.1 600))
;; Files added by populate at Mon, 25 Aug 2003 13:48:55 +0200,
;; to version 10.9(w), by raph:

  (olena/conf/README (oln/v/14_README 1.1 640))

;; Files deleted by depopulate at Sun, 21 Sep 2003 22:59:12 +0200,
;; from version 10.19(w), by nes:

  ; (tools/swilena/java/Makefile.am ())

;; Files added by populate at Sun, 21 Sep 2003 22:59:15 +0200,
;; to version 10.19(w), by nes:

  (tools/swilena/python/tests/Makefile.am (oln/v/15_Makefile.a 1.2 600))
  (tools/swilena/python/tests/simple1.py (oln/v/16_simple1.py 1.4 700))
  (tools/swilena/ruby/Makefile.am (oln/v/17_Makefile.a 1.2 600))
  (tools/swilena/ruby/tests/Makefile.am (oln/v/18_Makefile.a 1.1 600))
  (tools/swilena/ruby/tests/simple1.rb (oln/v/19_simple1.rb 1.4 700))

;; Files added by populate at Mon, 22 Sep 2003 00:03:13 +0200,
;; to version 10.21(w), by nes:

  (tools/swilena/python/swilena_display.py (oln/v/20_swilena_di 1.1 600))
  (tools/swilena/ruby/swilena_display.rb (oln/v/21_swilena_di 1.1 700))

;; Files added by populate at Mon, 22 Sep 2003 00:32:14 +0200,
;; to version 10.21(w), by nes:

  (tools/swilena/doc/examples/ruby/simple.rb (oln/v/22_simple.rb 1.4 710))
  (tools/swilena/doc/examples/python/simple.py (oln/v/23_simple.py 1.4 710))


;; Files added by populate at Sat, 27 Sep 2003 18:32:26 +0200,
;; to version 10.24(w), by burrus_n:

  (tools/swilena/generate_morpho_instantiations.py (oln/v/24_generate_m 1.4 700))

;; Files deleted by populate at Sat, 27 Sep 2003 18:33:27 +0200,
;; from version 10.24(w), by nes:

  ; (tools/swilena/meta/swilena_ntg_cplx.i ())
  ; (tools/swilena/meta/swilena_ntg_int_s.i ())
  ; (tools/swilena/meta/swilena_ntg_int_u.i ())

;; Files added by populate at Mon, 29 Sep 2003 19:17:53 +0200,
;; to version 10.26(w), by nes:

  (tools/swilena/src/Makefile.am (oln/v/25_Makefile.a 1.1 640))

;; Files added by populate at Wed, 08 Oct 2003 11:13:23 +0200,
;; to version 10.27(w), by burrus_n:

  (olena/tests/morpho/tests/builtin_types (oln/v/30_builtin_ty 1.2 640))

;; Files added by populate at Sun, 02 Nov 2003 17:15:34 +0100,
;; to version 10.32(w), by nes:

  (olena/tests/core/tests/without_ntg (oln/v/31_without_nt 1.1 600))

;; Files added by populate at Mon, 03 Nov 2003 21:56:15 +0100,
;; to version 10.33(w), by burrus_n:

  (olena/tests/io/tests/headers (oln/v/32_headers 1.1 600))

;; Files added by populate at Fri, 07 Nov 2003 17:21:47 +0100,
;; to version 10.35(w), by burrus_n:

  (olena/oln/convert/cast.hh (oln/v/35_cast.hh 1.1 600))

;; Files added by populate at Fri, 07 Nov 2003 17:29:58 +0100,
;; to version 10.36(w), by burrus_n:

  (olena/tests/morpho/tests/overall_benchs (oln/v/36_overall_be 1.1 640))
  (olena/tests/core/tests/benchs (oln/v/37_benchs 1.1 600))

;; Files added by populate at Sun, 09 Nov 2003 02:01:01 +0100,
;; to version 10.38(w), by burrus_n:

  (tools/swilena/meta/swilena_ntg_macros.i (oln/v/39_swilena_nt 1.1 600))

;; Files added by populate at Mon, 10 Nov 2003 11:23:59 +0100,
;; to version 10.39(w), by burrus_n:

  (tools/swilena/python/tests/morpho.py (oln/v/47_morpho.py 1.1 700))
  (tools/swilena/meta/swilena_arith.i (oln/v/48_swilena_ar 1.1 640))
  (tools/swilena/meta/swilena_conversions.i (oln/v/49_swilena_co 1.1 600))
  (tools/swilena/generate_conversions_instantiations.py (oln/v/50_generate_c 1.1 700))
  (tools/swilena/generate_arith_instantiations.py (oln/v/51_generate_a 1.1 700))

;; Files added by populate at Mon, 10 Nov 2003 14:06:22 +0100,
;; to version 10.39(w), by burrus_n:

  (tools/swilena/python/tests/arith.py (oln/w/0_arith.py 1.1 750))
  (tools/swilena/python/tests/conversions.py (oln/w/1_conversion 1.1 750))

;; Files added by populate at Mon, 10 Nov 2003 14:10:01 +0100,
;; to version 10.40(w), by burrus_n:

  (tools/swilena/python/Makefile.am (oln/w/2_Makefile.a 1.1 640))
  (tools/swilena/python/swilena_all1d.py (oln/w/3_swilena_al 1.1 640))
  (tools/swilena/python/swilena_all2d.py (oln/w/4_swilena_al 1.1 640))
  (tools/swilena/python/swilena_all3d.py (oln/w/5_swilena_al 1.1 640))

;; Files added by populate at Wed, 26 Nov 2003 11:35:29 +0100,
;; to version 10.41(w), by burrus_n:

  (integre/tests/types/tests/int_u8 (oln/w/6_int_u8 1.1 640))

;; Files added by populate at Mon, 08 Dec 2003 10:54:08 +0100,
;; to version 10.45(w), by david:

  (doc/hierarchies/structelt.dia (oln/w/7_structelt. 1.1 640) :no-keywords)
  (doc/hierarchies/point.dia (oln/w/8_point.dia 1.1 640) :no-keywords)
  (doc/hierarchies/new_olena_model.dia (oln/w/9_new_olena_ 1.1 640) :no-keywords)
  (doc/hierarchies/misc.dia (oln/w/10_misc.dia 1.1 640) :no-keywords)
  (doc/hierarchies/labels.dia (oln/w/11_labels.dia 1.1 640) :no-keywords)
  (doc/hierarchies/iter.dia (oln/w/12_iter.dia 1.1 640) :no-keywords)
  (doc/hierarchies/implementation.dia (oln/w/13_implementa 1.1 640))

;; Files deleted by depopulate at Thu, 22 Jan 2004 21:08:59 +0100,
;; from version 10.48(w), by palma_g:

  ; (olena/oln/convert/nrgbhsi.hh ())
  ; (olena/oln/convert/nrgbhsl.hh ())
  ; (olena/oln/convert/nrgbhsv.hh ())
  ; (olena/oln/convert/nrgbyiq.hh ())
  ; (olena/oln/convert/nrgbyuv.hh ())

;; Files added by populate at Thu, 22 Jan 2004 21:09:49 +0100,
;; to version 10.48(w), by palma_g:

  (olena/oln/convert/rgbhsv.hh (oln/j/35_rgbhsv.hh 1.1 644))
  (olena/oln/convert/rgbhsl.hh (oln/j/36_rgbhsl.hh 1.1 644))
  (olena/oln/convert/rgbhsi.hh (oln/j/37_rgbhsi.hh 1.1 644))
  (olena/oln/convert/rgbyuv.hh (oln/j/38_rgbyuv.hh 1.1 644))
  (olena/oln/convert/rgbyiq.hh (oln/j/39_rgbyiq.hh 1.1 644))


  (olena/oln/snakes/snakes_base.hxx (oln/f/11_snakes_bas 1.1 644))
  (olena/oln/snakes/snakes_base.hh (oln/f/50_snakes_bas 1.2 644))
  (olena/oln/snakes/energies.hxx (oln/j/21_energies.h 1.1 644))
  (olena/oln/snakes/energies.hh (oln/j/22_energies.h 1.2 644))
  (olena/oln/snakes/segment.hxx (oln/j/23_segment.hx 1.1 644))
  (olena/oln/snakes/greedy.hxx (oln/j/24_greedy.hxx 1.1 644))
  (olena/oln/snakes/greedy.hh (oln/j/25_greedy.hh 1.2 644))
  (olena/oln/snakes/node.hh (oln/j/32_node.hh 1.2 644))
  (olena/oln/snakes/node.hxx (oln/j/33_node.hxx 1.1 644))
  (olena/oln/snakes/segment.hh (oln/j/34_segment.hh 1.2 644))
;; Files added by populate at Fri, 30 Jan 2004 10:19:55 +0100,
;; to version 10.56(w), by palma_g:

  (olena/tests/convol/tests/uniform2_gauss (oln/j/40_uniform2_g 1.1 644))
  (olena/tests/convol/tests/uniform_gauss (oln/j/41_uniform_ga 1.2 644))


  (olena/oln/convert/value_to_point.hh (oln/j/43_value_to_p 1.2 644))

  (olena/tests/morpho/tests/area (oln/j/44_area 1.1 644))
;; Files added by populate at Fri, 06 Feb 2004 16:00:19 +0100,
;; to version 10.57(w), by palma_g:

  (olena/oln/morpho/attributes.hh (oln/j/45_attributes 1.7 644))

;; Files added by populate at Tue, 10 Feb 2004 15:26:15 +0100,
;; to version 10.62(w), by palma_g:

  (olena/oln/core/abstract/behavior.hh (oln/j/46_behavior.h 1.3 644))

;; Files added by populate at Tue, 10 Feb 2004 15:26:20 +0100,
;; to version 10.62(w), by palma_g:

  (olena/oln/core/behavior.hh (oln/j/47_behavior.h 1.2 644))


  (olena/oln/morpho/attribute_closing_opening_map.hxx (oln/j/48_attribute_ 1.2 644))
  (olena/oln/morpho/attribute_closing_opening_map.hh (oln/j/49_attribute_ 1.6 600))
  (olena/oln/utils/special_points.hh (oln/j/50_special_po 1.1 644))
  (olena/tests/morpho/tests/attribute (oln/j/51_attribute 1.3 644))
;; Files added by populate at Mon, 16 Feb 2004 18:59:27 +0100,
;; to version 10.64(w), by palma_g:

  (olena/tests/morpho/tests/attr_op_cl (oln/k/0_attr_op_cl 1.3 644))


  (doc/ref/exdoc.pl (oln/v/26_exdoc.pl 1.3 755))
  (doc/ref/doxygen.config.in (oln/v/29_doxygen.co 1.2 644))
  (doc/ref/exdoc.mk.in (oln/k/4_exdoc.mk.i 1.1 644))
  
  (doc/ref/img_conv.pl (oln/k/6_img_conv.p 1.2 700))
;; Files deleted by depopulate at Wed, 25 Feb 2004 16:41:09 +0100,
;; from version 10.67(w), by palma_g:

  ; (doc/ref/exdoc.config.in ())

;; Files added by populate at Wed, 25 Feb 2004 16:41:16 +0100,
;; to version 10.67(w), by palma_g:

  (doc/ref/out/exdoc.config.in (oln/k/7_exdoc.conf 1.2 644))

;; Files deleted by depopulate at Tue, 09 Mar 2004 10:41:51 +0100,
;; from version 10.70(w), by palma_g:

  ; (doc/ref/html () :directory)
)
(Merge-Parents
  (10.72 complete
    (olena/ChangeLog olena/ChangeLog olena/ChangeLog r) (olena/oln/morpho/attribute_closing_opening.hh olena/oln/morpho/attribute_closing_opening.hh olena/oln/morpho/attribute_closing_opening.hh m)
    (olena/oln/snakes/snakes_base.hh olena/oln/snakes/snakes_base.hh olena/oln/snakes/snakes_base.hh r) (olena/oln/snakes/energies.hh olena/oln/snakes/energies.hh olena/oln/snakes/energies.hh r)
    (olena/oln/snakes/greedy.hh olena/oln/snakes/greedy.hh olena/oln/snakes/greedy.hh r) (olena/oln/snakes/node.hh olena/oln/snakes/node.hh olena/oln/snakes/node.hh r)
    (olena/oln/snakes/segment.hh olena/oln/snakes/segment.hh olena/oln/snakes/segment.hh r) (olena/oln/morpho/attribute_closing_opening_map.hh olena/oln/morpho/attribute_closing_opening_map.hh olena/oln/morpho/attribute_closing_opening_map.hh m))
  (10.75 complete
    (olena/ChangeLog olena/ChangeLog olena/ChangeLog r) (olena/oln/core/abstract/dpoint.hh olena/oln/core/abstract/dpoint.hh olena/oln/core/abstract/dpoint.hh r)
    (olena/oln/core/abstract/image_size.hh olena/oln/core/abstract/image_size.hh olena/oln/core/abstract/image_size.hh r) (olena/oln/core/abstract/point.hh olena/oln/core/abstract/point.hh olena/oln/core/abstract/point.hh r)
    (olena/oln/level/cc.hh olena/oln/level/cc.hh olena/oln/level/cc.hh r) (olena/oln/level/compare.hh olena/oln/level/compare.hh olena/oln/level/compare.hh r)
    (olena/oln/level/connected.hh olena/oln/level/connected.hh olena/oln/level/connected.hh r) (olena/oln/level/fill.hh olena/oln/level/fill.hh olena/oln/level/fill.hh r)
    (olena/oln/level/invert.hh olena/oln/level/invert.hh olena/oln/level/invert.hh r) (olena/oln/level/lut.hh olena/oln/level/lut.hh olena/oln/level/lut.hh r)
    (olena/oln/level/set_level.hh olena/oln/level/set_level.hh olena/oln/level/set_level.hh r) (olena/oln/level/threshold.hh olena/oln/level/threshold.hh olena/oln/level/threshold.hh r)
    (olena/oln/core/abstract/image.hh olena/oln/core/abstract/image.hh olena/oln/core/abstract/image.hh r) (olena/oln/core/abstract/image_with_dim.hh olena/oln/core/abstract/image_with_dim.hh olena/oln/core/abstract/image_with_dim.hh r)
    (olena/oln/core/abstract/image_with_impl.hh olena/oln/core/abstract/image_with_impl.hh olena/oln/core/abstract/image_with_impl.hh r) (olena/oln/core/abstract/image_with_type.hh olena/oln/core/abstract/image_with_type.hh olena/oln/core/abstract/image_with_type.hh r)
    (olena/oln/core/abstract/image_with_type_with_dim.hh olena/oln/core/abstract/image_with_type_with_dim.hh olena/oln/core/abstract/image_with_type_with_dim.hh r) (olena/oln/core/abstract/behavior.hh olena/oln/core/abstract/behavior.hh olena/oln/core/abstract/behavior.hh r))
  (10.76 complete
    (olena/ChangeLog olena/ChangeLog olena/ChangeLog r) (olena/oln/core/abstract/image.hh olena/oln/core/abstract/image.hh olena/oln/core/abstract/image.hh r)
    (olena/oln/core/abstract/image_with_dim.hh olena/oln/core/abstract/image_with_dim.hh olena/oln/core/abstract/image_with_dim.hh m) 
  )
)
(New-Merge-Parents)
