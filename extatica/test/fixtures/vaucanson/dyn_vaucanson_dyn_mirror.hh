namespace dyn {
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      fun  xml2str("dyn::vcsn::xml::xml2str", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/xml/strings.hh");
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct myDOMErrorHandler {
        ctor myDOMErrorHandler("vcsn::xml::myDOMErrorHandler");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct xerces_parser {
        ctor xerces_parser("vcsn::xml::xerces_parser");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace z_automaton {
      fun  automaton_t("dyn::vcsn::z_automaton::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/z_automaton.hh");
    } // end of namespace z_automaton
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct TropicalSemiring {
        ctor TropicalSemiring("vcsn::algebra::TropicalSemiring");
      // };
    } // end of namespace algebra
    namespace algebra {
      // struct TropicalMin {
        ctor TropicalMin("vcsn::algebra::TropicalMin");
      // };
      // struct TropicalMax {
        ctor TropicalMax("vcsn::algebra::TropicalMax");
      // };
      // struct TropicalSemiring {
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace z_max_plus_automaton {
      fun  automaton_t("dyn::vcsn::z_max_plus_automaton::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/z_max_plus_automaton.hh");
    } // end of namespace z_max_plus_automaton
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace z_min_plus_automaton {
      fun  automaton_t("dyn::vcsn::z_min_plus_automaton::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/z_min_plus_automaton.hh");
    } // end of namespace z_min_plus_automaton
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace r_automaton {
      fun  automaton_t("dyn::vcsn::r_automaton::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/r_automaton.hh");
    } // end of namespace r_automaton
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct Transducer {
      ctor Transducer("vcsn::Transducer");
    // };
    // struct input_projection_helper {
      ctor input_projection_helper("vcsn::input_projection_helper");
    // };
    // struct output_projection_helper {
      ctor output_projection_helper("vcsn::output_projection_helper");
    // };
    // struct identity_transducer_helper {
      ctor identity_transducer_helper("vcsn::identity_transducer_helper");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace fmp_transducer {
    } // end of namespace fmp_transducer
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
      fun  automaton_t("dyn::vcsn::VCSN_CONTEXT_NAMESPACE::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/contexts/transducer.thh");
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace boolean_transducer {
    } // end of namespace boolean_transducer
  } // end of namespace vcsn
  namespace vcsn {
    namespace boolean_transducer {
      fun  automaton_t("dyn::vcsn::boolean_transducer::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/boolean_transducer.hh");
    } // end of namespace boolean_transducer
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      namespace tools {
      } // end of namespace tools
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct xml_chooser_base {
        ctor xml_chooser_base("vcsn::xml::xml_chooser_base");
      // };
      // struct xml_chooser {
        ctor xml_chooser("vcsn::xml::xml_chooser");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct reference_pair {
        ctor reference_pair("vcsn::xml::reference_pair");
      // };
      // struct Node {
        ctor Node("vcsn::xml::Node");
      // };
      // struct automatonNode {
        ctor automatonNode("vcsn::xml::automatonNode");
      // };
      // struct transducerNode {
        ctor transducerNode("vcsn::xml::transducerNode");
      // };
      // struct typeNode {
        ctor typeNode("vcsn::xml::typeNode");
      // };
      // struct contentNode {
        ctor contentNode("vcsn::xml::contentNode");
      // };
      // struct statesNode {
        ctor statesNode("vcsn::xml::statesNode");
      // };
      // struct transitionsNode {
        ctor transitionsNode("vcsn::xml::transitionsNode");
      // };
      // struct stateNode {
        ctor stateNode("vcsn::xml::stateNode");
      // };
      // struct transitionNode {
        ctor transitionNode("vcsn::xml::transitionNode");
      // };
      // struct initialNode {
        ctor initialNode("vcsn::xml::initialNode");
      // };
      // struct finalNode {
        ctor finalNode("vcsn::xml::finalNode");
      // };
      // struct semiringNode {
        ctor semiringNode("vcsn::xml::semiringNode");
      // };
      // struct monoidNode {
        ctor monoidNode("vcsn::xml::monoidNode");
      // };
      // struct freemonoidNode {
        ctor freemonoidNode("vcsn::xml::freemonoidNode");
      // };
      // struct generatorNode {
        ctor generatorNode("vcsn::xml::generatorNode");
      // };
      // struct geometryNode {
        ctor geometryNode("vcsn::xml::geometryNode");
      // };
      // struct drawingNode {
        ctor drawingNode("vcsn::xml::drawingNode");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct xml_converter {
        ctor xml_converter("vcsn::xml::xml_converter");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace xml {
      // struct XML {
        ctor XML("vcsn::xml::XML");
      // };
    } // end of namespace xml
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct AlphabetSet {
        ctor AlphabetSet("vcsn::algebra::AlphabetSet");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct FreeMonoid {
        ctor FreeMonoid("vcsn::algebra::FreeMonoid");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace utility {
    // struct generic_int_type {
      ctor generic_int_type("utility::generic_int_type");
    // };
    // struct char_traits {
      ctor char_traits("utility::char_traits");
    // };
  } // end of namespace utility
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct NumericalSemiring {
        ctor NumericalSemiring("vcsn::algebra::NumericalSemiring");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    fun  op_can_choose_non_starable("dyn::vcsn::op_can_choose_non_starable", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  op_choose_starable("dyn::vcsn::op_choose_starable", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  op_choose_non_starable("dyn::vcsn::op_choose_non_starable", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  op_mul("dyn::vcsn::op_mul", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    proc op_in_add("dyn::vcsn::op_in_add", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  op_add("dyn::vcsn::op_add", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  identity_value("dyn::vcsn::identity_value", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  zero_value("dyn::vcsn::zero_value", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    fun  op_starable("dyn::vcsn::op_starable", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
    proc op_in_star("dyn::vcsn::op_in_star", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/numerical_semiring.hh");
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct DefaultTransposeFun {
        ctor DefaultTransposeFun("vcsn::algebra::DefaultTransposeFun");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace utility {
  } // end of namespace utility
  namespace std {
  } // end of namespace std
  namespace utility {
  } // end of namespace utility
  namespace vcsn {
    namespace algebra {
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace std {
  } // end of namespace std
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
      // struct setpm {
        ctor setpm("vcsn::rat::setpm");
      // };
      fun  getpm("dyn::vcsn::rat::getpm", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/series/rat/dump_visitor.hh");
      // struct setzero {
        ctor setzero("vcsn::rat::setzero");
      // };
      // struct setid {
        ctor setid("vcsn::rat::setid");
      // };
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct Automata {
      ctor Automata("vcsn::Automata");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct TransducerBase {
      ctor TransducerBase("vcsn::TransducerBase");
    // };
    // struct transducer_traits {
      ctor transducer_traits("vcsn::transducer_traits");
    // };
    // struct extension_traits {
      ctor extension_traits("vcsn::extension_traits");
    // };
    // struct projection_traits {
      ctor projection_traits("vcsn::projection_traits");
    // };
    // struct output_projection_traits {
      ctor output_projection_traits("vcsn::output_projection_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    // struct labels_are_letters {
      ctor labels_are_letters("vcsn::labels_are_letters");
    // };
    // struct labels_are_words {
      ctor labels_are_words("vcsn::labels_are_words");
    // };
    // struct labels_are_series {
      ctor labels_are_series("vcsn::labels_are_series");
    // };
    // struct labels_are_couples {
      ctor labels_are_couples("vcsn::labels_are_couples");
    // };
    // struct LabelOf {
      ctor LabelOf("vcsn::LabelOf");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    // struct NoTag {
      ctor NoTag("vcsn::NoTag");
    // };
  } // end of namespace vcsn
  fun  operator_equal("dyn::operator_equal", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/automata/concept/tags.hh");
  fun  operator_not_equal("dyn::operator_not_equal", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/automata/concept/tags.hh");
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct geometry {
      ctor geometry("vcsn::geometry");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    // struct edge_value {
      ctor edge_value("vcsn::edge_value");
    // };
    // struct state_value {
      ctor state_value("vcsn::state_value");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct generalized_traits {
      ctor generalized_traits("vcsn::generalized_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace io {
      // struct automaton_saver_ {
        ctor automaton_saver_("vcsn::io::automaton_saver_");
      // };
      // struct string_out {
        ctor string_out("vcsn::io::string_out");
      // };
    } // end of namespace io
    namespace io {
      // struct automaton_loader_ {
        ctor automaton_loader_("vcsn::io::automaton_loader_");
      // };
    } // end of namespace io
  } // end of namespace vcsn
  namespace vcsn {
    namespace io {
      // struct dot {
        ctor dot("vcsn::io::dot");
      // };
      // struct transducer_dot {
        ctor transducer_dot("vcsn::io::transducer_dot");
      // };
    } // end of namespace io
  } // end of namespace vcsn
  namespace vcsn {
    namespace tools {
    } // end of namespace tools
  } // end of namespace vcsn
  namespace vcsn {
    namespace algorithm_patterns {
      // struct Comparator {
        ctor Comparator("vcsn::algorithm_patterns::Comparator");
      // };
    } // end of namespace algorithm_patterns
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct reference_type {
      ctor reference_type("vcsn::reference_type");
    // };
    // struct iterator_type {
      ctor iterator_type("vcsn::iterator_type");
    // };
    // struct PartialExp {
      // struct internal_iterator {
        ctor internal_iterator("vcsn::PartialExp::internal_iterator");
      // };
      ctor PartialExp("vcsn::PartialExp");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace VCSN_CONTEXT_NAMESPACE {
      fun  aut_to_exp("dyn::vcsn::VCSN_CONTEXT_NAMESPACE::aut_to_exp", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/contexts/automaton_functions.thh");
    } // end of namespace VCSN_CONTEXT_NAMESPACE
  } // end of namespace vcsn
  namespace vcsn {
    namespace boolean_automaton {
      fun  automaton_t("dyn::vcsn::boolean_automaton::automaton_t", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/boolean_automaton.hh");
    } // end of namespace boolean_automaton
  } // end of namespace vcsn
  namespace vcsn {
    // struct dynamic_traits {
      ctor dynamic_traits("vcsn::dynamic_traits");
    // };
    // struct SyntacticDecorator {
      ctor SyntacticDecorator("vcsn::SyntacticDecorator");
    // };
    // struct MetaElement {
      ctor MetaElement("vcsn::MetaElement");
    // };
    // struct Element {
      ctor Element("vcsn::Element");
    // };
    // struct default_slot_tag {
      ctor default_slot_tag("vcsn::default_slot_tag");
    // };
    // struct SetSlot {
      ctor SetSlot("vcsn::SetSlot");
    // };
    // struct Structure {
      ctor Structure("vcsn::Structure");
    // };
    // struct virtual_types {
      ctor virtual_types("vcsn::virtual_types");
    // };
    // struct undefined_type {
      ctor undefined_type("vcsn::undefined_type");
    // };
  } // end of namespace vcsn
  namespace utility {
    namespace unique {
      // struct UniqueListBase {
        ctor UniqueListBase("utility::unique::UniqueListBase");
      // };
      // struct uniquelist {
        ctor uniquelist("utility::unique::uniquelist");
      // };
      // struct UniqueMap {
        // struct TiSlot {
          ctor TiSlot("utility::unique::UniqueMap::TiSlot");
        // };
        ctor UniqueMap("utility::unique::UniqueMap");
      // };
      // struct unifiable {
        ctor unifiable("utility::unique::unifiable");
      // };
    } // end of namespace unique
  } // end of namespace utility
  namespace vcsn {
    // struct Structure {
    // };
  } // end of namespace vcsn
  namespace utility {
    namespace contract {
      proc trap("dyn::utility::contract::trap", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/misc/contract.hh");
      // struct fail {
        ctor fail("utility::contract::fail");
      // };
    } // end of namespace contract
  } // end of namespace utility
  namespace vcsn {
    // struct SyntacticDecorator {
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct op_add_traits {
      ctor op_add_traits("vcsn::op_add_traits");
    // };
    // struct op_sub_traits {
      ctor op_sub_traits("vcsn::op_sub_traits");
    // };
    // struct op_mul_traits {
      ctor op_mul_traits("vcsn::op_mul_traits");
    // };
    // struct op_div_traits {
      ctor op_div_traits("vcsn::op_div_traits");
    // };
    // struct op_mod_traits {
      ctor op_mod_traits("vcsn::op_mod_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace std {
  } // end of namespace std
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct SetSlotAttribute {
      ctor SetSlotAttribute("vcsn::SetSlotAttribute");
    // };
    // struct SetSlot {
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct mul_kind {
        ctor mul_kind("vcsn::algebra::mul_kind");
      // };
      // struct add_kind {
        ctor add_kind("vcsn::algebra::add_kind");
      // };
      // struct SemigroupBase {
        ctor SemigroupBase("vcsn::algebra::SemigroupBase");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct MonoidBase {
        ctor MonoidBase("vcsn::algebra::MonoidBase");
      // };
      // struct identity_as {
        ctor identity_as("vcsn::algebra::identity_as");
      // };
      // struct zero_as {
        ctor zero_as("vcsn::algebra::zero_as");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct SemiringBase {
        ctor SemiringBase("vcsn::algebra::SemiringBase");
      // };
    } // end of namespace algebra
    // struct op_star_traits {
      ctor op_star_traits("vcsn::op_star_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    // struct op_begin_traits {
      ctor op_begin_traits("vcsn::op_begin_traits");
    // };
    // struct op_rbegin_traits {
      ctor op_rbegin_traits("vcsn::op_rbegin_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct static_char_interval {
        ctor static_char_interval("vcsn::algebra::static_char_interval");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace utility {
    // struct limits {
      ctor limits("utility::limits");
    // };
  } // end of namespace utility
  namespace vcsn {
    namespace algebra {
      fun  operator_push("dyn::vcsn::algebra::operator_push", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/rational_number.hh");
      fun  gcd("dyn::vcsn::algebra::gcd", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/rational_number.hh");
      fun  lcm("dyn::vcsn::algebra::lcm", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/algebra/implementation/semiring/rational_number.hh");
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace std {
  } // end of namespace std
  namespace utility {
  } // end of namespace utility
  namespace utility {
    namespace random {
      fun  generate_letter("dyn::utility::random::generate_letter", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/misc/random.hh");
      fun  generate_digit("dyn::utility::random::generate_digit", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/misc/random.hh");
    } // end of namespace random
  } // end of namespace utility
  namespace vcsn {
    namespace algebra {
      // struct AlphabetSetBase {
        ctor AlphabetSetBase("vcsn::algebra::AlphabetSetBase");
      // };
      // struct alphabet_traits {
        ctor alphabet_traits("vcsn::algebra::alphabet_traits");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace utility {
    // struct iomanip {
      ctor iomanip("utility::iomanip");
    // };
  } // end of namespace utility
  namespace vcsn {
    namespace tools {
      fun  usual_escaped_characters("dyn::vcsn::tools::usual_escaped_characters", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/tools/usual_escaped_characters.hh");
    } // end of namespace tools
  } // end of namespace vcsn
  namespace utility {
    // struct escaper {
      ctor escaper("utility::escaper");
    // };
    // struct setesc {
      ctor setesc("utility::setesc");
    // };
    fun  getesc("dyn::utility::getesc", "/home/lrde/lrde-2006/pouill_n/w/oln/prototypes/seminar_dynamic_static_bridge/test/vaucanson/sources/include/vaucanson/misc/escaper.hh");
  } // end of namespace utility
  namespace vcsn {
    namespace algebra {
      // struct FreeMonoidBase {
        ctor FreeMonoidBase("vcsn::algebra::FreeMonoidBase");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct SeriesBase {
        ctor SeriesBase("vcsn::algebra::SeriesBase");
      // };
      // struct series_traits {
        ctor series_traits("vcsn::algebra::series_traits");
      // };
      // struct mute_series_impl {
        ctor mute_series_impl("vcsn::algebra::mute_series_impl");
      // };
      // struct mute_series_traits {
        ctor mute_series_traits("vcsn::algebra::mute_series_traits");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct semiring_slot_tag {
        ctor semiring_slot_tag("vcsn::algebra::semiring_slot_tag");
      // };
      // struct monoid_slot_tag {
        ctor monoid_slot_tag("vcsn::algebra::monoid_slot_tag");
      // };
      // struct Series {
        ctor Series("vcsn::algebra::Series");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace vcsn {
    namespace rat {
    } // end of namespace rat
  } // end of namespace vcsn
  namespace utility {
    // struct DeferrerDebugPart {
      ctor DeferrerDebugPart("utility::DeferrerDebugPart");
    // };
    // struct Deferrer {
      ctor Deferrer("utility::Deferrer");
    // };
  } // end of namespace utility
  namespace vcsn {
    namespace algebra {
      // struct DispatchFunction {
        ctor DispatchFunction("vcsn::algebra::DispatchFunction");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    namespace algebra {
      // struct BinaryOp {
        ctor BinaryOp("vcsn::algebra::BinaryOp");
      // };
      // struct UnaryOp {
        ctor UnaryOp("vcsn::algebra::UnaryOp");
      // };
      // struct Value {
        ctor Value("vcsn::algebra::Value");
      // };
      // struct GenericMatcher {
        ctor GenericMatcher("vcsn::algebra::GenericMatcher");
      // };
      // struct KRatExpMatcher {
        ctor KRatExpMatcher("vcsn::algebra::KRatExpMatcher");
      // };
      // struct KRatExpIdentity {
        ctor KRatExpIdentity("vcsn::algebra::KRatExpIdentity");
      // };
    } // end of namespace algebra
  } // end of namespace vcsn
  namespace vcsn {
    // struct state_h {
      ctor state_h("vcsn::state_h");
    // };
    // struct edge_h {
      ctor edge_h("vcsn::edge_h");
    // };
  } // end of namespace vcsn
  namespace std {
  } // end of namespace std
  namespace vcsn {
    namespace delta_kind {
      // struct edges {
        ctor edges("vcsn::delta_kind::edges");
      // };
      // struct states {
        ctor states("vcsn::delta_kind::states");
      // };
    } // end of namespace delta_kind
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct AutomataBase {
      ctor AutomataBase("vcsn::AutomataBase");
    // };
    // struct automaton_traits {
      ctor automaton_traits("vcsn::automaton_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
    // struct TransposeView {
      ctor TransposeView("vcsn::TransposeView");
    // };
    // struct transpose_traits {
      ctor transpose_traits("vcsn::transpose_traits");
    // };
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
  namespace vcsn {
  } // end of namespace vcsn
} // end of namespace dyn
