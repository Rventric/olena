#!/usr/bin/env python

# Copyright (C) 2003, 2004, 2006  EPITA Research and Development Laboratory
#
# This file is part of the Olena Library.  This library is free
# software; you can redistribute it and/or modify it under the terms
# of the GNU General Public License version 2 as published by the
# Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this library; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.
#
# As a special exception, you may use this file as part of a free
# software library without restriction.  Specifically, if other files
# instantiate templates or use macros or inline functions from this
# file, or you compile this file and link it with other files to
# produce an executable, this file does not by itself cause the
# resulting executable to be covered by the GNU General Public
# License.  This exception does not however invalidate any other
# reasons why the executable file might be covered by the GNU General
# Public License.


import sys, os
import copyright

years = "2003, 2004, 2006"
files = []

def close_files():
    for file in files:
	file.close()

def open_files(path):
    for dim in range(1, 4):
	files.append(open(path + "/swilena_arith%(dim)sd.i" % vars(), 'w'))

def write_headers(copyright_header):
    for dim in range(1, 4):
	file = files[dim - 1]
	file.write("""// Note: this file was generated by generate_arith.py.

""")
	file.writelines(copyright_header)
	file.write("""

%%module swilena_arith%(dim)sd

%%include swilena_config.i

%%include swilena_exception.i
%%include swilena_ntg_macros.i
%%import swilena_ntg.i

%%include swilena_arith.i

%%include swilena_image%(dim)sd.i

decl_arith(%(dim)s)

""" % vars())

def instantiate(dim, algorithm, *args):
    file = files[dim - 1]
    swilena_algorithm = algorithm
    params = args[0]
    for param in args[1:]:
	params += ", " + param
    file.write(
	"%%template(%(algorithm)s) my_%(swilena_algorithm)s< %(params)s >;\n"
	% vars())

def get_bigger_type(type):
    traits = { "ntg_int_u8"  : "ntg_int_u32",
	       "ntg_int_u32" : "ntg_int_u32",
	       "ntg_int_s8"  : "ntg_int_s32",
	       "ntg_int_s32" : "ntg_int_s32" }
    if traits.has_key(type):
	return traits[type]
    return type

def write_algorithms():
    # Algorithms with all types and all dims
    for dim in range(1, 4):
	for type in [ "ntg_bin",
		      "ntg_int_u8", "ntg_int_u32",
		      "ntg_int_s8", "ntg_int_s32",
		      "ntg_float" ]:
            # Work around a bug in SWIG 1.3.29 (fixed since).  We used
            # to refer to `oln::image' from the global (top-level)
            # namespace, i.e. `::oln::image', but it makes swig 1.3.29
            # generate invalid C++ code when used ad a template
            # argument: the space between `<' and `::' is eaten by
            # swig, and `<:' is understood as a trigraph (for `[') by
            # the C++ compiler.
	    img_type = "oln::image%(dim)sd< %(type)s >" % vars()
	    bigger_type = get_bigger_type(type)
	    return_img_type = "oln::image%(dim)sd< %(bigger_type)s >" % vars()

	    # FIXME: these algorithms do not work with bin
            if type != "ntg_bin":
		for algo in [ "plus", "minus", "times", "div" ]:
		    instantiate(dim, algo, return_img_type, img_type, img_type)

	    instantiate(dim, "min", return_img_type, img_type, img_type)
    	    instantiate(dim, "max", return_img_type, img_type, img_type)

def main():
    if len(sys.argv) != 2:
	sys.stderr.write ("Usage: generate_arith_instantiations.py path\n")
	sys.exit (1)
    else:
	path = sys.argv[1]
    open_files(path)
    copyright_header = \
      copyright.notice(os.path.join(path, "copyright.template"), years)
    write_headers(copyright_header)
    write_algorithms()
    close_files()
        
if __name__ == "__main__":
    main()
