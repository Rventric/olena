#! /bin/sh

# Copyright (C) 2003, 2004, 2006  EPITA Research and Development Laboratory
#
# This file is part of the Olena Library.  This library is free
# software; you can redistribute it and/or modify it under the terms
# of the GNU General Public License version 2 as published by the
# Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this library; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
# Boston, MA 02110-1301, USA.
#
# As a special exception, you may use this file as part of a free
# software library without restriction.  Specifically, if other files
# instantiate templates or use macros or inline functions from this
# file, or you compile this file and link it with other files to
# produce an executable, this file does not by itself cause the
# resulting executable to be covered by the GNU General Public
# License.  This exception does not however invalidate any other
# reasons why the executable file might be covered by the GNU General
# Public License.


[ -d "$1" -a -f "$1/expand.sh" -a -f "$1/ChangeLog" ] || \
  { echo "usage: $0 <swilena srcdir>" >&2; exit 1; }

SWILENA=`cd $1 && pwd`

mkdir -p "$SWILENA/src"
mkdir -p "$SWILENA/python"
mkdir -p "$SWILENA/ruby"

years="2003, 2004, 2006"

# Insert a copyright notice whose lines are prefixed by `//'.
copyright_notice_cxx()
{
  sed -e "s|^|// |;s|<YEARS>|$years|" "$SWILENA/src/copyright.template"
}

# Insert a copyright notice whose lines are prefixed by `#'.
copyright_notice_shell()
{
  sed -e "s/^/## /;s/<YEARS>/$years/" "$SWILENA/src/copyright.template"
}

MODULES="$MODULES ntg"
EXTRA_DIST_MODULES=
for dim in 1 2 3; do

  ## C++ header inclusions for basic types.
     cat >"$SWILENA/src/swilena_basics${dim}d.i" <<EOF
// -*- C++ -*-
// Warning: this file was generated by expand.sh

EOF
     copyright_notice_cxx >>"$SWILENA/src/swilena_basics${dim}d.i"
     cat >>"$SWILENA/src/swilena_basics${dim}d.i" <<EOF


%include swilena_basics.i
decl_basics($dim)
EOF
     # Have Automake include these modules in the distribution, but
     # don't create SWIG wrappers for them.
     EXTRA_DIST_MODULES="$EXTRA_DIST_MODULES basics${dim}d"

  ## {1d,2d,3d} families
  for mod in point structelt w_win imagesize image; do
     cat >"$SWILENA/src/swilena_$mod${dim}d.i" <<EOF
// -*- C++ -*-
// Warning: this file was generated by expand.sh

EOF
     # Insert the copyright notice.
     copyright_notice_cxx >>"$SWILENA/src/swilena_$mod${dim}d.i"
     cat >>"$SWILENA/src/swilena_$mod${dim}d.i" <<EOF


%module swilena_$mod${dim}d
%include swilena_$mod.i
decl_$mod($dim)
EOF

     MODULES="$MODULES ${mod}${dim}d"
  done

  ## w_window instances
  for t in int float; do
     echo "make_w_win(w_win${dim}d_$t, $dim, $t)" \
       >>"$SWILENA/src/swilena_w_win${dim}d.i"
  done

  ## Image instances
  cat >>"$SWILENA/src/swilena_image${dim}d.i" <<EOF
%include swilena_ntg_macros.i
%import swilena_ntg.i
EOF
  # int_u8 int_u16 int_s8 int_s16 int_s8s int_s16s int_s32s
  # int_u8s int_u16s int_u32s
  # float_s rgb_8 rgb_16 rgb_32
  cat >> "$SWILENA/src/swilena_image${dim}d.i" <<EOF
make_image(image${dim}d_bin, $dim, ntg_bin, ntg_bin_value)
make_image(image${dim}d_u8, $dim, ntg_int_u8, ntg_int_u8_value)
make_image(image${dim}d_u32, $dim, ntg_int_u32, ntg_int_u32_value)
make_image(image${dim}d_s8, $dim, ntg_int_s8, ntg_int_s8_value)
make_image(image${dim}d_s32, $dim, ntg_int_s32, ntg_int_s32_value)
make_image(image${dim}d_float, $dim, ntg_float, ntg_float_value)
EOF

  TYPES="ntg_bin ntg_int_u8 ntg_int_u32 ntg_int_s8 ntg_int_s32 ntg_float"

  ## Morpho algorithms
  for types in $TYPES; do
      MODULES="$MODULES morpho${dim}d_${types}"
  done
  $SWILENA/generate_morpho_instantiations.py $SWILENA/src

  ## Arith
  MODULES="$MODULES arith${dim}d"
  $SWILENA/generate_arith_instantiations.py $SWILENA/src

  ## Conversions
  MODULES="$MODULES conversions${dim}d"
  $SWILENA/generate_conversions_instantiations.py $SWILENA/src
done # for dim ...

#################### Python stuff #######################

PYMODS=''
PYTHON=''

header_python()
{
cat <<EOF
## Include this file into your Makefile.am -*- Makefile -*-
##
## makefile.swig for swilena/python
## NOTE: this file was generated automatically by expand.sh
##

EOF
copyright_notice_shell
cat <<EOF


AM_CPPFLAGS = -DOLN_EXCEPTIONS \$(PYTHON_CPPFLAGS) \\
  -I\$(srcdir)/../src -I\$(srcdir)/../meta
AM_CXXFLAGS = \$(CXXFLAGS_OPTIMIZE) \$(DOC_CPPFLAGS)
## We build modules, not plain libs.
AM_LDFLAGS = -avoid-version -module -shared \$(ZLIB_LDFLAGS)
AM_SWIG_FLAGS = -c++ -python \$(AM_CPPFLAGS)
EOF
}

dump_python()
{
    echo -n "pyexec_LTLIBRARIES ="
    ilist=0
    for mod in $MODULES; do
      if [ `expr $ilist % 4` = 0 ]; then
         echo " \\"; echo -ne "\t"
      fi
      echo -n " _swilena_$mod.la"
      ilist=`expr $ilist + 1`
    done
    echo; echo
    echo -n "nodist_python_PYTHON ="
    ilist=0
    for mod in $MODULES; do
      if [ `expr $ilist % 4` = 0 ]; then
         echo " \\"; echo -ne "\t"
      fi
      echo -n " swilena_$mod.py"
      ilist=`expr $ilist + 1`
    done
    echo; echo
    for mod in $MODULES; do
      echo "nodist__swilena_${mod}_la_SOURCES = swilena_${mod}_wrap.cc"
    done
    echo; echo
    echo -ne "CLEANFILES= "
    echo -e " swilena_all1d_wrap.cc \\"
    echo -e " swilena_all2d_wrap.cc \\"
    echo -e " swilena_all3d_wrap.cc \\"
    echo -ne " swilena_display_wrap.cc"
    for mod in $MODULES; do
	echo -e "\\"
	echo -ne "\t swilena_$mod.py"
	echo -e "\\"
	echo -ne "\t swilena_$mod.pyc"
	echo -e "\\"
	echo -ne "\t swilena_${mod}_wrap.cc"
    done
    echo; echo

    ilist=0
    for mod in $MODULES; do
      if [ -r "$SWILENA/src/swilena_${mod}.i" ]; then
         sdir=src
      else
         sdir=meta
      fi
      # Rule generating a C++ (*_wrap.cc) and a Python (*.py) wrappers from a
      # SWIG interface.
      #
      # FIXME: The generation of the Python wrapper is separated from
      # the one of the C++ wrapper in this version, and that's not good.
      # We should use Make's trick for multiple outputs (with timestamps)
      # here.
      base="swilena_${mod}"
      src="\$(srcdir)/../$sdir/$base.i"
      dest="${base}_wrap.cc"
      cat <<EOF
$dest: $src
	if \$(SWIG) \$(AM_SWIG_FLAGS) \$(SWIG_FLAGS) -MD -MF \$(DEPDIR)/${base}_wrap.Tcc \$(CPPFLAGS) -o \$@ \$<; \\
	then \\
	  mv -f "\$(DEPDIR)/${base}_wrap.Tcc" "\$(DEPDIR)/${base}_wrap.Pcc"; \\
	else \\
	  rm -f "\$(DEPDIR)/${base}_wrap.Tcc"; exit 1; \\
	fi

@AMDEP_TRUE@@am__include@ @am__quote@./\$(DEPDIR)/${base}_wrap.Pcc@am__quote@

$base.py: $src
	\$(MAKE) \$(AM_MAKEFLAGS) $dest

EOF
    done
}

#################### Ruby stuff #######################

header_ruby()
{
cat <<EOF
## Include this file in your Makefile.am -*- Makefile -*-
##
## makefile.swig for swilena/ruby
## NOTE: this file was generated automatically by expand.sh
##

EOF
copyright_notice_shell
cat <<EOF


AM_CPPFLAGS = -DOLN_EXCEPTIONS \$(RUBY_CPPFLAGS) \\
  -I\$(srcdir)/../src -I\$(srcdir)/../meta
AM_CXXFLAGS = \$(CXXFLAGS_OPTIMIZE) \$(DOC_CPPFLAGS)

## We build modules, not plain libs.
AM_LDFLAGS = -avoid-version -module -shared \$(ZLIB_LDFLAGS)

# On Mac OS X, the Ruby interpreter accepts only files ending in
# \`.bundle\' (and \`.rb\' of course).  Tell Libtool to use the
# \`.bundle\' extension instead of the default \`.so\'.
#
# Moreover, the way the Ruby interpreter uses dynamic module (on Mac
# OS X) is far less tolerant than Python w.r.t. multiply defined
# symbols.  The thing is, unless told to do otherwise, Libtool creates
# flat-namespace modules, which produce name clashes, because some
# symbols are defined multiple times (for instance, the symbol for
# \`oln::image2d\' is provided by \`swilena_image2.la\' and
# \`swilena_arith2d.la').
#
# The nightmare of dynamic modules with multiply defined symbols on Mac OS X.
# ---------------------------------------------------------------------------
#
# To avoid errors on multiply defined symbols, we can use two-level
# namespaces (see the man page of \`ld\' on Mac OS X).  The drawback is
# that until Mac OS X 10.3 (Panther), two-level namespaces
# libraries/modules do not allow undefined symbols, which is a pain in
# our case, since our modules needs symbols provided by the Ruby
# environment.  Anyway, Mac OS X 10.3 solved this with the linker flag
# \`-undefined dynamic_lookup\', postponing the resolution of undefined
# symbols at runtime Since this flag breaks the compatibility with
# previous versions of Mac OS X, the linker requires the environment
# variable MACOSX_DEPLOYMENT_TARGET to be to \`10.3\'. Another glitch is
# the way Libtool interprets the options it gets passed.  One could
# imagine that adding
#
#   -twolevel_namespace -undefined dynamic_lookup
#
# or
#
#   -Wl,-twolevel_namespace -Wl,-undefined -Wl,dynamic_lookup
#
# to AM_LDFLAGS would be sufficient for Libtool to understand that we
# want to create a two-level namespace module with dynamic lookup.
# Alas, things are not that simple.  In fact Libtool still forces the
# creation of a flat namespace module, in spite of the
# \`-twolevel_namespace\' option.
#
# The solution is to insert the flag \`-no-undefined\' first, which turns
# off flat namespaces, then to pass the options above.  And it works,
# at last!
#
# Just remember:
#
#               You must set MACOSX_DEPLOYMENT_TARGET=10.3
#                  in the environment for this to work!
#
# (Setting it to 10.4 on Mac OS X 10.4 (Tiger) might work as well,
# but it has not been tested yet.)
#
# This solution was set up thanks to clues from the Libtool mailing list:
#
#   http://www.mail-archive.com/libtool@gnu.org/msg05785.html
#   http://www.mail-archive.com/libtool@gnu.org/msg06952.html
#   http://lists.gnu.org/archive/html/libtool/2004-10/msg00090.html
#   http://lists.gnu.org/archive/html/libtool/2005-03/msg00061.html
#
if DARWIN
  AM_LDFLAGS += -shrext .bundle \\
    -no-undefined -Wl,-twolevel_namespace -Wl,-undefined -Wl,dynamic_lookup
endif DARWIN
AM_SWIG_FLAGS = -c++ -ruby \$(AM_CPPFLAGS)
EOF
}

dump_ruby()
{
    echo -n "ruby_LTLIBRARIES ="
    ilist=0
    for mod in $MODULES; do
      if [ `expr $ilist % 4` = 0 ]; then
         echo " \\"; echo -ne "\t"
      fi
      echo -n " swilena_$mod.la"
      ilist=`expr $ilist + 1`
    done
    echo; echo
    for mod in $MODULES; do
      echo "nodist_swilena_${mod}_la_SOURCES = swilena_${mod}_wrap.cc"
    done
    echo
    echo -ne "CLEANFILES= "
    echo -e " swilena_all1d_wrap.cc \\"
    echo -e " swilena_all2d_wrap.cc \\"
    echo -e " swilena_all3d_wrap.cc \\"
    echo -ne " swilena_display_wrap.cc"
    for mod in $MODULES; do
	echo -e "\\"
	echo -ne "\t swilena_${mod}_wrap.cc"
    done
    echo; echo

    echo "ruby_DATA ="
    echo

    ilist=0
    for mod in $MODULES; do
      if [ -r "$SWILENA/src/swilena_${mod}.i" ]; then
         sdir=src
      else
         sdir=meta
      fi
      # Rule generating a C++ (*_wrap.cc) wrapper for Ruby from a SWIG
      # interface.
      base="swilena_${mod}"
      src="\$(srcdir)/../$sdir/$base.i"
      dest="${base}_wrap.cc"
      cat <<EOF
$dest: $src
	if \$(SWIG) \$(AM_SWIG_FLAGS) \$(SWIG_FLAGS) -MD -MF \$(DEPDIR)/${base}_wrap.Tcc \$(CPPFLAGS) -o \$@ \$<; \\
	then \\
	  mv -f "\$(DEPDIR)/${base}_wrap.Tcc" "\$(DEPDIR)/${base}_wrap.Pcc"; \\
	else \\
	  rm -f "\$(DEPDIR)/${base}_wrap.Tcc"; exit 1; \\
	fi

@AMDEP_TRUE@@am__include@ @am__quote@./\$(DEPDIR)/${base}_wrap.Pcc@am__quote@

EOF

# Work around an issue between Libtool and Ruby on Mac OS X.
# Libtool generates dynamic modules ending in `.so', but the Ruby
# interpreter accepts only files ending in `.bundle' (and obviously
# `.rb') as arguments of the `require' method.  Hence we create
# aliases for the .so files to make them appear as .bundle's
# to ruby.
      cat <<EOF
ruby_DATA+ = .libs/$base.bundle
.libs/$base.bundle: .libs/$base.so $base.la
	cd .libs && \$(LN_S) -f $base.so $base.bundle

EOF
    done

    echo -n "CLEANFILES += \$(ruby_DATA)"
}

############ Generic stuff ###########

header_src() {
    cat <<EOF
## Include this file in your Makefile.am
##
## makefile.swig for swilena/src
## NOTE: this file was generated automatically by expand.sh
##
EOF
}

dump_src() {
    echo -n "EXTRA_DIST ="
    ilist=0
    for mod in $MODULES $EXTRA_DIST_MODULES; do
      if [ -r "$SWILENA/src/swilena_${mod}.i" ]; then
         if [ `expr $ilist % 4` = 0 ]; then
	    echo " \\"
            echo -ne "\t"
	 fi
	 echo -n " swilena_${mod}.i"
	 ilist=`expr $ilist + 1`
      fi
    done
    echo
}

############ Output ###############

header_src >"$SWILENA/src/makefile.swig"
dump_src >>"$SWILENA/src/makefile.swig"
header_python >"$SWILENA/python/makefile.swig"
dump_python >>"$SWILENA/python/makefile.swig"
header_ruby >"$SWILENA/ruby/makefile.swig"
dump_ruby >>"$SWILENA/ruby/makefile.swig"
