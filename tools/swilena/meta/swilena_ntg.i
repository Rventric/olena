%module swilena_ntg
%include swilena_exception.i


/***** Generic class declaration for scalars ******/
%define decl_scalar_class(Ns, Name, ValueType)
template<unsigned nbits, typename behavior>
class Name
{
 public:
  Name();
  Name(ValueType);

  %extend {
    ValueType value() const
      { return (*self); }
    void value(ValueType x) 
      { *self = Ns::Name<nbits, behavior>(x); }

#if defined(SWIGPYTHON) || defined(SWIGRUBY)
    Ns::Name<nbits, behavior> operator+ (const Ns::Name<nbits, behavior>& other) const { return (*self) + other; }
    Ns::Name<nbits, behavior> operator- (const Ns::Name<nbits, behavior>& other) const { return (*self) - other; }
    Ns::Name<nbits, behavior> operator* (const Ns::Name<nbits, behavior>& other) const { return (*self) * other; }
    Ns::Name<nbits, behavior> operator/ (const Ns::Name<nbits, behavior>& other) const { return (*self) / other; }
    Ns::Name<nbits, behavior> operator+ (ValueType other) const { return (*self) + other; }
    Ns::Name<nbits, behavior> operator- (ValueType other) const { return (*self) - other; }
    Ns::Name<nbits, behavior> operator* (ValueType other) const { return (*self) * other; }
    Ns::Name<nbits, behavior> operator/ (ValueType other) const { return (*self) / other; }
#else
    Ns::Name<nbits, behavior> add (const Ns::Name<nbits, behavior>& other) const { return (*self) + other; }
    Ns::Name<nbits, behavior> sub (const Ns::Name<nbits, behavior>& other) const { return (*self) - other; }
    Ns::Name<nbits, behavior> mul (const Ns::Name<nbits, behavior>& other) const { return (*self) * other; }
    Ns::Name<nbits, behavior> div (const Ns::Name<nbits, behavior>& other) const { return (*self) / other; }
    Ns::Name<nbits, behavior> add (ValueType other) const { return (*self) + other; }
    Ns::Name<nbits, behavior> sub (ValueType other) const { return (*self) - other; }
    Ns::Name<nbits, behavior> mul (ValueType other) const { return (*self) * other; }
    Ns::Name<nbits, behavior> div (ValueType other) const { return (*self) / other; }
#endif

#if defined(SWIGPYTHON)
    Ns::Name<nbits, behavior>& operator+= (const Ns::Name<nbits, behavior>& other) { return (*self) += other; }
    Ns::Name<nbits, behavior>& operator-= (const Ns::Name<nbits, behavior>& other) { return (*self) -= other; }
    Ns::Name<nbits, behavior>& operator*= (const Ns::Name<nbits, behavior>& other) { return (*self) *= other; }
    Ns::Name<nbits, behavior>& operator/= (const Ns::Name<nbits, behavior>& other) { return (*self) /= other; }
    Ns::Name<nbits, behavior>& operator+= (ValueType other) { return (*self) += other; }
    Ns::Name<nbits, behavior>& operator-= (ValueType other) { return (*self) -= other; }
    Ns::Name<nbits, behavior>& operator*= (ValueType other) { return (*self) *= other; }
    Ns::Name<nbits, behavior>& operator/= (ValueType other) { return (*self) /= other; }
#elseif !defined(SWIGRUBY) // These operators are generated by default in Ruby
    Ns::Name<nbits, behavior>& iadd (const Ns::Name<nbits, behavior>& other) { return (*self) += other; }
    Ns::Name<nbits, behavior>& isub (const Ns::Name<nbits, behavior>& other) { return (*self) -= other; }
    Ns::Name<nbits, behavior>& imul (const Ns::Name<nbits, behavior>& other) { return (*self) *= other; }
    Ns::Name<nbits, behavior>& idiv (const Ns::Name<nbits, behavior>& other) { return (*self) /= other; }
    Ns::Name<nbits, behavior>& iadd (ValueType other) { return (*self) += other; }
    Ns::Name<nbits, behavior>& isub (ValueType other) { return (*self) -= other; }
    Ns::Name<nbits, behavior>& imul (ValueType other) { return (*self) *= other; }
    Ns::Name<nbits, behavior>& idiv (ValueType other) { return (*self) /= other; }
#endif

#if defined(SWIGPYTHON) || defined(SWIGRUBY)
    bool operator< (const Ns::Name<nbits, behavior>&  other) const { return (*self) < other; }
    bool operator> (const Ns::Name<nbits, behavior>&  other) const { return (*self) > other; }
    bool operator<= (const Ns::Name<nbits, behavior>&  other) const { return (*self) <= other; }
    bool operator>= (const Ns::Name<nbits, behavior>&  other) const { return (*self) >= other; }
    bool operator== (const Ns::Name<nbits, behavior>&  other) const { return (*self) == other; }
    bool operator< (ValueType other) const { return (*self) < other; }
    bool operator> (ValueType other) const { return (*self) > other; }
    bool operator<= (ValueType other) const { return (*self) <= other; }
    bool operator>= (ValueType other) const { return (*self) >= other; }
    bool operator== (ValueType other) const { return (*self) == other; }
#else
    bool lt (const Ns::Name<nbits, behavior>&  other) const { return (*self) < other; }
    bool gt (const Ns::Name<nbits, behavior>&  other) const { return (*self) > other; }
    bool le (const Ns::Name<nbits, behavior>&  other) const { return (*self) <= other; }
    bool ge (const Ns::Name<nbits, behavior>&  other) const { return (*self) >= other; }
    bool eq (const Ns::Name<nbits, behavior>&  other) const { return (*self) == other; }
    bool lt (ValueType other) const { return (*self) < other; }
    bool gt (ValueType other) const { return (*self) > other; }
    bool le (ValueType other) const { return (*self) <= other; }
    bool ge (ValueType other) const { return (*self) >= other; }
    bool eq (ValueType other) const { return (*self) == other; }
#endif

#if defined(SWIGPYTHON)
    bool operator!= (const Ns::Name<nbits, behavior>&  other) const { return (*self) != other; }
    bool operator!= (ValueType other) const { return (*self) != other; }
#elseif !defined(SWIGRUBY)
    bool ne (const Ns::Name<nbits, behavior>&  other) const { return (*self) != other; }
    bool ne (ValueType other) const { return (*self) != other; }
#endif

  }

  EXTEND_DESCRIBE2(Ns::Name<nbits, behavior>);
};  
%enddef

/****** Generic class declaration for booleans *****/
%define decl_bin_class(Ns, Name, ValueType)
class Name
{
 public:
  Name();
  Name(ValueType);

  %extend {
    ValueType value() const
      { return (*self); }
    void value(ValueType x) 
      { *self = Ns::Name(x); }

#if defined(SWIGPYTHON)
    Ns::Name operator| (const Ns::Name& other) const { return (*self) | other; }
    Ns::Name operator| (ValueType other) const { return (*self) | other; }
    Ns::Name operator& (const Ns::Name& other) const { return (*self) & other; }
    Ns::Name operator& (ValueType other) const { return (*self) & other; }
    Ns::Name operator^ (const Ns::Name& other) const { return (*self) ^ other; }
    Ns::Name operator^ (ValueType other) const { return (*self) ^ other; }
    Ns::Name& operator|= (const Ns::Name& other) { return (*self) |= other; }
    Ns::Name& operator|= (ValueType other) { return (*self) |= other; }
    Ns::Name& operator&= (const Ns::Name& other) { return (*self) &= other; }
    Ns::Name& operator&= (ValueType other) { return (*self) &= other; }
    Ns::Name& operator^= (const Ns::Name& other) { return (*self) ^= other; }
    Ns::Name& operator^= (ValueType other) { return (*self) ^= other; }
    bool operator< (const Ns::Name&  other) const { return (*self) < other; }
    bool operator== (const Ns::Name&  other) const { return (*self) == other; }
    bool operator!= (const Ns::Name&  other) const { return (*self) != other; }
    bool operator< (ValueType other) const { return (*self) < other; }
    bool operator== (ValueType other) const { return (*self) == other; }
    bool operator!= (ValueType other) const { return (*self) != other; }
#else
    Ns::Name lor (const Ns::Name& other) const { return (*self) | other; }
    Ns::Name lor (ValueType other) const { return (*self) | other; }
    Ns::Name land (const Ns::Name& other) const { return (*self) & other; }
    Ns::Name land (ValueType other) const { return (*self) & other; }
    Ns::Name lxor (const Ns::Name& other) const { return (*self) ^ other; }
    Ns::Name lxor (ValueType other) const { return (*self) ^ other; }
    Ns::Name& ilor (const Ns::Name& other) { return (*self) |= other; }
    Ns::Name& ilor (ValueType other) { return (*self) |= other; }
    Ns::Name& iland (const Ns::Name& other) { return (*self) &= other; }
    Ns::Name& iland (ValueType other) { return (*self) &= other; }
    Ns::Name& ilxor (const Ns::Name& other) { return (*self) ^= other; }
    Ns::Name& iixor (ValueType other) { return (*self) ^= other; }
    bool lt (const Ns::Name&  other) const { return (*self) < other; }
    bool eq (const Ns::Name&  other) const { return (*self) == other; }
    bool ne (const Ns::Name&  other) const { return (*self) != other; }
    bool lt (ValueType other) const { return (*self) < other; }
    bool eq (ValueType other) const { return (*self) == other; }
    bool ne (ValueType other) const { return (*self) != other; }
#endif

  }

  EXTEND_DESCRIBE(Ns::Name);
};  
%enddef
    
%define decl_complex()
template<typename repr, typename T>
class cplx
{
 public:
  cplx(const T& p1 = 0, const T& p2 = 0);
  cplx(const ntg::cplx<repr, T>& other);

  const float_d real() const;
  const float_d imag() const;
  const T magn() const;
  const T angle() const;
  const T first() const;
  const T second() const;
  
  ntg::cplx<repr, T> conj() const;

  %extend {
    ntg::cplx<repr, T>& set(const T& p1, const T& p2)
      { return (*self) = ntg::cplx<repr, T>(p1, p2); }
    ntg::cplx<repr, T>& set(const ntg::cplx<repr, T>& other)
      { return (*self) = ntg::cplx<repr, T>(other); }
  }

  EXTEND_DESCRIBE2(ntg::cplx<repr, T>)
};
%enddef

%define decl_ntg()
%include <ntg/vect/cplx_representation.hh>
%include <ntg/core/predecls.hh>
%{
#include <ntg/all.hh>
%}

%include swilena_describe.i

namespace ntg
{

  decl_scalar_class(ntg, int_u, unsigned long)
  decl_scalar_class(ntg, int_s, long)
  decl_bin_class(ntg, bin, bool)

  decl_complex()

}
%enddef

decl_ntg()

/* 
   Macro are defined for every type and should be used in all modules
   Using ntg::int_u32 (the typedef in predecls.hh) directly leads to
   type matching problems:

  - it is a typedef never used in module swilena_ntg
    => no type correspondence is created between ntg::int_u32 
       and ntg::int_u<32, ntg::strict>.

  - if another module use ntg::int_u32, operations on it won't be
    possible since this module won't recognize the type ntg::int_u32.

  - ntg::int_u<32, ntg::strict> or ntg_uint should be used
    everywhere. ntg_uint is just a convenient macro.
*/

#define ntg_bin ntg::bin

%template(uint)  ntg::int_u< 32, ntg::strict >;
#define ntg_uint ntg::int_u< 32, ntg::strict >

%template(sint)  ntg::int_s< 32, ntg::strict >;
#define ntg_sint ntg::int_s< 32, ntg::strict >

#define ntg_float ntg::float_d

%template(cplx_rect)  ntg::cplx< ntg::rect, ntg_float >;
#define ntg_cplx_rect ntg::cplx< ntg::rect, ntg_float >

%template(cplx_polar)  ntg::cplx< ntg::polar, ntg_float >;
#define ntg_cplx_polar ntg::cplx< ntg::polar, ntg_float >
